! Last update 04/12/2025

! Dic. 2025:
! Cambiato il modo di gestire gli istanti dell'inizio e della fine di esecuzione
! gestiti da inst_start e inst_stop in premoloch.inp, 
! si puo' fare qualsiasi combinazione basta che inst_start <= inst_stop;
! si puo' applicare il premoloch sia in modo seriale che in modo parallelo
! sia con input_file_std = 1 (united file) che con input_file_std = 2 (separated files).
! Nuovo campo in mhf_soil: cswfl_down (downward shortwave radiation flux). 

! Sett. 2024: 
! Cambiamento in subroutine physiographic_param (def_soil.F90) e scrittura
! di model_param_constant.bin - piu' ordine, eliminazione dei passaggi 
! inutile. 
! Nuovo formato mhf di Bolam in input: lettura di mhf record non 1d ma 2d

! Giu. 2024:
! Nuovo formato mhf: scrittura e lettura di mhf record non 1d ma 2d

!------------------------------------------------------------------------------
! Prepares MOLOCH input fields (initial and boundary files) interpolating from input model data.
!
! Input ("input data") may be:
! 1) in BOLAM MHF format, generated by BOLAM or GLOBO model, on staggered rotated/or not lat-lon regular grid at hybrid model levels;
! 2) in the own MOLOCH MHF format on staggered MOLOCH grid at zita model levels;
! 3) in grib2 format data of IFS-ECMWF on rotated/or not lat-lon regular grid, at isobaric or hybrid model levels;
! 4) in grib2 format data of GFS-NCEP (USA) on rotated/or not lat-lon regular grid, at isobaric levels.
! 5) in grib2 format data of COSMO model on staggered rotated/or not lat-lon regular grid, at hybrid model levels.
!
! Output in MOLOCH MHF format on staggered MOLOCH grid ("model").
! The centre of rotation of the MOLOCH ("model" below) grid, having geographical
! coordinates X0, Y0, can be defined independently of the centre of rotation of the
! input model ("input grid data"), having geographical coordinates X0_INP, Y0_INP.
! However, in order to avoid possible errors introduced by the grid-rotation
! (especially for the wind rotation and in particular near the poles),
! use of coincident rotation centres is suggested.
! If the MOLOCH domain is close to a pole (> 85 deg N or S) or if the MOLOCH rotation
! centre is not in the range -180.,360.; -90,90, then the MOLOCH rotation centre is forced
! to be the same as that of the input model.

!------------------------------------------------------------------------------
! Input data must include the following parameters:
!          at atmosphere levels:
! temperature (t), u-component of wind (u), v-component of wind (v),
! specipic humidity (q) exluding of GFS data case when relative humidity (rh) is requested,
! geopotential (phi) in the isobaric level case or
! parameters of vertical coordinate (ak, bk) in the hybrid level case,
! geopotential at the lowest model level in the hybrid level case of IFS,
! optionally total cloud water content (qc) or liquid (qcw) and ice (qci) cloud water content separately;
!         at the surface:
! lan-sea fraction (1-land, 0-sea),
! surface geopotential or geometric hight of topography,
! surface pressure in the case of atmospheric hybrid levels,
! water content of snow cover (in m equiv. water);
! optionally surface temperature,
! optionally sea ice fraction,
! optionally sea ice thikness in the case of GFS data or sea ice temperature in the case of IFS data,
! soil type (excluding GFS data case) in the case of soil moisture in the therm
! of absolute or speific water content (not relative water content);
!         at the soil levels:
! soil temperatute;
! soil soil moisture, either speific (absolute) water content or relative water content.

!------------------------------------------------------------------------------

module model

! ------  Model grid parameters ------

! Parameters values read from file premoloch.inp

 integer :: nlon, nlat, nlev, nlevg, nlevp1, ntot, nnn
 integer, parameter :: nlevg0=20, nlevsnow=11
 real :: dlon, dlat, x0, y0, alon0, alat0
 real, dimension(20) :: soil_lev0
 real, dimension(:), allocatable :: soil_lev

! NLON, NLAT, NLEV: dimensions of the (rotated) model grid
! NLEVG : number of soil levels used in model
! DLON, DLAT: resolution in degrees
! X0, Y0: coordinates in deg of the centre of rotation of the output model grid
! (normally near the centre of the grid itself - point "T" of the Arakawa grid).

! ALON0, ALAT0: coord. of the SW corner (point "v") of the model grid, in its own coordinates.
! In case of non rotated grid, ALON0, ALAT0 must define the true coordinates of the SW corner
! and DLON should be set to DLAT/COS(ALAT0) where ALAT0 is a mean latitude of the model grid.
! SOIL_LEV0: depth (m) of model soil levels, 
! if SOIL_LEV0(K)=-9999., then number of soil level is defined equal K-1. 

! ------- Basic parameters ---------

 integer, dimension(50) :: nfdr
 real, dimension(100)   :: pdr

 integer, dimension(5) :: idate0
 integer, dimension(3) :: iperiod

! ----- Fields --------

 real, dimension(:), allocatable :: fz, fzh
 real, dimension(:,:,:), allocatable :: zeta, zetah, zeta_u, zeta_v, fmz, fmzh, &
     p, u, v, w, t, q, qcw, qci, tvirt, tice, soil_map, veg_map, soilvegpar
 real, dimension(:,:), allocatable :: fmask, phig, phig0, ps, tsurf, tgsurf, qvsurf, qgsurf, &
     water_table_depth, tg_bottom, qg_rel_bottom, qg_rel_surf_approx, &
     cloudt, totpre, snfall, runoff, snow, cswfl, cswfl_down, clwfl, chflux, cqflux,        &
     t2min, t2max, ws10max, albedo, emismap1, emismap2, rgm, rgq, fice, iceth, &
     soil_albedo_dry, soil_albedo_wet, soil_emiss1_dry, soil_emiss1_wet, soil_emiss2_dry, soil_emiss2_wet, &
     veg_lai, veg_frac, veg_root_depth, veg_roughness, veg_albedo, veg_emiss1, veg_emiss2, snow_dirt, fice_soil_surf
 real, dimension(:,:,:), allocatable :: tg, qg, tg_first_guess, qg_rel_first_guess, fice_soil, &
 soil_qmax, soil_qmin, soil_c, soil_rho, soil_psi, soil_k, soil_par_b, soil_par_c, soil_qrel_wilt, soil_qrel_ref, &
 snow_lev, snow_t, snow_fice, snow_age, snow_melt_age, snow_dens
 real :: veg_lai_max
 integer, dimension(:,:), allocatable :: ind_lev_soil_h_bottom, ind_lev_soil_w_bottom
 real, dimension(:,:), allocatable :: htopvar, m_rough, q_rough,  &
     htop_inp_mod, htop_atm_inp_mod, alon_t, alat_t, alon_rot, alat_rot, d2
 real, dimension(:,:), allocatable :: alon_u, alon_v, alat_u, alat_v, &
      x_t, x_u, x_v, y_t, y_u, y_v
 real :: dx, dy

! Copies
 integer :: iflag_soil_snow_frc
 real, dimension(:,:), allocatable :: tsurf_copy, iceth_frc, fice_frc, &
 tsurf_frc, tgsurf_frc, qvsurf_frc, qgsurf_frc, fice_soil_surf_frc, snow_frc
 real, dimension(:,:,:), allocatable :: tg_copy, tg_frc, qg_frc, fice_soil_frc, &
 snow_lev_frc, snow_t_frc, snow_fice_frc, snow_age_frc, snow_melt_age_frc, snow_dens_frc

end module model
!------------------------------------------------------------------------------
module input_data

! ------  Input grid parameters ------

! input_format: source of input model grid data: 'grib2' for IFS, GFS, COSMO;
!               'mhfb' for Bolam and Globo (Globo-generated MHF file);
!               'mhfm' for Moloch (self-nesting).
! input_file_std: valid for INPUT_FORMAT = 'mhfb' and 'mhfm':
!       type of input data - 1: a single file including many instants;
!                            2: different files, one for each instant.
! INPUT_MODEL: name of the model prodiced input data ('IFS' or 'GFS' or 'BOLAM' or 'MOLOCH' or 'COSMO')

 character (len=10) :: input_model, input_format
 integer :: input_file_std=0

! Parameters values read from input file

 integer :: nlon_inp0, nlon_inp, nlat_inp, nlev_inp, nlevg_inp, nlev_atm_inp_max, nlev_soil_inp_max, res_change, ifl_xf
 real :: dlon_inp, dlat_inp, x0_inp, y0_inp, alon0_inp, alon0_inp_ini, alat0_inp, flag_rot_inp=0, flag_cut_paste

! ------- Basic parameters ---------

 integer :: npar3d=20, npar2d=50, npar3d_soil=10, level_type=0
 integer, dimension(5) :: idate0_inp
 integer, dimension(3) :: iperiod_inp
 integer, dimension(4) :: iperiod_inp_grib2

! For 3D input data fields at model hybrid or sigma levels:
! AK and BK vectors are used to define pressure on IFS, or Bolam, or Globo model levels

 real, dimension(:), allocatable :: ak, bk, lev_list_inp, soil_lev_inp

! ----- Fields --------

 real, dimension(:,:,:,:), allocatable :: field3d, field3d_soil
 real, dimension(:,:,:), allocatable   :: field2d

 real, dimension(:,:), allocatable :: alon_t_inp, alon_u_inp, alon_v_inp, alat_t_inp, &
       alat_u_inp, alat_v_inp, psl_inp, u_inp_rot, v_inp_rot
 real, dimension(:), allocatable :: x_t_inp, x_u_inp, y_t_inp, y_v_inp

 real, dimension(:,:,:), allocatable :: zeta_inp, zetah_inp, u_inp, v_inp, w_inp, t_inp, tvirt_inp, q_inp, qc_inp, &
                qcw_inp, qci_inp, p_inp, tg_inp, qg_inp, tice_inp, qgmax_inp, qgmin_inp
 real, dimension(:,:), allocatable :: fmask_inp, fmask_inp_save, htop_inp, htop_inp_save, htop_atm_inp, htop_atm_inp_save, &
                ps_inp, tsurf_inp, qvsurf_inp, &
                snow_inp, fice_inp, iceth_inp, d2_inp, alon_rot_inp, alat_rot_inp

 integer, dimension(:,:), allocatable :: mask_frame
 logical :: frame

end module input_data
!------------------------------------------------------------------------------
module parameters

! Parameter values read from file premoloch.inp

 integer :: inst_start, inst_stop

! NST is soil type number, NVT is veg_maption type number
! NSVVAR is a reserved number for soil-veg_maption variable fields

 integer, parameter :: nst=31, nvt=22, nsvvar=50

! No. of days of each month

 integer, dimension(12) :: imon=(/31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31/)

! Physical constants

 real, parameter :: rd=287.05, cp=1004.6, rcp=rd/cp, p0=1000.e2, g0=9.807,      &
                    rv=461.51, eps=rd/rv, ep=rv/rd-1., pzer=1.e5, tzer=273.15,  &
                    h=rd*273.32/g0, a=6371.e+3, pi=abs(acos(-1.))
 real :: dz, gamma, gammac, gamma_inp, coeday, a0, b0
 real :: val_missing=-9999.
 logical :: surf_elaborate

    CONTAINS

    function gzita (zita)    ! Decay function
    gzita = 1. -a0*(zita/h)-(3.-2.*a0)*(zita/h)**2 +(2.-a0)*(zita/h)**3
    end function gzita

    function gzitap (zita)   ! Derivative of decay function
    gzitap = (-a0-(6.-4.*a0)*(zita/h) +(6.-3.*a0)*(zita/h)**2)/h
    end function gzitap

    function bzita (zita)    ! Stretching function
    bzita = b0 + (1.-b0)*(zita/h)
    end function bzita

    function bzitap (zita)   ! Derivative of stretching function
    bzitap = (1.-b0)/h
    end function bzitap

end module parameters
!------------------------------------------------------------------------------
program premoloch

use model
use input_data
use parameters

implicit none

namelist/param_premoloch/ input_format, input_file_std, &
                          nlon, nlat, nlev, dlon, dlat, x0, y0, alon0, alat0, &
                          a0, b0, soil_lev0, inst_start, inst_stop, &
                          nlev_atm_inp_max, nlev_soil_inp_max

! Strings for input files names

character (len=8), dimension(:), allocatable :: input_file
character (len=20), dimension(:), allocatable :: input_file_atm, input_file_soil
character (len=80) :: file_name_work, file_name_work_atm, file_name_work_soil
logical :: lex, lex2

integer :: icentre_inp, isubcentre_inp, imodel_inp

integer :: ifl_land=0
character (len=20) :: fl_land='land_par.bin'

real, dimension(20) :: point_extr, point_extr_inp
real, dimension(:,:), allocatable :: ps_inp_mod, hx_slope, hy_slope, &
      u_u_inp_mod_rot, u_v_inp_mod_rot, v_u_inp_mod_rot, v_v_inp_mod_rot, u_inp_work, v_inp_work, tsurf_work, tsurf_work_inp
real, dimension(:,:,:), allocatable :: u_inp_mod, v_inp_mod, w_inp_mod, &
      t_inp_mod, q_inp_mod, qcw_inp_mod, qci_inp_mod, p_inp_mod, tvirt_inp_mod, &
      zeta_inp_mod, zetah_inp_mod
real, dimension(200) :: zlinp, zlout, zfinp, zfout
integer, dimension(200) :: iv

integer :: inst, ninst, inst2, in, i, j, k, &
           flag_constant_fields, &
           nday, ndm, iimon, ndayr, lbot, nsmooth, jlon, jlat,  &
           ip1, im1, jp1, jm1, k1, nnn1, nnn2, nnn3, iframe, kb, ipoint, jpoint, &
           lev_soil_ref=3
real :: zg, zita, zitah, day, al, dphig, zps, zphig, ztvirt, ztvirtmed, zframe,    &
        ztvirt1, zsigalf, zqs, zq, zwater, fracw, zsigmed, zsigalfm1, zdelta,      &
        zgam2, zrh, we, zlatt, zb, zc, zc1, zzz, zz1, zz2, z1, z2, z3, zuhx, zvhy, &
        zzz1, zzz2, zzz3, zzz4, zzz5, zzz6, zzz7, zital, zitahl, umax, vmax, wmax, &
        zk1, ztk, w1, zlap, zrh1, zdsigalf
integer, dimension(3) :: indumax, indvmax, indwmax
integer, parameter :: npoint=0
real, dimension(npoint,1) :: lon_point=reshape((/11.34/),(/npoint,1/)), &
 lat_point=reshape((/44.49/),(/npoint,1/)), lon_rot_point, lat_rot_point

! Definition of (output) model grid parameters and other parameters

 open (11, file='premoloch.inp', status='old')
 read (11, param_premoloch)
 close (11)
 print *,'Parameters of pre-moloch (defined in premoloch.inp):'
 print param_premoloch

!--------------------------------------------------------------------------

 dz=h/float(nlev)
 frame = .false. ! it is assumed that full fields are available, unless possibly in case of IFS fc. data

!--------------------------------------------------------------------------
! Input data
!--------------------------------------------------------------------------

 ninst=max(inst_stop-inst_start+1, 1)

 allocate(input_file(ninst))
 allocate(input_file_atm(ninst))
 allocate(input_file_soil(ninst))

 if (input_format == 'grib2' .or. input_format == 'GRIB2') then
   input_file(:) = "grib_000"
 elseif (input_format == 'mhfb' .or. input_format == 'MHFB' .and. input_file_std == 2) then
   input_file_atm(:) = "mhfb_000_atm"
   input_file_soil(:) = "mhfb_000_soil"
 elseif (input_format == 'mhfm' .or. input_format == 'MHFM' .and. input_file_std == 2) then
   input_file_atm(:) = "mhfm_000_atm"
   input_file_soil(:) = "mhfm_000_soil"
 endif

 do i = 1,ninst
   write (input_file(i)(6:8),'(i3.3)') i+inst_start-1
   write (input_file_atm(i)(6:8),'(i3.3)') i+inst_start-1
   write (input_file_soil(i)(6:8),'(i3.3)') i+inst_start-1
 enddo

 if (input_file_std == 1) then ! case of Bolam/Globo mhf or Moloch mhf file
   if (input_format == 'mhfb' .or. input_format == 'MHFB') then
     input_file_atm(:)  = "mhfb_atm"
     input_file_soil(:) = "mhfb_soil"
   endif
   if (input_format == 'mhfm' .or. input_format == 'MHFM') then
     input_file_atm(:)  = "mhfm_atm"
     input_file_soil(:) = "mhfm_soil"
   endif
 endif

 file_name_work = input_file(1)
 if (input_format == 'mhfb' .or. input_format == 'MHFB' .or. input_format == 'mhfm' .or. input_format == 'MHFM') then
   file_name_work      = input_file_atm(1)
   file_name_work_atm  = input_file_atm(1)
   file_name_work_soil = input_file_soil(1)
 endif

 do while (.true.)
   inquire(file=file_name_work,exist=lex)
   if (lex) exit
   print *,"Input file ",trim(file_name_work)," not available"
#ifdef oper
   inquire(file='premoloch_stop.txt',exist=lex2)
   if (lex2) then
     print *,"Found file premoloch_stop.txt, demand to program stop"
     stop
   endif
   print *,"Waiting (sleep) 30 s"
   call sleep (30)
#else
   stop
#endif
 enddo

!--------------------------------------------------------------------------
! Allocation of arrays

   allocate(ak     (nlev_atm_inp_max+1))
   allocate(bk     (nlev_atm_inp_max+1))
   allocate(lev_list_inp(nlev_atm_inp_max))
   allocate(soil_lev_inp(nlev_soil_inp_max))

!--------------------------------------------------------------------------

! Definitions of input data provider centre (input model) and origin of rotated input grid

  if (input_format == 'grib2' .or. input_format == 'GRIB2') then
    call read_grib2_data(1,file_name_work,1,.true.,flag_cut_paste,icentre_inp,isubcentre_inp,imodel_inp, &
              nlon_inp0,nlat_inp,nlev_inp,nlev_atm_inp_max,nlevg_inp,nlev_soil_inp_max, &
              x0_inp,y0_inp,alon0_inp,alat0_inp,dlon_inp,dlat_inp,idate0_inp,iperiod_inp_grib2, &
              lev_list_inp,soil_lev_inp,level_type, &
              npar3d,npar2d,npar3d_soil,field3d,field2d,field3d_soil,ak,bk,val_missing)
    if (icentre_inp == 98) then
      input_model = 'IFS'
    elseif (icentre_inp == 7) then
      input_model = 'GFS'
    elseif (icentre_inp == 80.and.isubcentre_inp == 103) then ! 80 - centre Rome RSMC, Italy, 103 - subcentre Bologna ARPAE-SIMC, Italy
      input_model = 'COSMO'
    else
      print *
      print *,'Centre of input model data not identified:', icentre_inp
      stop
    endif
  elseif (input_format == 'mhfb' .or. input_format == 'MHFB') then ! BOLAM
    icentre_inp = 80                          ! identifies Rome RSMC, Italy
    isubcentre_inp = 102                      ! identifies CNR-ISAC, Italy
    input_model = 'BOLAM'
    imodel_inp = 1
    call read_bolam_mhf_data(0,file_name_work_atm,file_name_work_soil,input_file_std,.true., &
              nlon_inp0,nlat_inp,nlev_inp,nlev_atm_inp_max,nlevg_inp,nlev_soil_inp_max, &
              x0_inp,y0_inp,alon0_inp,alat0_inp,dlon_inp,dlat_inp,idate0_inp,iperiod_inp, &
              lev_list_inp,soil_lev_inp,level_type,  &
              npar3d,npar2d,npar3d_soil,field3d,field2d,field3d_soil,ak,bk,val_missing)
  elseif (input_format == 'mhfm' .or. input_format == 'MHFM') then ! MOLOCH
    icentre_inp = 80                          ! identifies Rome RSMC, Italy
    isubcentre_inp = 102                      ! identifies CNR-ISAC, Italy
    input_model = 'MOLOCH'
    imodel_inp = 2
    call read_moloch_mhf_data(0, file_name_work_atm, file_name_work_soil, input_file_std, .true., &
         nlev_atm_inp_max, nlev_soil_inp_max, nlon_inp0, nlat_inp, nlev_inp, nlevg_inp, &
         x0_inp, y0_inp, alon0_inp, alat0_inp, dlon_inp, dlat_inp, &
         level_type, lev_list_inp, soil_lev_inp, idate0_inp, iperiod_inp, &
 frame, mask_frame, &
        htop_inp, fmask_inp, ps_inp, &
        zeta_inp, zetah_inp, p_inp, t_inp, u_inp, v_inp, w_inp, q_inp, qcw_inp, qci_inp, &
        tg_inp, qg_inp, tsurf_inp, qvsurf_inp, snow_inp, fice_inp, iceth_inp, qgmax_inp, qgmin_inp)
  else
    print *
    print *,'Input data format not identified:', input_format
    stop
  endif

  print *
  print *,'     Input data from ',input_model
  print *

!--------------------------------------------------------------------------

 if (abs(x0_inp)>0.01.or.abs(y0_inp)>0.01) then
   flag_rot_inp=1
 else
   flag_rot_inp=0
 endif

 if (x0<-180.or.x0>360.or.y0<-90.or.y0>90.) then
   x0=x0_inp
   y0=y0_inp
   print *,'Centre of coordinate rotation (same values of input grid is prescribed):'
   print *,' x0=',x0,' y0=',y0
 endif

!--------------------------------------------------------------------------

! Soil level definition

  k=0
  do while (.true.)
    k=k+1
    if (int(soil_lev0(k)) == -9999) exit
  enddo
  nlevg=k-1
  if (nlevg < 1) then
    print *,"Depth of soil leveld, defined in namelist, not valid, stop"
    print *,"SOIL_LEV0: ",soil_lev0(:)
    stop
  endif
  allocate (soil_lev(nlevg))
  soil_lev(1:nlevg) = soil_lev0(1:nlevg)

 print*
 print*, "Depth (cm) of soil layers:"
 do k=1,nlevg
  print '(i3,2f8.1)', k, soil_lev(k)*1.e2
 enddo
 print*

!--------------------------------------------------------------------------

! Allocation of output data array

 nlevp1=nlev+1
 allocate(fz(nlev))
 allocate(fzh(nlevp1))
 allocate(zeta(nlon,nlat,nlev))
 allocate(zetah(nlon,nlat,nlev))
 allocate(zeta_u(nlon,nlat,nlev))
 allocate(zeta_v(nlon,nlat,nlev))
 allocate(fmz(nlon,nlat,nlev))
 allocate(fmzh(nlon,nlat,nlevp1))
 allocate(p(nlon,nlat,nlev))
 allocate(u(nlon,nlat,nlev))
 allocate(v(nlon,nlat,nlev))
 allocate(w(nlon,nlat,nlevp1))
 allocate(t(nlon,nlat,nlev))
 allocate(q(nlon,nlat,nlev))
 allocate(qcw(nlon,nlat,nlev))
 allocate(qci(nlon,nlat,nlev))
 allocate(tvirt(nlon,nlat,nlev))
 allocate(fmask(nlon,nlat))
 allocate(phig(nlon,nlat))
 allocate(phig0(nlon,nlat))
 allocate(ps(nlon,nlat))
 allocate(tsurf(nlon,nlat))
 allocate(tsurf_copy(nlon,nlat))
 allocate(tsurf_frc(nlon,nlat))
 allocate(tgsurf(nlon,nlat))
 allocate(tgsurf_frc(nlon,nlat))
 allocate(qvsurf(nlon,nlat))
 allocate(qvsurf_frc(nlon,nlat))
 allocate(qgsurf(nlon,nlat))
 allocate(qgsurf_frc(nlon,nlat))
 allocate(tice(nlon,nlat,nlevg))
 allocate(cloudt(nlon,nlat))
 allocate(totpre(nlon,nlat))
 allocate(snfall(nlon,nlat))
 allocate(runoff(nlon,nlat))
 allocate(snow(nlon,nlat))
 allocate(snow_frc(nlon,nlat))
 allocate(cswfl(nlon,nlat))
 allocate(cswfl_down(nlon,nlat))
 allocate(clwfl(nlon,nlat))
 allocate(chflux(nlon,nlat))
 allocate(cqflux(nlon,nlat))
 allocate(t2min(nlon,nlat))
 allocate(t2max(nlon,nlat))
 allocate(ws10max(nlon,nlat))
 allocate(albedo(nlon,nlat))
 allocate(emismap1(nlon,nlat))
 allocate(emismap2(nlon,nlat))
 allocate(rgm(nlon,nlat))
 allocate(rgq(nlon,nlat))
 allocate(fice(nlon,nlat))
 allocate(iceth(nlon,nlat))
 allocate(fice_frc(nlon,nlat))
 allocate(iceth_frc(nlon,nlat))
 allocate(soilvegpar(nlon,nlat,nsvvar))
 allocate(m_rough(nlon,nlat))
 allocate(q_rough(nlon,nlat))
 allocate(d2(nlon,nlat))
 allocate(htop_inp_mod(nlon,nlat))
 allocate(htop_atm_inp_mod(nlon,nlat))
 allocate(alon_t(nlon,nlat))
 allocate(alat_t(nlon,nlat))
 allocate(alon_rot(nlon,nlat))
 allocate(tsurf_work(nlon,nlat))

 allocate(fice_soil_surf (nlon,nlat))
 allocate(fice_soil_surf_frc (nlon,nlat))
 allocate(alat_rot(nlon,nlat))

 allocate(tg                (nlon,nlat,nlevg))
 allocate(qg                (nlon,nlat,nlevg))
 allocate(tg_first_guess    (nlon,nlat,nlevg))
 allocate(qg_rel_first_guess(nlon,nlat,nlevg))
 allocate(fice_soil         (nlon,nlat,nlevg))
 allocate(tg_copy           (nlon,nlat,nlevg))
 allocate(tg_frc            (nlon,nlat,nlevg))
 allocate(qg_frc            (nlon,nlat,nlevg))
 allocate(fice_soil_frc     (nlon,nlat,nlevg))

 allocate(snow_lev       (nlon,nlat,nlevsnow))
 allocate(snow_t         (nlon,nlat,nlevsnow))
 allocate(snow_fice      (nlon,nlat,nlevsnow))
 allocate(snow_age       (nlon,nlat,nlevsnow))
 allocate(snow_melt_age  (nlon,nlat,nlevsnow))
 allocate(snow_dens      (nlon,nlat,nlevsnow))
 allocate(snow_lev_frc   (nlon,nlat,nlevsnow))
 allocate(snow_t_frc     (nlon,nlat,nlevsnow))
 allocate(snow_fice_frc  (nlon,nlat,nlevsnow))
 allocate(snow_age_frc   (nlon,nlat,nlevsnow))
 allocate(snow_melt_age_frc(nlon,nlat,nlevsnow))
 allocate(snow_dens_frc  (nlon,nlat,nlevsnow))
 allocate(snow_dirt      (nlon,nlat))

 allocate(water_table_depth  (nlon,nlat))
 allocate(tg_bottom          (nlon,nlat))
 allocate(qg_rel_bottom      (nlon,nlat))
 allocate(qg_rel_surf_approx (nlon,nlat))

 allocate(ind_lev_soil_h_bottom(nlon,nlat))
 allocate(ind_lev_soil_w_bottom(nlon,nlat))

 allocate(soil_map       (nlon,nlat,nst+1))
 allocate(veg_map        (nlon,nlat,nvt+1))

 allocate(soil_qmax      (nlon,nlat,nlevg))
 allocate(soil_qmin      (nlon,nlat,nlevg))
 allocate(soil_c         (nlon,nlat,nlevg))
 allocate(soil_rho       (nlon,nlat,nlevg))
 allocate(soil_psi       (nlon,nlat,nlevg))
 allocate(soil_k         (nlon,nlat,nlevg))
 allocate(soil_par_b     (nlon,nlat,nlevg))
 allocate(soil_par_c     (nlon,nlat,nlevg))
 allocate(soil_qrel_wilt (nlon,nlat,nlevg))
 allocate(soil_qrel_ref  (nlon,nlat,nlevg))

 allocate(soil_albedo_dry(nlon,nlat))
 allocate(soil_albedo_wet(nlon,nlat))
 allocate(soil_emiss1_dry(nlon,nlat))
 allocate(soil_emiss1_wet(nlon,nlat))
 allocate(soil_emiss2_dry(nlon,nlat))
 allocate(soil_emiss2_wet(nlon,nlat))

 allocate(veg_lai        (nlon,nlat))
 allocate(veg_frac       (nlon,nlat))
 allocate(veg_root_depth (nlon,nlat))
 allocate(veg_roughness  (nlon,nlat))
 allocate(veg_albedo     (nlon,nlat))
 allocate(veg_emiss1     (nlon,nlat))
 allocate(veg_emiss2     (nlon,nlat))

! Allocation of auxiliary array

 allocate(alon_u(nlon,nlat))
 allocate(alon_v(nlon,nlat))
 allocate(alat_u(nlon,nlat))
 allocate(alat_v(nlon,nlat))
 allocate(x_t(nlon,nlat))
 allocate(x_u(nlon,nlat))
 allocate(x_v(nlon,nlat))
 allocate(y_t(nlon,nlat))
 allocate(y_u(nlon,nlat))
 allocate(y_v(nlon,nlat))

 allocate(htopvar(nlon,nlat))
 allocate(hx_slope(nlon,nlat))
 allocate(hy_slope(nlon,nlat))

 allocate(ps_inp_mod(nlon,nlat))
 allocate(u_u_inp_mod_rot(nlon,nlat))
 allocate(u_v_inp_mod_rot(nlon,nlat))
 allocate(v_u_inp_mod_rot(nlon,nlat))
 allocate(v_v_inp_mod_rot(nlon,nlat))
 allocate(u_inp_mod(nlon,nlat,nlev_atm_inp_max))
 allocate(v_inp_mod(nlon,nlat,nlev_atm_inp_max))
 allocate(w_inp_mod(nlon,nlat,nlev_atm_inp_max+1))
 allocate(t_inp_mod(nlon,nlat,nlev_atm_inp_max))
 allocate(q_inp_mod(nlon,nlat,nlev_atm_inp_max))
 allocate(qcw_inp_mod(nlon,nlat,nlev_atm_inp_max))
 allocate(qci_inp_mod(nlon,nlat,nlev_atm_inp_max))
 allocate(p_inp_mod(nlon,nlat,nlev_atm_inp_max))
 allocate(tvirt_inp_mod(nlon,nlat,nlev_atm_inp_max))
 allocate(zeta_inp_mod(nlon,nlat,nlev_atm_inp_max))
 allocate(zetah_inp_mod(nlon,nlat,nlev_atm_inp_max+1))

!-----------------------------------------------------------------------------

!  Storage of model grid parameters

 nfdr(1) = 10
 nfdr(2)=nlon
 nfdr(3)=nlat
 nfdr(4)=nlev
 nfdr(15)=nlevg
 pdr(5)=alon0
 pdr(4)=alat0
 pdr(2)=dlon
 pdr(1)=dlat
 pdr(39)=x0
 pdr(38)=y0
 pdr(40)=h
 pdr(41)=2.2e-4 ! qccrit, used to plot clouds created by this procedure
 pdr(42)=b0
 pdr(43)=a0
 pdr(6:6+nlevg-1)=soil_lev(1:nlevg)

 ntot = nlon*nlat
 dx = a*dlon*pi/180. ! actual dx only in case of rotated coordinates - dx at the equator in regular coord.
 dy = a*dlat*pi/180.

! Definition of geographical coordinates of the staggered model grid
! (for definition of orography, land-sea mask, veget. etc.):
! alon_t,alat_t, alon_u,alat_u, alon_v,alat_v

1 continue

 call rot_grid(x0,y0,alon0,alat0+dlat*0.5,dlon,dlat,alon_t,alat_t,nlon,nlat)
 call rot_grid(x0,y0,alon0+dlon*0.5,alat0+dlat*0.5,dlon,dlat,alon_u,alat_u,nlon,nlat)
 call rot_grid(x0,y0,alon0,alat0,dlon,dlat,alon_v,alat_v,nlon,nlat)

! For check of domains conformity

 point_extr( 1) = minval(alon_t(:,:))
 point_extr( 2) = minval(alon_u(:,:))
 point_extr( 3) = minval(alon_v(:,:))
 point_extr( 4) = maxval(alon_t(:,:))
 point_extr( 5) = maxval(alon_u(:,:))
 point_extr( 6) = maxval(alon_v(:,:))
 point_extr( 7) = minval(point_extr( 1: 3))
 point_extr( 8) = maxval(point_extr( 4: 6))

 point_extr(11) = minval(alat_t(:,:))
 point_extr(12) = minval(alat_u(:,:))
 point_extr(13) = minval(alat_v(:,:))
 point_extr(14) = maxval(alat_t(:,:))
 point_extr(15) = maxval(alat_u(:,:))
 point_extr(16) = maxval(alat_v(:,:))
 point_extr(17) = minval(point_extr(11:13))
 point_extr(18) = maxval(point_extr(14:16))

 write(*, '(a,f8.4,a,f8.4)') ' Lon. of extreme points of (rotated) model grid in x dir.:',point_extr( 7),',',point_extr( 8)
 write(*, '(a,f8.4,a,f8.4)') ' Lat. of extreme points of (rotated) model grid in y dir.:',point_extr(17),',',point_extr(18)

 if((x0.ne.x0_inp.or.y0.ne.y0_inp).and.(point_extr(17) < -85..or.point_extr(18) > 85.)) then
  print*, "Care: the MOLOCH domain is close to a pole:"
  print*, "the rotation centre coordinates are reset to match those of the input model,"
  print*, "otherwise interpolated wind errors can be severe."
  print*, "In case, change alon0, alat0 to move the grid."
  print *,'New centre of coordinate rotation: x0 =',x0,' y0 =',y0
  x0=x0_inp
  y0=y0_inp
  pdr(39)=x0
  pdr(38)=y0
  goto 1
 endif

! Case of input data on a global model grid

 if (x0_inp==0..and.y0_inp==0..and.alon0_inp+float(nlon_inp0-1)*dlon_inp>357.) then
   x_t(:,:) = x_t(:,:)+360.
   x_u(:,:) = x_u(:,:)+360.
   x_v(:,:) = x_v(:,:)+360.
 endif

! Definition of model vertical coordinate Zita-Moloch

   do k=1,nlev
   zita   = (k-1)*dz+dz*0.5
   zitah  = (k-1)*dz
   fz (k) = 1.-zita /h
   fzh(k) = 1.-zitah/h
   enddo
   fzh(nlevp1) = 0.

   print*
   print*,'dx (at mid. lat.)   dy           dzita'
   print*, dx*cos((alat0+nlat/2*dlat+dlat*0.5)*pi/180.), dy, dz
   print*

   print*,'lev       zeta      zetah'
   do k = nlev, 1, -1
   zitahl = (k-1)*dz
   zital  = (k-1)*dz+dz/2.
   if (k.le.10.or.k.ge.nlev-10) write(6,6007) k, -h*bzita(zital)*log(1.-zital/h), -h*bzita(zitahl)*log(1.-zitahl/h)
   enddo
 6007 format(i4, 1x, 2f11.2)
   print*

 flag_cut_paste = 0
 nlon_inp = nlon_inp0

! Case when the model domain includes the whole longitude circle (typically for circumpolar domain location)
! One degree is a suitable interval to check if the model domain covers a full circumpolar area

   if (input_model /= 'BOLAM'.and.input_model /= 'MOLOCH'.and.flag_rot_inp == 0) then
! point_extr(7) - minimum values of model domain longitude
! point_extr(8) - maximum values of model domain longitude
     if ((abs(point_extr(7)) < 1. .and. abs(point_extr(8)-360.) < 1.).or.(abs(point_extr(7)+180.) < 1. .and. abs(point_extr(8)-180.) < 1.)) then
       nlon_inp = nlon_inp0 + 1
     endif
   endif


! For control:
! call anti_rot_grid(x0, y0, lon_point(1:npoint,1), lat_point(1:npoint,1), &
! lon_rot_point(1:npoint,1), lat_rot_point(1:npoint,1), npoint, 1)
! ipoint=nint((lon_rot_point(1,1)-alon0)/dlon)
! jpoint=nint((lat_rot_point(1,1)-alat0)/dlat)
! print *,'Point ',ipoint,jpoint
! open (31,file="point_out.dat",status="unknown",form="formatted",position="append")

!--------------------------------------------------------------------------
!      Basic loop on input data instants
!--------------------------------------------------------------------------

 inst_loop: do inst = inst_start, inst_stop

! Reading of input data grid parameters,
! this parametes can be different for various time instant
! because of input data may have different resolution 
! at various time instant

 file_name_work = input_file(inst-inst_start+1)
 if (input_model == 'BOLAM'.or.input_model == 'MOLOCH') then
   file_name_work      = input_file_atm(inst-inst_start +1)
   file_name_work_atm  = input_file_atm(inst-inst_start +1)
   file_name_work_soil = input_file_soil(inst-inst_start +1)
 endif

 do while (.true.)
   inquire(file=file_name_work,exist=lex)
   if (lex) exit
   print *,"Input file ",trim(file_name_work)," not available"
#ifdef oper
   inquire(file='premoloch_stop.txt',exist=lex2)
   if (lex2) then
     print *,"Found file premoloch_stop.txt, demand to program stop"
     stop
   endif
   print *,"Waiting (sleep) 30 s"
   call sleep (30)
#else
   stop
#endif
 enddo

! Definition of input data grid parameters, vertical levels (atmospheric and soil), and initial date
! Note: if input data is IFS or GFS, then input grid parameters may change for different instants,
! if input data is Bolam or Globo or Moloch, then input grid parameters are constant,
! and must be defined only once.

 if (input_format == 'grib2' .or. input_format == 'GRIB2') then
    call read_grib2_data(inst,file_name_work,1,.true.,flag_cut_paste,icentre_inp,isubcentre_inp,imodel_inp, &
              nlon_inp0,nlat_inp,nlev_inp,nlev_atm_inp_max,nlevg_inp,nlev_soil_inp_max, &
              x0_inp,y0_inp,alon0_inp,alat0_inp,dlon_inp,dlat_inp,idate0_inp,iperiod_inp_grib2, &
              lev_list_inp,soil_lev_inp,level_type, &
              npar3d,npar2d,npar3d_soil,field3d,field2d,field3d_soil,ak,bk,val_missing)
 elseif (input_model == 'BOLAM'.and.inst == inst_start) then
    call read_bolam_mhf_data(inst,file_name_work_atm,file_name_work_soil,input_file_std,.true., &
              nlon_inp0,nlat_inp,nlev_inp,nlev_atm_inp_max,nlevg_inp,nlev_soil_inp_max, &
              x0_inp,y0_inp,alon0_inp,alat0_inp,dlon_inp,dlat_inp,idate0_inp,iperiod_inp, &
              lev_list_inp,soil_lev_inp,level_type, &
              npar3d,npar2d,npar3d_soil,field3d,field2d,field3d_soil,ak,bk,val_missing)
 elseif (input_model == 'MOLOCH'.and.inst == inst_start) then
    call read_moloch_mhf_data(inst, file_name_work_atm, file_name_work_soil, input_file_std, .true., &
         nlev_atm_inp_max, nlev_soil_inp_max, &
         nlon_inp0, nlat_inp, nlev_inp, nlevg_inp, &
         x0_inp, y0_inp, alon0_inp, alat0_inp, dlon_inp, dlat_inp, &
         level_type, lev_list_inp, soil_lev_inp, idate0_inp, iperiod_inp, &
 frame, mask_frame, &
        htop_inp, fmask_inp, ps_inp, &
        zeta_inp, zetah_inp, p_inp, t_inp, u_inp, v_inp, w_inp, q_inp, qcw_inp, qci_inp, &
        tg_inp, qg_inp, tsurf_inp, qvsurf_inp, snow_inp, fice_inp, iceth_inp, qgmax_inp, qgmin_inp)
 endif

!--------------------------------------------------------------------------

  if (alon0_inp > 180.) alon0_inp = alon0_inp-360. ! Necessary, otherwise negative long. coordinates are mistaken

  nlon_inp = nlon_inp0
  if (input_model /= 'BOLAM'.and.input_model /= 'MOLOCH'.and.flag_rot_inp == 0) then
! point_extr(7) - minimum values of model domain longitude
! point_extr(8) - maximum values of model domain longitude
    if ((abs(point_extr(7)) < 1. .and. abs(point_extr(8)-360.) < 1.).or.(abs(point_extr(7)+180.) < 1. .and. abs(point_extr(8)-180.) < 1.)) then
      nlon_inp = nlon_inp0 + 1
    endif
  endif

! Allocation of input data array

 if (.not.allocated(field3d))      allocate(field3d(nlon_inp0,nlat_inp,nlev_atm_inp_max,npar3d))
 if (.not.allocated(field2d))      allocate(field2d(nlon_inp0,nlat_inp,npar2d))
 if (.not.allocated(field3d_soil)) allocate(field3d_soil(nlon_inp0,nlat_inp,nlev_soil_inp_max,npar3d_soil))

 if (.not.allocated(alon_t_inp)) allocate(alon_t_inp(nlon_inp,nlat_inp))
 if (.not.allocated(alon_u_inp)) allocate(alon_u_inp(nlon_inp,nlat_inp))
 if (.not.allocated(alon_v_inp)) allocate(alon_v_inp(nlon_inp,nlat_inp))
 if (.not.allocated(alat_t_inp)) allocate(alat_t_inp(nlon_inp,nlat_inp))
 if (.not.allocated(alat_u_inp)) allocate(alat_u_inp(nlon_inp,nlat_inp))
 if (.not.allocated(alat_v_inp)) allocate(alat_v_inp(nlon_inp,nlat_inp))
 if (.not.allocated(mask_frame)) allocate(mask_frame(nlon_inp,nlat_inp))

 if (.not.allocated(zeta_inp )) allocate(zeta_inp(nlon_inp,nlat_inp,nlev_atm_inp_max))
 if (.not.allocated(zetah_inp)) allocate(zetah_inp(nlon_inp,nlat_inp,nlev_atm_inp_max+1))
 if (.not.allocated(u_inp    )) allocate(u_inp(nlon_inp,nlat_inp,nlev_atm_inp_max))
 if (.not.allocated(v_inp    )) allocate(v_inp(nlon_inp,nlat_inp,nlev_atm_inp_max))
 if (.not.allocated(w_inp    )) allocate(w_inp(nlon_inp,nlat_inp,nlev_atm_inp_max+1))
 if (.not.allocated(t_inp    )) allocate(t_inp(nlon_inp,nlat_inp,nlev_atm_inp_max))
 if (.not.allocated(tvirt_inp)) allocate(tvirt_inp(nlon_inp,nlat_inp,nlev_atm_inp_max))
 if (.not.allocated(q_inp    )) allocate(q_inp(nlon_inp,nlat_inp,nlev_atm_inp_max))
 if (.not.allocated(qc_inp   )) allocate(qc_inp(nlon_inp,nlat_inp,nlev_atm_inp_max))
 if (.not.allocated(qcw_inp  )) allocate(qcw_inp(nlon_inp,nlat_inp,nlev_atm_inp_max))
 if (.not.allocated(qci_inp  )) allocate(qci_inp(nlon_inp,nlat_inp,nlev_atm_inp_max))
 if (.not.allocated(p_inp    )) allocate(p_inp(nlon_inp,nlat_inp,nlev_atm_inp_max))

 if (.not.allocated(htop_inp ))    allocate(htop_inp(nlon_inp,nlat_inp))
 if (.not.allocated(htop_atm_inp)) allocate(htop_atm_inp(nlon_inp,nlat_inp))
 if (.not.allocated(fmask_inp))    allocate(fmask_inp(nlon_inp,nlat_inp))
 if (.not.allocated(ps_inp   ))    allocate(ps_inp(nlon_inp,nlat_inp))
 if (.not.allocated(tsurf_inp))    allocate(tsurf_inp(nlon_inp,nlat_inp))
 if (.not.allocated(qvsurf_inp))    allocate(qvsurf_inp(nlon_inp,nlat_inp))
 if (.not.allocated(tg_inp   ))    allocate(tg_inp(nlon_inp,nlat_inp,nlev_soil_inp_max))
 if (.not.allocated(qg_inp   ))    allocate(qg_inp(nlon_inp,nlat_inp,nlev_soil_inp_max))
 if (.not.allocated(qgmax_inp   )) allocate(qgmax_inp(nlon_inp,nlat_inp,nlev_soil_inp_max))
 if (.not.allocated(qgmin_inp   )) allocate(qgmin_inp(nlon_inp,nlat_inp,nlev_soil_inp_max))
 if (.not.allocated(tice_inp ))    allocate(tice_inp(nlon_inp,nlat_inp,nlev_soil_inp_max))
 if (.not.allocated(snow_inp ))    allocate(snow_inp(nlon_inp,nlat_inp))
 if (.not.allocated(fice_inp ))    allocate(fice_inp(nlon_inp,nlat_inp))
 if (.not.allocated(iceth_inp))    allocate(iceth_inp(nlon_inp,nlat_inp))

 if (.not.allocated(d2_inp   )) allocate(d2_inp(nlon_inp,nlat_inp))

 if (.not.allocated(alon_rot_inp)) allocate(alon_rot_inp(nlon_inp,nlat_inp))
 if (.not.allocated(alat_rot_inp)) allocate(alat_rot_inp(nlon_inp,nlat_inp))
 if (.not.allocated(x_t_inp)) allocate(x_t_inp(nlon_inp))
 if (.not.allocated(x_u_inp)) allocate(x_u_inp(nlon_inp))
 if (.not.allocated(y_t_inp)) allocate(y_t_inp(nlat_inp))
 if (.not.allocated(y_v_inp)) allocate(y_v_inp(nlat_inp))

 if (.not.allocated(psl_inp  )) allocate(psl_inp(nlon_inp,nlat_inp))
 if (.not.allocated(u_inp_rot)) allocate(u_inp_rot(nlon_inp,nlat_inp))
 if (.not.allocated(v_inp_rot)) allocate(v_inp_rot(nlon_inp,nlat_inp))
 if (.not.allocated(u_inp_work)) allocate(u_inp_work(nlon_inp,nlat_inp))
 if (.not.allocated(v_inp_work)) allocate(v_inp_work(nlon_inp,nlat_inp))
 if (.not.allocated(tsurf_work_inp)) allocate(tsurf_work_inp(nlon_inp,nlat_inp))

!--------------------------------------------------------------------------

 write (*,*)
 write (*,*) '     Parameters of input data horizontal grid:'
 write(*,'(a,i4,a,i4,a,f9.4,a,f9.4)') ' nx =',nlon_inp0,', ny =',nlat_inp,',  x west extreem =',alon0_inp,',  y south extreem =',alat0_inp
 write(*,'(a,f6.3,a,f6.3)') ' dx =',dlon_inp,', dy =',dlat_inp

  flag_cut_paste = 0

! Case of input data on a global grid (typically for historical GFS data or ERA5 data...)
! In case of global area in input data, grid points having positive longitudes but west of
! Greenwich are "cut" and "pasted" (giving them negative longitudes) in order to reconstruct
! a grid crossing the Greenwich meridian

 if (nlon_inp0 == nlon_inp) then

! point_extr(7) - minimum values of model domain longitude
! point_extr(8) - maximum values of model domain longitude

   if (flag_rot_inp==0.and.alon0_inp==0..and.alon0_inp+dlon_inp*float(nlon_inp-1)>359.) then
    alon0_inp_ini = alon0_inp
    if (point_extr(7)*point_extr(8) >= 0.) then
      if (alon0_inp == 0.) ifl_xf = 0
      if (alon0_inp == -180.) ifl_xf = 1
    else
      if ( alon0_inp ==0.) ifl_xf = 1
      if ( alon0_inp ==-180.) ifl_xf = 0
    endif
    if (ifl_xf == 1) then
      if (alon0_inp == 0.) then
        alon0_inp = -180.
      elseif (alon0_inp == -180.) then
        alon0_inp = 0.
      endif

      flag_cut_paste = 1

      print *
      print*,'Shift of the input grid longitude:',' alon0_inp ',alon0_inp,' initial values ',alon0_inp_ini
    endif
   endif

   if (flag_rot_inp==0) then
     if (alon0_inp > 0..and.minval(alon_t(:,:)) <= 0.) then
       if (alon0_inp-360.+float(nlon_inp-1)*dlon_inp >= maxval(alon_t(:,:))) alon0_inp = alon0_inp-360.
     elseif (alon0_inp < 0..and.minval(alon_t(:,:)) >= 0.) then
       if (alon0_inp+360. <= minval(alon_t(:,:))) alon0_inp = alon0_inp+360.
     endif
   endif

 else

   flag_cut_paste = 0

 endif

!--------------------------------------------------------------------------

! Definition of geographical coordinates of the staggered input grid:
! alon_t_inp,alat_t_inp, alon_u_inp,alat_u_inp, alon_v_inp,alat_v_inp

 if (input_model == "BOLAM" .or. input_model == "MOLOCH") then
   call rot_grid(x0_inp,y0_inp,alon0_inp,alat0_inp+dlat_inp*0.5, &
                 dlon_inp,dlat_inp,alon_t_inp,alat_t_inp,nlon_inp,nlat_inp)
   call rot_grid(x0_inp,y0_inp,alon0_inp+dlon_inp*0.5,alat0_inp+dlat_inp*0.5, &
                 dlon_inp,dlat_inp,alon_u_inp,alat_u_inp,nlon_inp,nlat_inp)
   call rot_grid(x0_inp,y0_inp,alon0_inp,alat0_inp, &
                 dlon_inp,dlat_inp,alon_v_inp,alat_v_inp,nlon_inp,nlat_inp)
 elseif (input_model == "COSMO") then
   call rot_grid(x0_inp,y0_inp,alon0_inp,alat0_inp, &
                 dlon_inp,dlat_inp,alon_t_inp,alat_t_inp,nlon_inp,nlat_inp)
   call rot_grid(x0_inp,y0_inp,alon0_inp+dlon_inp*0.5,alat0_inp, &
                 dlon_inp,dlat_inp,alon_u_inp,alat_u_inp,nlon_inp,nlat_inp)
   call rot_grid(x0_inp,y0_inp,alon0_inp,alat0_inp+dlat_inp*0.5, &
                 dlon_inp,dlat_inp,alon_v_inp,alat_v_inp,nlon_inp,nlat_inp)
 else
   call rot_grid(x0_inp,y0_inp,alon0_inp,alat0_inp, &
                 dlon_inp,dlat_inp,alon_t_inp,alat_t_inp,nlon_inp,nlat_inp)
   alon_u_inp(:,:) = alon_t_inp
   alat_u_inp(:,:) = alat_t_inp
   alon_v_inp(:,:) = alon_t_inp
   alat_v_inp(:,:) = alat_t_inp
 endif

! Check of domains conformity

 point_extr_inp( 1) = minval(alon_t_inp(:,:))
 point_extr_inp( 2) = minval(alon_u_inp(:,:))
 point_extr_inp( 3) = minval(alon_v_inp(:,:))
 point_extr_inp( 4) = maxval(alon_t_inp(:,:))
 point_extr_inp( 5) = maxval(alon_u_inp(:,:))
 point_extr_inp( 6) = maxval(alon_v_inp(:,:))
 point_extr_inp( 7) = minval(point_extr_inp( 1: 3))
 point_extr_inp( 8) = maxval(point_extr_inp( 4: 6))

 point_extr_inp(11) = minval(alat_t_inp(:,:))
 point_extr_inp(12) = minval(alat_u_inp(:,:))
 point_extr_inp(13) = minval(alat_v_inp(:,:))
 point_extr_inp(14) = maxval(alat_t_inp(:,:))
 point_extr_inp(15) = maxval(alat_u_inp(:,:))
 point_extr_inp(16) = maxval(alat_v_inp(:,:))
 point_extr_inp(17) = minval(point_extr_inp(11:13))
 point_extr_inp(18) = maxval(point_extr_inp(14:16))

! The next check may not be correct in all cases, but routine interp_spline_2d will stop
! in case the model grid is not contained in the input grid

 if ((point_extr(7) < point_extr_inp(7).or.point_extr(8) > point_extr_inp(8))            &
    .and.(abs(point_extr_inp(7))+abs(point_extr_inp(8))) < 359.                          &
    .or.point_extr(17) < point_extr_inp(17).or.point_extr(18) > point_extr_inp(18)) then
    print *,'Extreme points of input grid in X direction: ',point_extr_inp( 7),point_extr_inp( 8)
    print *,'Extreme points of input grid in Y direction: ',point_extr_inp(17),point_extr_inp(18)
    print *,'Model domain not contained in the input grid'
    if(abs(point_extr(17))>89.5.or.abs(point_extr(18))>89.5) then
      print*, "Case of input domain including polar area: the above problem may not be fatal"
    else
      stop
    endif
 endif

! Definition of model grid points in terms of input grid coordinates

 call anti_rot_grid(x0_inp,y0_inp,alon_t,alat_t,x_t,y_t,nlon,nlat)
 call anti_rot_grid(x0_inp,y0_inp,alon_u,alat_u,x_u,y_u,nlon,nlat)
 call anti_rot_grid(x0_inp,y0_inp,alon_v,alat_v,x_v,y_v,nlon,nlat)

 if (abs(x0_inp) <0.01.and.abs(y0_inp) < 0.01.and.minval(x_t(1,:)) < 180..and.alon0_inp > 180.) then
    x_t(:,:) = x_t(:,:) + 360.
    x_u(:,:) = x_u(:,:) + 360.
    x_v(:,:) = x_v(:,:) + 360.
 endif

! Definition of input grid points in terms of input grid coordinates

 if (input_model == "BOLAM" .or. input_model == "MOLOCH") then
   do i=1,nlon_inp
     x_t_inp(i) = alon0_inp + dlon_inp*float(i-1)
     x_u_inp(i) = x_t_inp(i) + dlon_inp*0.5
   enddo
   do j=1,nlat_inp
     y_v_inp(j) = alat0_inp + dlat_inp*float(j-1)
     y_t_inp(j) = y_v_inp(j) + dlat_inp*0.5
   enddo
 elseif (input_model == "COSMO") then
   do i=1,nlon_inp
     x_t_inp(i) = alon0_inp + dlon_inp*float(i-1)
     x_u_inp(i) = x_t_inp(i) + dlon_inp*0.5
   enddo
   do j=1,nlat_inp
     y_t_inp(j) = alat0_inp + dlat_inp*float(j-1)
     y_v_inp(j) = y_t_inp(j) + dlat_inp*0.5
   enddo
 else ! IFS, GFS
   do i=1,nlon_inp
     x_t_inp(i) = alon0_inp + dlon_inp*float(i-1)
   enddo
   x_u_inp(1:nlon_inp) = x_t_inp(1:nlon_inp)
   do j=1,nlat_inp
     y_t_inp(j) = alat0_inp + dlat_inp*float(j-1)
   enddo
   y_v_inp(1:nlat_inp) = y_t_inp(1:nlat_inp)
 endif

!---------------------------------------------------------------------------
!    Input data reading
!    (vertical levels in input data must be ordered upward)
!---------------------------------------------------------------------------

#ifdef oper
    if (inst_stop < 1) then
    inst_start = 1
    inst_stop = 1
    endif
#endif

    if (inst == inst_start) then
      surf_elaborate = .true.
    else
      surf_elaborate = .false.
    endif

    print *
    print*, 'surf_elaborate ',surf_elaborate
    print *

! Call of the procedure for reading and decoding input data files

   file_name_work = input_file(inst-inst_start+1)
   if (input_model == 'BOLAM'.or.input_model == 'MOLOCH') then
     file_name_work_atm  = input_file_atm(inst-inst_start +1)
     file_name_work_soil = input_file_soil(inst-inst_start +1)
   endif

   if (input_format == 'grib2' .or. input_format == 'GRIB2') then
      call read_grib2_data(inst,file_name_work,1,.false.,flag_cut_paste,icentre_inp,isubcentre_inp,imodel_inp, &
                nlon_inp0,nlat_inp,nlev_inp,nlev_atm_inp_max,nlevg_inp,nlev_soil_inp_max, &
                x0_inp,y0_inp,alon0_inp,alat0_inp,dlon_inp,dlat_inp,idate0_inp,iperiod_inp_grib2, &
                lev_list_inp,soil_lev_inp,level_type, &
                npar3d,npar2d,npar3d_soil,field3d,field2d,field3d_soil,ak,bk,val_missing)
   else ! Bolam or Moloch
      if (input_file_std == 1 .and. inst == inst_start) then ! skip of initial instants in the united input file
       do inst2 = 1, inst_start-1
          print*, "Reading and skipping instant no.", inst2
          if (input_model == 'BOLAM') &
            call read_bolam_mhf_data(inst2,file_name_work_atm,file_name_work_soil,input_file_std,.false., &
                   nlon_inp0,nlat_inp,nlev_inp,nlev_atm_inp_max,nlevg_inp,nlev_soil_inp_max, &
                   x0_inp,y0_inp,alon0_inp,alat0_inp,dlon_inp,dlat_inp,idate0_inp,iperiod_inp, &
                   lev_list_inp,soil_lev_inp,level_type, &
                   npar3d,npar2d,npar3d_soil,field3d,field2d,field3d_soil,ak,bk,val_missing)
          if (input_model == 'MOLOCH') &
            call read_moloch_mhf_data(inst2, file_name_work_atm, file_name_work_soil, input_file_std, .false., &
                   nlev_atm_inp_max, nlev_soil_inp_max, &
                   nlon_inp0, nlat_inp, nlev_inp, nlevg_inp, &
                   x0_inp, y0_inp, alon0_inp, alat0_inp, dlon_inp, dlat_inp, &
                   level_type, lev_list_inp, soil_lev_inp, idate0_inp, iperiod_inp, &
                   frame, mask_frame, &
                   htop_inp, fmask_inp, ps_inp, &
                   zeta_inp, zetah_inp, p_inp, t_inp, u_inp, v_inp, w_inp, q_inp, qcw_inp, qci_inp, &
                   tg_inp, qg_inp, tsurf_inp, qvsurf_inp, snow_inp, fice_inp, iceth_inp, qgmax_inp, qgmin_inp)
        enddo
      endif
      print*, "Start reading and processing instant no.", inst
      if (input_model == 'BOLAM') &
        call read_bolam_mhf_data(inst,file_name_work_atm,file_name_work_soil,input_file_std,.false., &
               nlon_inp0,nlat_inp,nlev_inp,nlev_atm_inp_max,nlevg_inp,nlev_soil_inp_max, &
               x0_inp,y0_inp,alon0_inp,alat0_inp,dlon_inp,dlat_inp,idate0_inp,iperiod_inp, &
               lev_list_inp,soil_lev_inp,level_type,  &
               npar3d,npar2d,npar3d_soil,field3d,field2d,field3d_soil,ak,bk,val_missing)
      if (input_model == 'MOLOCH') &
        call read_moloch_mhf_data(inst, file_name_work_atm, file_name_work_soil, input_file_std, .false., &
               nlev_atm_inp_max, nlev_soil_inp_max, &
               nlon_inp0, nlat_inp, nlev_inp, nlevg_inp, &
               x0_inp, y0_inp, alon0_inp, alat0_inp, dlon_inp, dlat_inp, &
               level_type, lev_list_inp, soil_lev_inp, idate0_inp, iperiod_inp, &
               frame, mask_frame, &
               htop_inp, fmask_inp, ps_inp, &
               zeta_inp, zetah_inp, p_inp, t_inp, u_inp, v_inp, w_inp, q_inp, qcw_inp, qci_inp, &
               tg_inp, qg_inp, tsurf_inp, qvsurf_inp, snow_inp, fice_inp, iceth_inp, qgmax_inp, qgmin_inp)
   endif

!--------------------------------------------------------------------------

   write(*, '(a12,i3,a5)') " Instant no.", inst, "read"

! Preliminary elaboration of read and decoded input data

  print *
  if (input_model == 'IFS') then
    call conv_ifs_data(inst)
  elseif (input_model == 'GFS') then
    call conv_gfs_data(inst)
  elseif (input_model == 'BOLAM') then
    call conv_bolam_data(inst)
  elseif (input_model == 'COSMO') then
    call conv_cosmo_data(inst)
  elseif (input_model == 'MOLOCH') then
    call conv_moloch_data
  endif
  print *

  if (inst == inst_start) then
    write(*, '(a,2i5)') ' The first and last instants to be processed are:', inst_start, inst_stop

! Definition of the initial instant

    idate0(1:5) = idate0_inp(1:5)

    ndayr = idate0(3)
    do iimon = 1, idate0(2)-1
    ndayr = ndayr+ imon(iimon)
    enddo
    day = float(ndayr-1)+float(idate0(4))/24.+float(idate0(5))/(24.*60.)

! Definition of lapse rate depending on season (in both hemispheres),
! varying from 4.5E-3 at the end of Dec. to 7.3E-3 at the end of June in the N.H.
! (opposite in the S.H. - no seasonal change if the domain centre is in the tropics).

    if(y0 > 30.) then
    coeday = 0.5*(1.-cos(day*2.*pi/365.))   ! N.H.
    elseif(y0 < -30.) then
    coeday = 0.5*(1.+cos(day*2.*pi/365.))   ! S.H.
    else
    coeday = 0.5                            ! tropics
    endif
    gammac = 4.5e-3 + 2.8e-3*coeday

   write(*,*)
   write(*, '(a,f8.4)') ' Climatological lapse rate =', gammac

! Definition of all physiographic parameters on the model grid:
! topography height, variance of topography height,
! land-sea fraction, soil and veg_maption parameters;
! soil temperature and water content on the bottom level and also at
! all soil levels in following some climatic hypothesis and surface data

! Surface temperature interpolated into model grid is necessary
! to define fisrt guess of soil temperature at all soil levels.
! If there are soil temperature data in input, then this field may be defined as
! fiction data. 

   if (minval(tsurf_inp) > 100.) then
     tsurf_work_inp(1:nlon_inp,1:nlat_inp) = tsurf_inp(1:nlon_inp,1:nlat_inp)
   else
     tsurf_work_inp(1:nlon_inp,1:nlat_inp) = tg_inp(1:nlon_inp,1:nlat_inp,1)
   endif
   call landtemp(tsurf_work_inp,fmask_inp,nlon_inp,nlat_inp,4,0,0.9)
   call interp_spline_2d(tsurf_work_inp,nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t,y_t,ntot,tsurf_work,1.)

   print *

! -----------------------------------------------------------------------

! Definition of all constant (in time) model physiographical parameters

! If model_param_constant.bin exists, then reads constant model
! physiographical parameters from this file,
! else parameters are defined using def_soil.F90 procedures

! If model_param_constant.bin exists (flag_constant_fields=0), then reads constant model
! physiographical parameters from this file,
! else (flag_constant_fields/=0) parameters are defined using
! subroutine physiographic_param (in def_soil.F90)

! Physiographical parameters variable in time (LAI, vegetation frac,
! soil temperature and soil water content vertical approximated profies)
! are difined by subroutine physiographic_param (in def_soil.F90)

  call read_param_const(flag_constant_fields)

  print *

  call physiographic_param (nlon, nlat, nst, nvt, nlevg, &
 alon0, alat0+dlat*0.5, dlon, dlat, x0, y0, alon_t, alat_t, tsurf_work, soil_lev(1:nlevg), ndayr, flag_constant_fields, &
 phig, htopvar, fmask, &
 water_table_depth, tg_bottom, qg_rel_bottom, qg_rel_surf_approx, & 
 ind_lev_soil_h_bottom, ind_lev_soil_w_bottom, &
 tg_first_guess, qg_rel_first_guess, &
 soil_map, veg_map, &
 soil_qmax, soil_qmin, soil_c, soil_rho, soil_psi, soil_k, &
 soil_par_b, soil_par_c, soil_qrel_wilt, soil_qrel_ref, &
 soil_albedo_dry, soil_albedo_wet, &
 soil_emiss1_dry, soil_emiss1_wet, soil_emiss2_dry, soil_emiss2_wet, &
 veg_lai, veg_frac, veg_root_depth, veg_roughness, veg_albedo, veg_emiss1, veg_emiss2, veg_lai_max, &
 snow_dirt)

    phig(:,:) = phig(:,:)*g0
    phig0(:,:) = phig(:,:)

! Definition orography slope

    do j = 1, nlat
    jm1 = max(j-1,1)
    zlatt = cos((alat0+(j-1)*dlat+dlat*0.5)*pi/180.)
    do i = 1, nlon
    ip1 = min(i+1,nlon)
    hx_slope(i,j) = (phig(ip1,j)-phig(i,j))/(zlatt*g0*dx)
    hy_slope(i,j) = (phig(i,j)-phig(i,jm1))/(g0*dy)
    enddo
    enddo

! Old soil --->
    soilvegpar(:,:,1) = soil_psi(:,:,lev_soil_ref)
    soilvegpar(:,:,2) = soil_par_b(:,:,lev_soil_ref)
    soilvegpar(:,:,3) = soil_rho(:,:,lev_soil_ref)
    soilvegpar(:,:,4) = soil_c(:,:,lev_soil_ref)
    soilvegpar(:,:,5) = soil_k(:,:,lev_soil_ref)
    soilvegpar(:,:,6) = soil_qmax(:,:,lev_soil_ref)
    soilvegpar(:,:,7) = soil_qmin(:,:,lev_soil_ref)
    soilvegpar(:,:,8) = soil_qrel_wilt(:,:,lev_soil_ref)*(soil_qmax(:,:,lev_soil_ref)-soil_qmin(:,:,lev_soil_ref))+ &
                        soil_qmin(:,:,lev_soil_ref)
    soilvegpar(:,:,9) = soil_qrel_ref(:,:,lev_soil_ref)*(soil_qmax(:,:,lev_soil_ref)-soil_qmin(:,:,lev_soil_ref))+ &
                        soil_qmin(:,:,lev_soil_ref)
    soilvegpar(:,:,10) = soil_qmax(:,:,lev_soil_ref)*0.01
    soilvegpar(:,:,11) = soil_qmax(:,:,lev_soil_ref)*0.05
    soilvegpar(:,:,12) = soil_qmax(:,:,lev_soil_ref)*0.10
    soilvegpar(:,:,13) = soil_qmax(:,:,lev_soil_ref)*0.15
    soilvegpar(:,:,14) = soil_qmax(:,:,lev_soil_ref)*0.20
    soilvegpar(:,:,15) = soil_qmax(:,:,lev_soil_ref)*0.30
    soilvegpar(:,:,16) = soil_qmax(:,:,lev_soil_ref)*0.40
    soilvegpar(:,:,17) = soil_qmax(:,:,lev_soil_ref)*0.50
    soilvegpar(:,:,18) = soil_qmax(:,:,lev_soil_ref)*0.80
    soilvegpar(:,:,19) = soil_emiss1_dry(:,:)
    soilvegpar(:,:,20) = soil_emiss2_dry(:,:)
    soilvegpar(:,:,21) = soil_emiss1_wet(:,:)
    soilvegpar(:,:,22) = soil_emiss2_wet(:,:)
    soilvegpar(:,:,23) = soil_albedo_dry(:,:)
    soilvegpar(:,:,24) = soil_albedo_wet(:,:)
    soilvegpar(:,:,31) = veg_lai(:,:)
    soilvegpar(:,:,32) = veg_frac(:,:)
    soilvegpar(:,:,33) = veg_root_depth(:,:)
    soilvegpar(:,:,34) = veg_roughness(:,:)*1.8
    soilvegpar(:,:,35) = veg_emiss1(:,:)
    soilvegpar(:,:,36) = veg_emiss2(:,:)
    soilvegpar(:,:,37) = veg_albedo(:,:)
    soilvegpar(:,:,38) = soilvegpar(:,:,34)*0.55
! <---

   m_rough(:,:)=veg_roughness(:,:)*1.8      ! momentum roughness
   q_rough(:,:)=veg_roughness(:,:)          ! heat-moisture roughness

! Altitude (m) of Zita-Moloch levels and its derivative

   do k = 1, nlev
    zita  = (k-1)*dz+dz*0.5
    zitah = (k-1)*dz
    do j = 1, nlat
    do i = 1, nlon
    zg = phig(i,j)/g0
    zeta (i,j,k) = zg*gzita(zita ) -h*bzita(zita )*log(fz (k))
    zetah(i,j,k) = zg*gzita(zitah) -h*bzita(zitah)*log(fzh(k))
    fmz  (i,j,k) = fz (k)/(bzita(zita )+fz (k)*zg*gzitap(zita ) &
                 - h*fz (k)*log(fz (k))*bzitap(zita ))
    fmzh (i,j,k) = fzh(k)/(bzita(zitah)+fzh(k)*zg*gzitap(zitah) &
                 - h*fzh(k)*log(fzh(k))*bzitap(zitah))
    if (i<=nlon-1) then
    zg = 0.5*(phig(i,j)+phig(i+1,j))/g0
    else
    zg = phig(nlon-1,j)/g0
    endif
    zeta_u(i,j,k) = zg*gzita(zita) -h*bzita(zita)*log(fz(k))
    if (j>=2) then
    zg = 0.5*(phig(i,j)+phig(i,j-1))/g0
    else
    zg = phig(i,2)/g0
    endif
    zeta_v(i,j,k) = zg*gzita(zita) -h*bzita(zita)*log(fz(k))
    enddo
    enddo
   enddo
   fmzh(:,:,nlevp1) = 0.

   zzz = abs(x0-x0_inp)+abs(y0-y0_inp)
   if (zzz>=0.02.and.flag_rot_inp==1) then
    print*, "The rotation centres of input data and MOLOCH do not coincide:"
    print*, "Wind anti-rotation is computed"
   endif

  endif ! inst == inst_start

!--------------------------------------------------------------------------
!  Storage of date and time
!--------------------------------------------------------------------------

    nfdr(5:9)   = idate0_inp(1:5)
    nfdr(10:12) = iperiod_inp(1:3)

!--------------------------------------------------------------------------
!  Atmospheric time-dependent fields
!--------------------------------------------------------------------------

!--------------------------------------------------------------------------
!                 Horizontal interpolation
!--------------------------------------------------------------------------

! Interpolation of input topography hight because of eventual changing of resoiltion of input data

! No use horizontal inperpolation of topogragy with a procedure different 
! in respect the procedure used for zeta (level altitude) interpolation !!!
!    al=0.5
!    if (frame) al=1.
!    call interp_spline_2d (htop_inp,nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t, &
!                           y_t,ntot,htop_inp_mod,al)
    call h_inter (htop_inp, nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, htop_inp_mod)
    if (input_model == 'IFS'.and.level_type == 2) then
      call h_inter (htop_atm_inp, nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, htop_atm_inp_mod)
    endif

! Modif. of MOLOCH orography to fit the input model orography near the boundaries

!    do jlat = 1, nlat
!    do jlon = 1, nlon
!    iframe = min (jlon, jlat, nlon+1-jlon, nlat+1-jlat)
!    zframe = max (0., float(11-iframe)/10.)
!    phig(jlon,jlat) = zframe*htop_inp_mod(jlon,jlat)*g0 + (1.-zframe)*phig0(jlon,jlat)
!    enddo
!    enddo

    psl_inp = alog(ps_inp)

    al=0.5
    if (frame) al=1.
!    call interp_spline_2d (psl_inp, nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, ntot, ps_inp_mod, al)
    call h_inter (psl_inp, nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, ps_inp_mod)

!  Wind components

    do k = 1, nlev_inp

    if (zzz>0.02.and.flag_rot_inp==1) then

      if (input_model == 'MOLOCH'.or.input_model == 'BOLAM') then
      do j = 1, nlat_inp
      do i = 1, nlon_inp
        u_inp_work(i,j) = u_inp(i,j,k)
        v_inp_work(i,j) = v_inp(i,j,k)
        alon_rot_inp(i,j) = alon0_inp + float(i-1)*dlon_inp
        alat_rot_inp(i,j) = alat0_inp + float(j-1)*dlat_inp
      enddo
      enddo
    elseif (input_model == 'COSMO') then
      do j = 1, nlat_inp
        jp1 = min(1, j+1)
      do i = 1, nlon_inp
        ip1 = min(nlon, i+1)
        u_inp_work(i,j) = 0.5*(u_inp(i,j,k) + u_inp(ip1,j,k))
        v_inp_work(i,j) = 0.5*(v_inp(i,j,k) + v_inp(i,jp1,k))
        alon_rot_inp(i,j) = x_t_inp(i)
        alat_rot_inp(i,j) = y_t_inp(j)
      enddo
      enddo
    else ! IFS
      do j = 1, nlat_inp
      do i = 1, nlon_inp
        u_inp_work(i,j) = u_inp(i,j,k)
        v_inp_work(i,j) = v_inp(i,j,k)
        alon_rot_inp(i,j) = x_t_inp(i)
        alat_rot_inp(i,j) = y_t_inp(j)
      enddo
      enddo
    endif

    call anti_rot_wind (x0_inp,y0_inp,alon_u_inp,alat_u_inp,alon_rot_inp,alat_rot_inp, &
                        u_inp_work(:,:),v_inp_work(:,:),u_inp_rot,v_inp_rot,nlon_inp,nlat_inp)

    else

      u_inp_rot(:,:) = u_inp(:,:,k)
      v_inp_rot(:,:) = v_inp(:,:,k)

    endif

    call h_inter (u_inp_rot, nlon_inp, nlat_inp, x_u_inp, y_t_inp, x_u, y_u, nlon, nlat, u_u_inp_mod_rot)
    call h_inter (u_inp_rot, nlon_inp, nlat_inp, x_u_inp, y_t_inp, x_v, y_v, nlon, nlat, u_v_inp_mod_rot)
    call h_inter (v_inp_rot, nlon_inp, nlat_inp, x_t_inp, y_v_inp, x_u, y_u, nlon, nlat, v_u_inp_mod_rot)
    call h_inter (v_inp_rot, nlon_inp, nlat_inp, x_t_inp, y_v_inp, x_v, y_v, nlon, nlat, v_v_inp_mod_rot)

    if (zzz>0.02) then
    call rot_wind (u_u_inp_mod_rot,v_u_inp_mod_rot,u_v_inp_mod_rot,v_v_inp_mod_rot, &
                   alon_u,alon_v,alat_u,alat_v, &
                   u_inp_mod(:,:,k),v_inp_mod(:,:,k),nlon,nlat,x0,y0,alon0,alat0,dlon,dlat)
    else
    u_inp_mod(:,:,k) = u_u_inp_mod_rot(:,:)
    v_inp_mod(:,:,k) = v_v_inp_mod_rot(:,:)
    endif

    enddo ! k = 1, nlev_inp

    do k = 1, nlev_inp
    call h_inter (zeta_inp  (:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, zeta_inp_mod  (:,:,k))
    call h_inter (t_inp  (:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, t_inp_mod  (:,:,k))
    call h_inter (q_inp  (:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, q_inp_mod  (:,:,k))
    call h_inter (qcw_inp(:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, qcw_inp_mod(:,:,k))
    call h_inter (qci_inp(:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, qci_inp_mod(:,:,k))
    enddo
    if (input_model == 'BOLAM') then
      do k = 1, nlev_inp
        call h_inter (w_inp  (:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, w_inp_mod  (:,:,k))
      enddo
    endif
    if (input_model == 'MOLOCH') then
      do k = 1, nlev_inp
        call h_inter (w_inp  (:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, w_inp_mod  (:,:,k))
        call h_inter (zetah_inp  (:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, zetah_inp_mod  (:,:,k))
      enddo
    endif
    if (input_model == 'COSMO') then
      do k = 1, nlev_inp+1
        call h_inter (w_inp  (:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, w_inp_mod  (:,:,k))
        call h_inter (zetah_inp  (:,:,k), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, zetah_inp_mod  (:,:,k))
      enddo
    endif
    if (input_model == 'MOLOCH'.or.input_model == 'COSMO') then
      do j = 1,nlat
        do i = 1,nlon
          do k = 2,nlev_inp
            if (zetah_inp_mod(i,j,k) <= zetah_inp_mod(i,j,k-1)) zetah_inp_mod(i,j,k)=zetah_inp_mod(i,j,k-1)+5.
          enddo
        enddo
      enddo
    endif

    q_inp_mod   = max (q_inp_mod  , 1.e-7)
    qcw_inp_mod = max (qcw_inp_mod, 0.)
    qci_inp_mod = max (qci_inp_mod, 0.)

! Definition of some basic variables: virtual temperature, absolute altitude
! for model grid points on input data vertical levels

    do k = 1, nlev_inp
    do j = 1, nlat
    do i = 1, nlon
    tvirt_inp_mod(i,j,k) = t_inp_mod(i,j,k)*(1.+ep*q_inp_mod(i,j,k)-qcw_inp_mod(i,j,k)-qci_inp_mod(i,j,k))
    enddo
    enddo
    enddo

! Pressure on input atmospheric levels 

! Use of the hydrostatic eq. in the case of hydrostatic model data in input.
! Use of inperpolation of input pressure data n the case of non-hydrostatic model data in input. 

    if (input_model /= 'MOLOCH'.and.input_model /= 'COSMO') then ! BOLAM, GLOBO, IFS, GFS

      if (input_model == 'IFS'.and.level_type == 2) then
        d2(:,:) = htop_atm_inp_mod(:,:)
      else
        d2(:,:) = htop_inp_mod(:,:)
      endif
      do j = 1, nlat
      do i = 1, nlon
        p_inp_mod(i,j,1) = ps_inp_mod(i,j)- &
 g0*(zeta_inp_mod(i,j,1)-d2(i,j))/(rd*tvirt_inp_mod(i,j,1))
        do k = 2, nlev_inp
          p_inp_mod(i,j,k) = p_inp_mod(i,j,k-1)- &
 (g0*(zeta_inp_mod(i,j,k)-zeta_inp_mod(i,j,k-1)))/(0.5*rd*(tvirt_inp_mod(i,j,k)+tvirt_inp_mod(i,j,k-1)))
        enddo
      enddo
      enddo

    else ! MOLOCH, COSMO

      do k = 1, nlev_inp
        call h_inter (log(p_inp(:,:,k)), nlon_inp, nlat_inp, x_t_inp, y_t_inp, x_t, y_t, nlon, nlat, p_inp_mod(:,:,k))
      enddo

    endif

    ps_inp_mod(:,:) = exp(ps_inp_mod(:,:))
    p_inp_mod(:,:,1:nlev_inp) = exp(p_inp_mod(:,:,1:nlev_inp))

! Computation of (minus) average lapse rate of the input model (horiz. interpolated) between lowest levels

    gamma_inp=0.
    nnn=0
    do j = 1, nlat_inp
    do i = 1, nlon_inp
    if (mask_frame(i,j) /= 0) then
      do k = 1, nlev_inp 
        if ( (zeta_inp(i,j,k)-htop_inp(i,j)) >= 300.) then
          kb = k
          exit
        endif 
      enddo
      kb = max (kb, 2)
      gamma_inp = gamma_inp+(t_inp(i,j,1)-t_inp(i,j,kb))/(zeta_inp(i,j,kb)-zeta_inp(i,j,1))
      nnn=nnn+1
    endif
    enddo
    enddo
    if (nnn > 0) then
      gamma_inp = gamma_inp/float(nnn)
    else
      gamma_inp = 0.
    endif
    gamma = max(0.35*gammac+0.65*gamma_inp, 0.) ! Limited to avoid inversions

    write(*, '(a,f8.4)') " Mean lapse rate of input model near the surface =", gamma_inp
    write(*, '(a,f8.4)') " Blended lapse rate =", gamma

!--------------------------------------------------------------------------
!          Surface pressure for prescribed model orography
!--------------------------------------------------------------------------
!   3 cases are considered:
!  1) If difference between input data orography and model orography is minimal
!     (less then about 0.1 m), input values are used without correction;
!  2) if model orography is higher than input orography, geopotential height
!     is interpolated from input data levels;
!  3) if model orography is lower than input orography, extrapolation
!     below ground is applied using a lapse rate GAMMA.

   if (input_model == 'IFS'.and.level_type == 2) then
     d2(:,:) = htop_atm_inp_mod(:,:)
   else
     d2(:,:) = htop_inp_mod(:,:)
   endif

   do j = 1, nlat
   do i = 1, nlon
   dphig = d2(i,j)*g0-phig(i,j)
   if (abs(dphig)<1.) then                            ! case 1)
     ps(i,j) = ps_inp_mod(i,j)
   else
     if (dphig<0) then                                ! case 2)
     do k = 1, nlev_inp
     if (zeta_inp_mod(i,j,k)>phig(i,j)/g0) exit
     enddo
     k1 = k
       if (k1>1) then
       ztvirt = tvirt_inp_mod(i,j,k1-1)+ (tvirt_inp_mod(i,j,k1)-tvirt_inp_mod(i,j,k1-1))* &
                (phig(i,j)/g0-zeta_inp_mod(i,j,k1-1))/(zeta_inp_mod(i,j,k1)-zeta_inp_mod(i,j,k1-1))
       else
       ztvirt = tvirt_inp_mod(i,j,1) ! Tvirt at ground surface = Tvirt at the lowest atm. level
       endif
     ztvirtmed = 0.5*(ztvirt+tvirt_inp_mod(i,j,k1))
     ps(i,j) = p_inp_mod(i,j,k1)*exp((zeta_inp_mod(i,j,k1)*g0-phig(i,j))/(rd*ztvirtmed))
     else                                            ! case 3)
     ztvirt = tvirt_inp_mod(i,j,1)+gamma*(zeta_inp_mod(i,j,1)-d2(i,j)) ! Tvirt extrapol. at input model surf.
     ztvirtmed = ztvirt+0.5*gamma*dphig/g0
     ps(i,j) = ps_inp_mod(i,j)*exp(dphig/(rd*ztvirtmed))
     endif
   endif
   enddo
   enddo

!if (inst==2) then
! call outgraph(80*1000+102,2,nlon,nlat,x0,y0,alon0,alat0+dlat*0.5,dlon,dlat,&
! 0, 3,  0,  1, 1, 0,idate0_inp(1:5),iperiod_inp(1:3),ps(:,:),1.e-2,0.)
! call outgraph(80*1000+102,2,nlon,nlat,x0,y0,alon0,alat0+dlat*0.5,dlon,dlat,&
! 0, 3,  0,105, 1, 0,idate0_inp(1:5),iperiod_inp(1:3),ps_inp_mod(:,:),1.e-2,0.)
! call outgraph(80*1000+102,2,nlon,nlat,x0,y0,alon0,alat0+dlat*0.5,dlon,dlat,&
! 0, 3,  6,105, 1, 0,idate0_inp(1:5),iperiod_inp(1:3),htop_inp_mod(:,:),1.,0.)
! call outgraph(80*1000+102,2,nlon,nlat,x0,y0,alon0,alat0+dlat*0.5,dlon,dlat,&
! 0, 3,  6,105, 1, 0,idate0_inp(1:5),iperiod_inp(1:3),htop_atm_inp_mod(:,:),1.,0.)
! call outgraph(80*1000+102,2,nlon,nlat,x0,y0,alon0,alat0+dlat*0.5,dlon,dlat,&
! 0, 3,  6,105, 1, 0,idate0_inp(1:5),iperiod_inp(1:3),zeta_inp_mod(:,:,1),1.,0.)
! call outgraph(80*1000+102,2,nlon,nlat,x0,y0,alon0,alat0+dlat*0.5,dlon,dlat,&
! 0, 0,  1,105, 1, 0,idate0_inp(1:5),iperiod_inp(1:3),tvirt_inp_mod(:,:,1),1.,-273.15)
! call outgraph(80*1000+102,2,nlon,nlat,x0,y0,alon0,alat0+dlat*0.5,dlon,dlat,&
! 0, 3,  6,105, 1, 0,idate0_inp(1:5),iperiod_inp(1:3),(d2(:,:)-phig(:,:)/g0),1.,0.)
!endif

!--------------------------------------------------------------------------
!          Vertical interpolation
!--------------------------------------------------------------------------

! Mass variables

    do    j = 1, nlat
    do 44 i = 1, nlon

! Array of input grid coordinates

    zlinp(1:nlev_inp) = zeta_inp_mod(i,j,1:nlev_inp)

! Array of output grid coordinates

    zlout(1:nlev) = zeta(i,j,1:nlev)

! Definition of auxiliary array IV

    call near (zlout(1:nlev), nlev, zlinp(1:nlev_inp), nlev_inp, iv(1:nlev))

! Interpolation: weighted average between cubic spline and linear function

    call interp_spline_1d (t(i,j,1:nlev), zlout(1:nlev), nlev, &
                           t_inp_mod(i,j,1:nlev_inp), zlinp(1:nlev_inp), nlev_inp, iv(1:nlev), 0.6,0.85,0.5)

    call interp_spline_1d (q(i,j,1:nlev), zlout(1:nlev), nlev, &
                           q_inp_mod(i,j,1:nlev_inp), zlinp(1:nlev_inp), nlev_inp, iv(1:nlev), 0.65,0.4,0.4)
    q(i,j,:) = max(q(i,j,:), 1.e-8)

    call interp_spline_1d (qcw(i,j,1:nlev), zlout(1:nlev), nlev,  &
                           qcw_inp_mod(i,j,1:nlev_inp), zlinp(1:nlev_inp), nlev_inp, iv(1:nlev), 0.7,0.4,0.4)
    qcw(i,j,:) = max (qcw(i,j,:), 0.)

    call interp_spline_1d (qci(i,j,1:nlev), zlout(1:nlev), nlev,  &
                           qci_inp_mod(i,j,1:nlev_inp), zlinp(1:nlev_inp), nlev_inp, iv(1:nlev), 0.7,0.4,0.4)
    qci(i,j,:) = max (qci(i,j,:), 0.)

! LBOT is the first output-model level above the lowest input-model level

    do k = 1, nlev
    if (zlout(k)>zlinp(1)) then
    lbot = k
    exit
    endif
    enddo

! Under LBOT level: temperature is extrapolated with lapse rate GAMMA,
! blended with the extrapolated values (computed in the vertical interpolation).
! zlap: local lapse rate (comp. over 3 lower layers, consistently with the def. of gamma_inp)
! w1: weight given to the modified profiles of t and q defined below (function of local lapse rate)

    zlap = (t_inp_mod(i,j,1) - t_inp_mod(i,j,4))/(zlinp(4)-zlinp(1))
    w1 = min(1., -1./9.*zlap*1000. + 1.) ! w1=1. for zlap<=0.deg/km; w1=0. for zlap>=9.deg/km
    w1 = max(w1, .1)
!    w1 = 0.  ! pure extrap.
!    w1 = 1. ! pure redefinitions below

    if (lbot>1) then
    t(i,j,1) = w1*(t_inp_mod(i,j,1) + gamma*(zlinp(1)-zlout(1))) + (1.-w1)*t(i,j,1)
    do k = 2, lbot
    zk1 = zlout(k) + zlinp(1) - zlout(1)
      do kb = 2, nlev_inp
      if(zlinp(kb).gt.zk1) exit   ! kb: index of input model immediately above the k level
      enddo
    ztk = (t_inp_mod(i,j,kb-1)*(zlinp(kb)-zk1)+t_inp_mod(i,j,kb)*(zk1-zlinp(kb-1)))/(zlinp(kb)-zlinp(kb-1)) !linear interp.
    t(i,j,k) = w1*(ztk + gamma*(zk1-zlout(k))) + (1.-w1)*t(i,j,k)
    enddo
    endif

! Provisional definition of tvirt

    tvirt(i,j,:) = t(i,j,:)*(1.+ep*q(i,j,:)-qcw(i,j,:)-qci(i,j,:))

! Use of the hydrostatic eq. in the case of hydrostatic model data in input.
! Use of inperpolation of input pressure data n the case of non-hydrostatic model data in input. 

    if (input_model /= 'MOLOCH'.and.input_model /= 'COSMO') then ! BOLAM, GLOBO, IFS, GFS

      zz1 = zeta(i,j,1)-phig(i,j)/g0
      ztvirtmed = tvirt(i,j,1)+0.5*gamma*zz1
      zz2 = g0/(rd*ztvirtmed)
      p(i,j,1) = ps(i,j)*exp(-zz1*zz2)
      do k = 2, nlev
      zb = 2.*g0/fmzh(i,j,k)*dz/rd+tvirt(i,j,k)-tvirt(i,j,k-1)
      zdelta = sqrt(zb**2+4.*tvirt(i,j,k-1)*tvirt(i,j,k))
      p(i,j,k) = -p(i,j,k-1)/(2.*tvirt(i,j,k-1))*(zb-zdelta)
      enddo

    else ! MOLOCH, COSMO

! Array of input grid coordinates

      zlinp(2:nlev_inp+1) = zeta_inp_mod(i,j,1:nlev_inp)
      zlinp(1) = htop_inp_mod(i,j)

! Array of output grid coordinates

      zlout(1:nlev) = zeta(i,j,1:nlev)

! Definition of auxiliary array IV

      call near (zlout(1:nlev), nlev, zlinp(1:nlev_inp+1), nlev_inp+1, iv(1:nlev))

! Definition of input function

      zfinp(2:nlev_inp+1) = p_inp_mod(i,j,1:nlev_inp)
      zfinp(1) = ps(i,j)

! Interpolation: weighted average between cubic spline and linear function

      call interp_spline_1d (p(i,j,1:nlev), zlout(1:nlev), nlev, &
                             zfinp(1:nlev_inp+1), zlinp(1:nlev_inp+1), nlev_inp+1, iv(1:nlev), 0.9,0.50,0.50)

    endif

! Recomputation of Q at levels below the lowest input model level.
! Pressure on model levels is required to compute relative humidity.
! If lapse rate is not large, Q is extrapolated with constant relative humidity.
! Values computed as above are then blended with those extrapolated with interp_spline_1d.

    call qsat_entropy (t_inp_mod(i,j,1), p_inp_mod(i,j,1), zqs, zzz1,zzz2,zzz3,zzz4,zzz5,fracw)
    zrh1 = min (q_inp_mod(i,j,1)/zqs, 1.)

    if (lbot>1) then
    do k = 1, lbot
    call qsat_entropy (t_inp_mod(i,j,k), p_inp_mod(i,j,k), zqs, zzz1,zzz2,zzz3,zzz4,zzz5,fracw)
    zrh = min (q_inp_mod(i,j,k)/zqs, 1.)
    zrh = 0.85*zrh + 0.15*zrh1
    call qsat_entropy (t(i,j,k), p(i,j,k), zqs, zzz1,zzz2,zzz3,zzz4,zzz5,fracw)
    q(i,j,k) = w1*zrh*zqs + (1.-w1)*q(i,j,k)
    q(i,j,k) = min(q(i,j,k), zqs)
      if (q(i,j,k)/zqs<0.95) then
      qcw(i,j,k) = 0.
      qci(i,j,k) = 0.
      endif
    enddo
    endif

 44 continue
    enddo

! U-component of wind in U-points of model grid

    do    j = 1, nlat
    do 45 i = 1, nlon

    ip1 = min(nlon, i+1)

! Array of input grid coordinates

    if (input_model == 'BOLAM'.or.input_model == 'MOLOCH'.or.input_model == 'COSMO') then
      zlinp(1:nlev_inp) = 0.5*(zeta_inp_mod(i,j,1:nlev_inp)+zeta_inp_mod(ip1,j,1:nlev_inp))
    else ! IFS, GFS
      zlinp(1:nlev_inp) = zeta_inp_mod(i,j,1:nlev_inp)
    endif

    zfinp(1:nlev_inp) = u_inp_mod(i,j,1:nlev_inp)
    zlout(1:nlev) = zeta_u(i,j,1:nlev)
    call near (zlout(1:nlev), nlev, zlinp(1:nlev_inp), nlev_inp, iv(1:nlev))
    call interp_spline_1d (u(i,j,1:nlev), zlout(1:nlev), nlev,   &
                           zfinp(1:nlev_inp), zlinp(1:nlev_inp), nlev_inp, iv(1:nlev), 0.6,0.2,0.2)

! LBOT is the first output level above the lowest input level

    do k = 1, nlev
    if (zlout(k)>zlinp(1)) then
    lbot = k
    exit
    endif
    enddo

!  Below LBOT reconstruction of the wind profile using linear interpolation in z
!  Note that wind at the lowest level is further reduced elsewhere as a function of rgm

    if(lbot>1) u(i,j,1) = zfinp(1)
    if(lbot>2) then
      do k = 2, lbot-1
      u(i,j,k) = u(i,j,1) + (zlout(k)-zlout(1))*(u(i,j,lbot)-u(i,j,1))/(zlout(lbot)-zlout(1))
      enddo
    endif
!   if(lbot==1) u(i,j,1) = 0.65*u(i,j,1) + 0.35*zfinp(1) ! should reduce wind at lowest level when interpolated

 45 continue
    enddo

! V-component of wind in V-points of model grid

    do    j = 1, nlat
      jm1 = max(1, j-1)
      jp1 = min(nlat, j+1)
    do 46 i = 1, nlon

    if (input_model == 'BOLAM'.or.input_model == 'MOLOCH') then
      zlinp(1:nlev_inp) = 0.5*(zeta_inp_mod(i,j,1:nlev_inp)+zeta_inp_mod(i,jm1,1:nlev_inp))
    elseif (input_model == 'COSMO') then
      zlinp(1:nlev_inp) = 0.5*(zeta_inp_mod(i,j,1:nlev_inp)+zeta_inp_mod(i,jp1,1:nlev_inp))
    else ! IFS, GFS
      zlinp(1:nlev_inp) = zeta_inp_mod(i,j,1:nlev_inp)
    endif

    zfinp(1:nlev_inp) = v_inp_mod(i,j,1:nlev_inp)
    zlout(1:nlev) = zeta_v(i,j,1:nlev)
    call near (zlout(1:nlev), nlev, zlinp(1:nlev_inp), nlev_inp, iv(1:nlev))
    call interp_spline_1d (v(i,j,1:nlev), zlout(1:nlev), nlev,  &
                           zfinp(1:nlev_inp), zlinp(1:nlev_inp), nlev_inp, iv(1:nlev), 0.6,0.2,0.2)

! LBOT is the first output level above the lowest input level

    do k = 1, nlev
    if (zlout(k)>zlinp(1)) then
    lbot = k
    exit
    endif
    enddo

! Below LBOT reconstruction of the wind profile using linear interpolation in z
! Note that wind at the lowest level is further reduced elsewhere as a function of rgm

    if(lbot>1) v(i,j,1) = zfinp(1)
    if(lbot>2) then
     do k = 2, lbot-1
     v(i,j,k) = v(i,j,1) + (zlout(k)-zlout(1))*(v(i,j,lbot)-v(i,j,1))/(zlout(lbot)-zlout(1))
     enddo
    endif
!    if(lbot==1) v(i,j,1) = 0.65*v(i,j,1) + 0.35*zfinp(1) ! should reduce wind at lowest level when interpolated

 46 continue
    enddo

! Vertical velocity at semi-integer levels

  if (input_model == 'BOLAM'.or.input_model == 'MOLOCH'.or.input_model == 'COSMO') then

    do    j = 1, nlat
    do 47 i = 1, nlon

    jp1 = min(j+1,nlat)
    jm1 = max(j-1,1)
    ip1 = min(i+1,nlon)
    im1 = max(i-1,1)

    zlout(1:nlev) = zetah(i,j,1:nlev)

    if (input_model == 'BOLAM') then

      zlinp(1:nlev_inp) = zeta_inp_mod(i,j,1:nlev_inp)
      zfinp(1:nlev_inp) = w_inp_mod(i,j,1:nlev_inp)
      call near (zlout(1:nlev), nlev, zlinp(1:nlev_inp), nlev_inp, iv(1:nlev))
      call interp_spline_1d (w(i,j,1:nlev), zlout(1:nlev), nlev, &
                           zfinp(1:nlev_inp), zlinp(1:nlev_inp), nlev_inp, iv(1:nlev), 0.65,0.6,0.0)

    elseif (input_model == 'MOLOCH') then

      zlinp(1:nlev_inp) = zetah_inp_mod(i,j,1:nlev_inp)
      zfinp(1:nlev_inp) = w_inp_mod(i,j,1:nlev_inp)
      call near (zlout(1:nlev), nlev, zlinp(1:nlev_inp), nlev_inp, iv(1:nlev))
      call interp_spline_1d (w(i,j,1:nlev), zlout(1:nlev), nlev, &
                           zfinp(1:nlev_inp), zlinp(1:nlev_inp), nlev_inp, iv(1:nlev), 0.65,0.6,0.0)


    else ! COSMO

      zlinp(1:nlev_inp+1) = zetah_inp_mod(i,j,1:nlev_inp+1)
      zfinp(1:nlev_inp+1) = w_inp_mod(i,j,1:nlev_inp+1)
      call near (zlout(1:nlev), nlev, zlinp(1:nlev_inp+1), nlev_inp+1, iv(1:nlev))
      call interp_spline_1d (w(i,j,1:nlev), zlout(1:nlev), nlev, &
                           zfinp(1:nlev_inp+1), zlinp(1:nlev_inp+1), nlev_inp+1, iv(1:nlev), 0.65,0.6,0.0)

    endif

    w(i,j,nlevp1) = 0.

! LBOT is the first output level above the lowest input level

    do k = 1, nlev
    if (zlout(k)>zlinp(1)) then
    lbot = k
    exit
    endif
    enddo

! Under LBOT level: definition using horizontal wind gradient

    if (lbot>1) then
    do k = 1, lbot-1
    k1 = max(k-1,1)
    zuhx = (u(i,j,k1)+u(i,j,k))*hx_slope(i,j) + (u(im1,j,k1)+u(im1,j,k))*hx_slope(im1,j)
    zvhy = (v(i,j,k1)+v(i,j,k))*hy_slope(i,j) + (v(i,jp1,k1)+v(i,jp1,k))*hy_slope(i,jp1)
    w(i,j,k) = 0.25*(zuhx+zvhy)*fzh(k)
    enddo
    endif

 47 continue
    enddo

 else

   w(:,:,:) = 0.

 endif

! Final definition of tvirt and pressure on model levels

    tvirt = t*(1.+ep*q-qcw-qci)

! Pressure on model atmospheric levels using the hydrostatic eq.

    do j = 1, nlat
    do i = 1, nlon
    zz1 = zeta(i,j,1)-phig(i,j)/g0
    zz2 = g0/(rd*tvirt(i,j,1))
    p(i,j,1) = ps(i,j)*exp(-zz1*zz2)
    do k = 2, nlev
    zb = 2.*g0/fmzh(i,j,k)*dz/rd+tvirt(i,j,k)-tvirt(i,j,k-1)
    zdelta = sqrt (zb**2 + 4.*tvirt(i,j,k-1)*tvirt(i,j,k))
    p(i,j,k) = -p(i,j,k-1)/(2.*tvirt(i,j,k-1))*(zb-zdelta)
    enddo
    enddo
    enddo

!--------------------------------------------------------------------------
!          Definition of surface variables
!--------------------------------------------------------------------------

 if (surf_elaborate) call premoloch_surf (inst)

! Correction of wind at the lowest level as a function of roughness (defined in premoloch_surf)

 do j=1,nlat
 do i=1,nlon
 u(i,j,1) = u(i,j,1)/(1.+0.1*min(rgm(i,j),8.))
 v(i,j,1) = v(i,j,1)/(1.+0.1*min(rgm(i,j),8.))
 enddo
 enddo

! Filter of wind

! do k = 1, 3
! call filt (u, nlon, nlat, nlev)
! call filt (v, nlon, nlat, nlev)
! enddo

! Print maximum absolute values of velocity components

 umax=maxval(abs(u))
 vmax=maxval(abs(v))
 wmax=maxval(abs(w))
 indumax=maxloc(abs(u))
 indvmax=maxloc(abs(v))
 indwmax=maxloc(abs(w))

    print 1010, umax, vmax, wmax
    print 1011, indumax(1),indumax(2),indumax(3),indvmax(1),indvmax(2),indvmax(3), &
                indwmax(1),indwmax(2),indwmax(3)
 1010 format(' Max. abs. u, v, w =',3F14.3)
 1011 format('        at i, j, lev    ',3I4,2X,3I4,2X,3I4)

! Print date of the pre-processed instant

    print*, "Date (yyyy mm dd), time (hh mm) of the initial cond.:"
    print '(i11, i3.2, i3.2, i11.2, i3.2)', idate0(:)
    print*, "Time (dd hh mm) of the processed instant:"
    print '(i9.2, 2(i3.2))', iperiod_inp(:)

!---------------------------------------------------------------------------
!    Output writing
!---------------------------------------------------------------------------

!i=ipoint; j=jpoint
!write (31,*) ' ------------------------'
!write (31,*) ' p '
!write (31,*) p(i,j,1:nlev)
!write (31,*) ' u '
!write (31,*) u(i,j,1:nlev)
!write (31,*) ' v '
!write (31,*) v(i,j,1:nlev)
!write (31,*) ' w '
!write (31,*) w(i,j,1:nlev+1)
!write (31,*) ' t '
!write (31,*) t(i,j,1:nlev)
!write (31,*) ' q '
!write (31,*) q(i,j,1:nlev)
!write (31,*) ' qcw '
!write (31,*) qcw(i,j,1:nlev)
!write (31,*) ' qci '
!write (31,*) qci(i,j,1:nlev)
!write (31,*) ' veg_lai '
!write (31,*) veg_lai(i,j)
!write (31,*) ' veg_frac '
!write (31,*) veg_frac(i,j)
!write (31,*) ' rgm '
!write (31,*) rgm(i,j)
!write (31,*) ' rgq '
!write (31,*) rgq(i,j)
!write (31,*) ' iceth '
!write (31,*) iceth(i,j)
!write (31,*) ' fice '
!write (31,*) fice(i,j)
!write (31,*) ' albedo '
!write (31,*) albedo(i,j)
!write (31,*) ' emismap1 '
!write (31,*) emismap1(i,j)
!write (31,*) ' emismap2 '
!write (31,*) emismap2(i,j)
!write (31,*) ' tsurf '
!write (31,*) tsurf(i,j)
!write (31,*) ' tgsurf '
!write (31,*) tgsurf(i,j)
!write (31,*) ' tg '
!write (31,*) tg(i,j,1:nlevg)
!write (31,*) ' qvsurf '
!write (31,*) qvsurf(i,j)
!write (31,*) ' qgsurf '
!write (31,*) qgsurf(i,j)
!write (31,*) ' qg '
!write (31,*) qg(i,j,1:nlevg)
!write (31,*) ' fice_soil_surf '
!write (31,*) fice_soil_surf(i,j)
!write (31,*) ' fice_soil '
!write (31,*) fice_soil(i,j,1:nlevg)
!write (31,*) ' snow '
!write (31,*) snow(i,j)
!write (31,*) ' snow_lev '
!write (31,*) snow_lev(i,j,1:nlevsnow)
!write (31,*) ' snow_t '
!write (31,*) snow_t(i,j,1:nlevsnow)
!write (31,*) ' snow_fice '
!write (31,*) snow_fice(i,j,1:nlevsnow)
!write (31,*) ' snow_age '
!write (31,*) snow_age(i,j,1:nlevsnow)
!write (31,*) ' snow_melt_age '
!write (31,*) snow_melt_age(i,j,1:nlevsnow)
!write (31,*) ' snow_dens '
!write (31,*) snow_dens(i,j,1:nlevsnow)
!write (31,*) ' snow_albedo '
!write (31,*) 0.71
!write (31,*) ' htop'
!write (31,*) phig(i,j)/g0
!write (31,*) ' htopvar'
!write (31,*) htopvar(i,j)
!write (31,*) ' soil_map'
!write (31,*) soil_map(i,j,1:nst+1)
!write (31,*) ' veg_map'
!write (31,*) veg_map(i,j,1:nvt+1)
!write (31,*) ' soil_qmax'
!write (31,*) soil_qmax(i,j,1:nlevg)
!write (31,*) ' soil_qmin'
!write (31,*) soil_qmin(i,j,1:nlevg)
!write (31,*) ' soil_c'
!write (31,*) soil_c(i,j,1:nlevg)
!write (31,*) ' soil_rho'
!write (31,*) soil_rho(i,j,1:nlevg)
!write (31,*) ' soil_psi'
!write (31,*) soil_psi(i,j,1:nlevg)
!write (31,*) ' soil_k'
!write (31,*) soil_k(i,j,1:nlevg)
!write (31,*) ' soil_par_b'
!write (31,*) soil_par_b(i,j,1:nlevg)
!write (31,*) ' soil_par_c'
!write (31,*) soil_par_c(i,j,1:nlevg)
!write (31,*) ' soil_qrel_wilt'
!write (31,*) soil_qrel_wilt(i,j,1:nlevg)
!write (31,*) ' soil_qrel_ref'
!write (31,*) soil_qrel_ref(i,j,1:nlevg)
!write (31,*) ' soil_albedo_dry'
!write (31,*) soil_albedo_dry(i,j)
!write (31,*) ' soil_albedo_wet'
!write (31,*) soil_albedo_wet(i,j) 
!write (31,*) ' soil_emiss1_dry'
!write (31,*) soil_emiss1_dry(i,j)
!write (31,*) ' soil_emiss1_wet'
!write (31,*) soil_emiss1_wet(i,j)
!write (31,*) ' soil_emiss2_dry'
!write (31,*) soil_emiss2_dry(i,j)
!write (31,*) ' soil_emiss2_wet'
!write (31,*) soil_emiss2_wet(i,j)
!write (31,*) ' veg_root_depth'
!write (31,*) veg_root_depth(i,j)
!write (31,*) ' veg_roughness'
!write (31,*) veg_roughness(i,j)
!write (31,*) ' veg_albedo'
!write (31,*) veg_albedo(i,j)
!write (31,*) ' veg_emiss1'
!write (31,*) veg_emiss1(i,j)
!write (31,*) ' veg_emiss2'
!write (31,*) veg_emiss2(i,j)
!write (31,*) ' ind_lev_soil_h_bottom'
!write (31,*) ind_lev_soil_h_bottom(i,j)
!write (31,*) ' ind_lev_soil_w_bottom'
!write (31,*) ind_lev_soil_w_bottom(i,j)
!write (31,*) ' veg_lai_max'
!write (31,*) veg_lai_max

    if (inst == 1.and.flag_constant_fields == 1) then
      call write_param_const
    endif

    call write_mhf_atm(inst)
    call write_mhf_soil(inst)

! call outgraph(80102,2,nlon,nlat,x0,y0,alon0,alat0+dlat*0.5,dlon,dlat,&
! 2, 0,  0,  1, 1, 0,idate0(1:5),iperiod(1:3),fmask(:,:),1.,0.)
! call outgraph(80102,2,nlon,nlat,x0,y0,alon0,alat0+dlat*0.5,dlon,dlat,&
! 0, 0,  0,  1, 1, 0,idate0(1:5),iperiod(1:3),((qg(:,:,11)-soil_qmin(:,:,11))/(soil_qmax(:,:,11)-soil_qmin(:,:,11))),1.,0.)

!---------------------------------------------------------------------------

! Deallocation of input data array (for possibility to have
! various resolution of input data in different instants).
! Never resolution changing in the case of input data 
! from Bolam and Moloch models. So some array used only for this
! input data will not deallocated.

 deallocate(field3d)
 deallocate(field2d)
 deallocate(field3d_soil)

 deallocate(alon_t_inp)
 deallocate(alon_u_inp)
 deallocate(alon_v_inp)
 deallocate(alat_t_inp)
 deallocate(alat_u_inp)
 deallocate(alat_v_inp)
 deallocate(mask_frame)

 deallocate(zeta_inp)
 deallocate(zetah_inp)
 deallocate(u_inp)
 deallocate(v_inp)
 deallocate(w_inp)
 deallocate(t_inp)
 deallocate(tvirt_inp)
 deallocate(q_inp)
 deallocate(qc_inp)
 deallocate(qcw_inp)
 deallocate(qci_inp)
 deallocate(p_inp)
 deallocate(htop_inp)
 deallocate(htop_atm_inp)
 deallocate(fmask_inp)
 deallocate(ps_inp)
 deallocate(tsurf_inp)
 deallocate(qvsurf_inp)
 deallocate(tg_inp)
 deallocate(qg_inp)
 deallocate(qgmax_inp)
 deallocate(qgmin_inp)
 deallocate(tice_inp)
 deallocate(snow_inp)
 deallocate(fice_inp)
 deallocate(iceth_inp)
 deallocate(d2_inp)

 deallocate(alon_rot_inp)
 deallocate(alat_rot_inp)
 deallocate(x_t_inp)
 deallocate(x_u_inp)
 deallocate(y_t_inp)
 deallocate(y_v_inp)

 deallocate(psl_inp)
 deallocate(u_inp_rot)
 deallocate(v_inp_rot)
 deallocate(u_inp_work)
 deallocate(v_inp_work)
 deallocate(tsurf_work_inp)

!---------------------------------------------------------------------------

 enddo inst_loop

 stop
 end program premoloch
!------------------------------------------------------------------------------
subroutine read_moloch_mhf_data(ifl, filename_atm, filename_soil, data_mode, ini_flag, nlev_atm_inp_max, nlev_soil_inp_max, &
 nlon_inp, nlat_inp, nlev_inp, nlevg_inp, &
 x0_inp, y0_inp, alon0_inp, alat0_inp, dlon_inp, dlat_inp, &
 level_type, lev_list_inp, soil_lev_inp, idate0_inp, iperiod_inp, &
 frame, mask_frame, &
 htop_inp, fmask_inp, ps_inp, &
 zeta_inp, zetah_inp, p_inp, t_inp, u_inp, v_inp, w_inp, q_inp, qcw_inp, qci_inp, &
 tg_inp, qg_inp, tsurf_inp, qvsurf_inp, snow_inp, fice_inp, iceth_inp, qgmax_inp, qgmin_inp)

! Reads a MOLOCH-type MHF
!------------------------------------------------------------------------
! Following parameters must be defined in output of this procedure:
!
! nlev_inp  - atmospheric levels number in input data;
! nlevg_inp  - soil levels number in input data;
! nlon_inp  - grid point number of input data along x-axis;
! nlat_inp  - grid point number of input data along y-axis;
! x0_inp, y0_inp - center of input grid rotation;
! alon0_inp, alat0_inp - origin (south-west) point of input grid;
! dlon_inp, dlat_inp - space steps of input grid;
! level_type - type of atmopheric levels in input data (hybrid or isobaric);
! lev_list_inp - 1d array with atmospheric level list of input data;
! soil_lev_inp - 1d array with soil level list of input data;
! idate0_inp - 1d array with date, time of simulation start or analysis;
! iperiod_inp - 1d array with simulation term;
! frame - logical flag: .false. - no frame in input data, .true. - frame in input data
! mask_frame - 2d ingeter array with flag of input data presence in a grid point,
! if no frame, then all values of mask_frame equal 1;
! htop_inp - 2d array with topography hight (m) of input data;
! fmask_inp - 2d array with sea-land fraction (1-sea, 0-land) of input data;
! ps_inp - 2d array with surface pressure (Pa) of input data;
! zeta_inp - 3d array with geometric altitude (m, over sea surface) of integer atmospheric levels of input data;
! zetah_inp - 3d array with geometric altitude (m, over sea surface) of half atmospheric levels of input data;
! p_inp - 3d array with pressure (Ps) at atmospheric levels of input data;
! t_inp - 3d array with temperature (K) at atmospheric levels of input data;
! u_inp - 3d array with u-component of wind (m/s) at atmospheric levels of input data;
! v_inp - 3d array with v-component of wind (m/s) at atmospheric levels of input data;
! w_inp - 3d array with vertical velocity (m/s) at atmospheric half-levels of input data;
! q_inp - 3d array with specific humidity (kg/kg) at atmospheric levels of input data;
! qcw_inp - 3d array with specific cloud liquid water content (kg/kg) at atmospheric levels of input data;
! qci_inp - 3d array with specific cloud ice water content (kg/kg) at atmospheric levels of input data;
! tg_inp - 3d array with temperature (m/s) at soil levels of input data;
! qg_inp - 3d array with specific volumetric soil water content (m^3/m^3) at soil levels of input data;
! qgmax_inp - 3d array with maximum specific volumetric soil water content (m^3/m^3) at soil levels of input data;
! qgmin_inp - 3d array with minimum specific volumetric soil water content (m^3/m^3) at soil levels of input data;
! tsurf_inp - 2d array with surface temperature (K);
! qvsurf_inp - 2d array with specipic humidity (kg/kg) at the surface;
! snow_inp - 2d array with total water content of surface snow cover (kg/m^2);
! fice_inp - 2d array with fraction of sea ice cover (proportion) at the surface;
! iceth_inp - 2d array with thickness of sea ice cover (m) at the surface.
!
!------------------------------------------------------------------------

implicit none

! Input

integer :: ifl
character (len=80) :: filename_atm, filename_soil
integer :: data_mode ! 1 - united file, 2 - separated files
logical :: ini_flag
integer :: nlev_atm_inp_max, nlev_soil_inp_max

! Output

integer, dimension(nlon_inp,nlat_inp) :: mask_frame
logical :: frame
integer :: level_type, nlon_inp, nlat_inp, nlev_inp, nlevg_inp
integer, dimension(5) :: idate0_inp
integer, dimension(3) :: iperiod_inp
real :: x0_inp, y0_inp, alon0_inp, alat0_inp, dlon_inp, dlat_inp
real, dimension(nlev_atm_inp_max) :: lev_list_inp
real, dimension(nlev_soil_inp_max) :: soil_lev_inp
real, dimension(nlon_inp,nlat_inp) :: htop_inp, fmask_inp, ps_inp, tsurf_inp, qvsurf_inp, snow_inp, fice_inp, iceth_inp
real, dimension(nlon_inp,nlat_inp,nlev_atm_inp_max) :: zeta_inp, p_inp, t_inp, u_inp, v_inp, q_inp, qcw_inp, qci_inp
real, dimension(nlon_inp,nlat_inp,nlev_atm_inp_max+1) :: zetah_inp, w_inp
real, dimension(nlon_inp,nlat_inp,nlev_soil_inp_max+1) :: tg_inp, qg_inp, qgmax_inp, qgmin_inp

! For reading

integer :: unit_atm = 21, unit_soil = 22, unit_const = 23
integer, dimension(50) :: nfdr, nfdr_soil
real, dimension(100)   :: pdr, pdr_soil
character (len=80) :: filename_const = "model_param_constant_inp.bin"
integer, parameter :: nlevsnow=11

! For working

integer :: ierr_open_atm=0, ierr_open_soil=0, ierr_open_const=0, ierr_read=0, i, j, k, ird, &
 ierr, nlon_const, nlat_const, nlevg_const, nst_inp, nvt_inp 
real, parameter :: rd=287.05, rv=461.51, g0=9.807, h=rd*273.32/g0, ep=rv/rd-1.
real, save :: a0, b0, dz
real :: dlon_const, dlat_const, x0_const, y0_const, alon0_const, alat0_const, &
 zita, zitah, zfz, zfzh, zgzita, zgzitah, zbzita, zbzitah, ztvirt, zdgz, zz1 
real, dimension(nlon_inp,nlat_inp) :: read2d_work
real, allocatable, dimension(:,:,:), save :: zeta_inp_save, zetah_inp_save

 if (data_mode==2) then
   open (unit_atm, file=trim(filename_atm), status='old', form='unformatted', iostat=ierr_open_atm)
   open (unit_soil, file=trim(filename_soil), status='old', form='unformatted', iostat=ierr_open_soil)
 else
   if (ifl == 0) then
     open (unit_atm, file=trim(filename_atm), status='old', form='unformatted', iostat=ierr_open_atm)
     open (unit_soil, file=trim(filename_soil), status='old', form='unformatted', iostat=ierr_open_soil)
   endif
 endif

 if (ierr_open_atm /= 0) then
   print *,"Error in opening of input file ", trim(filename_atm)
   stop
 endif

 if (ierr_open_soil /= 0) then
   print *,"Error in opening of input file ", trim(filename_soil)
   stop
 endif

 read(unit_soil, iostat=ierr_read) nfdr_soil
 read(unit_atm, iostat=ierr_read) nfdr
 if (ierr_read /= 0) then
   print *,"End of file encountered in reading input file ", trim(filename_atm)
   stop
 endif
 read(unit_atm) pdr
 read(unit_soil) pdr_soil

 if (ini_flag) then

   if (data_mode == 1) then
     rewind (unit_atm)
     rewind (unit_soil)
   else
     close (unit_atm)
     close (unit_soil)
   endif

   if (any(nfdr(:) /= nfdr_soil(:))) then
     print *,"Not concidence of nfdr parameters in ",trim(filename_atm)," and ",trim(filename_soil)," input files, stop"
     stop
   endif

   if (any(pdr(:) /= pdr_soil(:))) then
     print *,"Not concidence of pdr parameters in ",trim(filename_atm)," and ",trim(filename_soil)," input files, stop"
     stop
   endif

   level_type    = 2       ! hybrid levels
   nlon_inp      = nfdr(2)
   nlat_inp      = nfdr(3)
   nlev_inp      = nfdr(4)
   nlevg_inp     = nfdr(15)
   x0_inp        = pdr(39)
   y0_inp        = pdr(38)
   dlon_inp      = pdr(2)
   dlat_inp      = pdr(1)
   alon0_inp     = pdr(5)
   alat0_inp     = pdr(4)
   b0            = pdr(42)
   a0            = pdr(43)

   dz=h/float(nlev_inp)

   do k = 1,nlev_inp
     lev_list_inp(k)=float(k)
   enddo
   soil_lev_inp(1:nlevg_inp) = pdr(6:6+nlevg_inp-1)

   if (any(nfdr(5:9) /= nfdr_soil(5:9))) then
     print *,"Not coincidence of initial data read from ",trim(filename_atm)," and ",trim(filename_soil),":"
     print *,trim(filename_atm)," ",nfdr(5:9)
     print *,trim(filename_soil)," ",nfdr_soil(5:9)
     print *," stop"
     stop
   endif

   idate0_inp(1:5) = nfdr(5:9)

   print*
   print *,'Date (YYYY MM DD) and time (HH MM, analysis time) of the input fields:'
   print *,idate0_inp(1:3),'            ',idate0_inp(4:5)

   return

 endif

 if (ifl >= 1) then

! Reading of constant physiographical parameters of input model

   open (unit_const, file=trim(filename_const), status='old', form='unformatted', iostat=ierr_open_const)

   if (ierr_open_const /= 0) then
     print *,"Error in opening of input file ", trim(filename_const),", stop"
     stop
   endif

   read (unit_const) nlon_const, nlat_const, nlevg_const, dlon_const, dlat_const, &
 x0_const, y0_const, alon0_const, alat0_const, nst_inp, nvt_inp

   ierr=0
   if (nlon_inp /= nlon_const) ierr=ierr+1
   if (nlat_inp /= nlat_const) ierr=ierr+1
   if (nlevg_inp /= nlevg_const) ierr=ierr+1
   if (abs(dlon_inp-dlon_const) > 1.e-4) ierr=ierr+1
   if (abs(dlat_inp-dlat_const) > 1.e-4) ierr=ierr+1
   if (abs(x0_inp-x0_const) > 1.e-4) ierr=ierr+1
   if (abs(y0_inp-y0_const) > 1.e-4) ierr=ierr+1
   if (abs(alon0_inp-alon0_const) > 1.e-4) ierr=ierr+1
   if (abs(alat0_inp-alat0_const-dlat_const*0.5) > 1.e-4) ierr=ierr+1

   if (ierr /= 0) then
     write (*,*)
     write (*,*) "Error in header parameters in input file, ",trim(filename_const),", not coincident with parameters read from ",&
 trim(filename_atm)
     write (*,*) trim(filename_atm)," nlon, nlat, nlevg, dlon, dlat, x0, y0, alon0, alat0 :", &
 nlon_inp, nlat_inp, nlevg_inp, dlon_inp, dlat_inp, x0_inp, y0_inp, alon0_inp, alat0_inp
     write (*,*) trim(filename_const)," nlon, nlat, nlevg, dlon, dlat, x0, y0, alon0, alat0 :", &
 nlon_const, nlat_const, nlevg_const, dlon_const, dlat_const, x0_const, y0_const, alon0_const, alat0_const-dlat_const*0.5
     write (*,*) "  stop"
     stop
   endif

! Sea-land fraction

   call rrec2 (unit_const, nlon_inp, nlat_inp, fmask_inp(1:nlon_inp,1:nlat_inp))

! Topography hight

   call rrec2 (unit_const, nlon_inp, nlat_inp, htop_inp(1:nlon_inp,1:nlat_inp))

   do ird = 1,1 ! Topography variation
     call rrec2 (unit_const, nlon_inp, nlat_inp, read2d_work(1:nlon_inp,1:nlat_inp))
   enddo

   do ird = 1,nst_inp+1 ! Soil types
     call rrec2 (unit_const, nlon_inp, nlat_inp, read2d_work(1:nlon_inp,1:nlat_inp))
   enddo

   do ird = 1,nvt_inp+1 ! Vegetation types
     call rrec2 (unit_const, nlon_inp, nlat_inp, read2d_work(1:nlon_inp,1:nlat_inp))
   enddo

   do k = 1,nlevg_inp
     call rrec2 (unit_const, nlon_inp, nlat_inp, qgmax_inp(1:nlon_inp,1:nlat_inp,k))
   enddo

   do k = 1,nlevg_inp
     call rrec2 (unit_const, nlon_inp, nlat_inp, qgmin_inp(1:nlon_inp,1:nlat_inp,k))
   enddo

   close (unit_const)

 endif ! ifl >= 1

 frame=.false.
 mask_frame(:,:) = 1

 if (any(nfdr(10:12) /= nfdr_soil(10:12))) then
   print *,"Not coincidence of validity time read from ",trim(filename_atm)," and ",trim(filename_soil),":"
   print *,trim(filename_atm)," ",nfdr(10:12)
   print *,trim(filename_soil)," ",nfdr_soil(10:12)
   print *," stop"
   stop
 endif

 iperiod_inp(1:3) = nfdr(10:12)

 print *,'Validity time if forecast (00 if analysis) (days, hours, minutes):'
 print *,iperiod_inp(1:3)

! Atmospheric variables

 do k = 1,nlev_inp
   call rrec2 (unit_atm, nlon_inp, nlat_inp, p_inp(1:nlon_inp,1:nlat_inp,k))
 enddo

 do k = 1,nlev_inp
   call rrec2 (unit_atm, nlon_inp, nlat_inp, u_inp(1:nlon_inp,1:nlat_inp,k))
 enddo

 do k = 1,nlev_inp
   call rrec2 (unit_atm, nlon_inp, nlat_inp, v_inp(1:nlon_inp,1:nlat_inp,k))
 enddo

 do k = 1,nlev_inp+1
   call rrec2 (unit_atm, nlon_inp, nlat_inp, w_inp(1:nlon_inp,1:nlat_inp,k))
 enddo

 do k = 1,nlev_inp
   call rrec2 (unit_atm, nlon_inp, nlat_inp, t_inp(1:nlon_inp,1:nlat_inp,k))
 enddo

 do k = 1,nlev_inp
   call rrec2 (unit_atm, nlon_inp, nlat_inp, q_inp(1:nlon_inp,1:nlat_inp,k))
 enddo

 do k = 1,nlev_inp
   call rrec2 (unit_atm, nlon_inp, nlat_inp, qcw_inp(1:nlon_inp,1:nlat_inp,k))
 enddo

 do k = 1,nlev_inp
   call rrec2 (unit_atm, nlon_inp, nlat_inp, qci_inp(1:nlon_inp,1:nlat_inp,k))
 enddo

! Surface, soil, sea variables

 do ird = 1,4 ! Vegetation LAI, Vegetation fraction, RGM, RGQ
   call rrec2 (unit_soil, nlon_inp, nlat_inp, read2d_work(1:nlon_inp,1:nlat_inp))
 enddo

 call rrec2 (unit_soil, nlon_inp, nlat_inp, fice_inp(1:nlon_inp,1:nlat_inp))

 call rrec2 (unit_soil, nlon_inp, nlat_inp, iceth_inp(1:nlon_inp,1:nlat_inp))

 do ird = 1,6 ! Albedo, 2 emisivities, Tot. cloudness, Tot. prec., Snow prec.
   call rrec2 (unit_soil, nlon_inp, nlat_inp, read2d_work(1:nlon_inp,1:nlat_inp))
 enddo

 call rrec2 (unit_soil, nlon_inp, nlat_inp, tsurf_inp(1:nlon_inp,1:nlat_inp))

 do ird = 1,1 ! tg surface
   call rrec2 (unit_soil, nlon_inp, nlat_inp, read2d_work(1:nlon_inp,1:nlat_inp))
 enddo

 do k = 1,nlevg_inp
   call rrec2 (unit_soil, nlon_inp, nlat_inp, tg_inp(1:nlon_inp,1:nlat_inp,k))
 enddo

 call rrec2 (unit_soil, nlon_inp, nlat_inp, qvsurf_inp(1:nlon_inp,1:nlat_inp))

 do ird = 1,1 ! qg surface
   call rrec2 (unit_soil, nlon_inp, nlat_inp, read2d_work(1:nlon_inp,1:nlat_inp))
 enddo

 do k = 1,nlevg_inp
   call rrec2 (unit_soil, nlon_inp, nlat_inp, qg_inp(1:nlon_inp,1:nlat_inp,k))
 enddo

 do ird = 1,nlevg_inp+1 ! Soil ice fraction at surface and at soil levels
   call rrec2 (unit_soil, nlon_inp, nlat_inp, read2d_work(1:nlon_inp,1:nlat_inp))
 enddo

 call rrec2 (unit_soil, nlon_inp, nlat_inp, snow_inp(1:nlon_inp,1:nlat_inp))

 do ird = 1,6 ! Snow mass, temperature, ice fraction, age, melting age, density at snow levels
   do k = 1,nlevsnow
     call rrec2 (unit_soil, nlon_inp, nlat_inp, read2d_work(1:nlon_inp,1:nlat_inp))
   enddo
 enddo

 do ird = 1,15 ! Snow albedo, CSWFl, CLWFl, CHFlux, CQFlux, T2Min, T2Max, WS10Max, Runoff, Runoff total, CHFluxbottom, CWVflux, Wfluxbottom, LevSnowfall, 1 empty
   call rrec2 (unit_soil, nlon_inp, nlat_inp, read2d_work(1:nlon_inp,1:nlat_inp))
 enddo

 if (data_mode == 2) then
   close (unit_atm)
   close (unit_soil)
 endif

! Definition of altitude of integer (zeta_inp) and half (zetah_inp) atmospheric levels 

 if (ifl == 1) then

   do k = 1,nlev_inp
     zita  = float(k-1)*dz+dz*0.5
     zitah = float(k-1)*dz
     zfz   = 1.-zita /h
     zfzh  = 1.-zitah/h
     zgzita  = 1.-a0*(zita /h)-(3.-2.*a0)*(zita /h)**2 +(2.-a0)*(zita /h)**3
     zgzitah = 1.-a0*(zitah/h)-(3.-2.*a0)*(zitah/h)**2 +(2.-a0)*(zitah/h)**3
     zbzita  = b0 + (1.-b0)*(zita /h)
     zbzitah = b0 + (1.-b0)*(zitah/h)
     do j = 1,nlat_inp
       do i = 1,nlon_inp
         zeta_inp (i,j,k) = htop_inp(i,j)*zgzita  -h*zbzita *log(zfz)
         zetah_inp(i,j,k) = htop_inp(i,j)*zgzitah -h*zbzitah*log(zfzh)
       enddo
     enddo
   enddo

   if (.not.allocated(zeta_inp_save )) allocate (zeta_inp_save (nlon_inp,nlat_inp,nlev_inp))
   if (.not.allocated(zetah_inp_save)) allocate (zetah_inp_save(nlon_inp,nlat_inp,nlev_inp))
   zeta_inp_save(:,:,1:nlev_inp) = zeta_inp(:,:,1:nlev_inp)
   zetah_inp_save(:,:,1:nlev_inp) = zetah_inp(:,:,1:nlev_inp)

 else

   zeta_inp(:,:,1:nlev_inp) = zeta_inp_save(:,:,1:nlev_inp)
   zetah_inp(:,:,1:nlev_inp) = zetah_inp_save(:,:,1:nlev_inp)

 endif 

! Definition of surface pressure
 
 zbzita  = b0 + (1.-b0)*(.5*dz/h)
 zz1 = -g0*h*zbzita*log(1.-.5*dz/h)
 zgzita  = 1.-a0*(.5*dz/h)-(3.-2.*a0)*(.5*dz/h)**2 +(2.-a0)*(.5*dz/h)**3
 do j = 1, nlat_inp
   do i = 1, nlon_inp
     zdgz = htop_inp(i,j)*g0*(zgzita-1.) + zz1
     ztvirt = t_inp(i,j,1)*(1.+ep*q_inp(i,j,1)-qcw_inp(i,j,1)-qci_inp(i,j,1))
     ps_inp(i,j) = p_inp(i,j,1)*exp(zdgz/(rd*ztvirt))
   enddo
 enddo

return
end
!------------------------------------------------------------------------------
subroutine read_bolam_mhf_data(ifl,filename_atm,filename_soil,data_mode,ini_flag, &
    nlon_inp,nlat_inp,nlev_atm_inp,nlev_atm_inp_max,nlevg_inp,nlev_soil_inp_max, &
    x0_inp,y0_inp,alon0_inp,alat0_inp,dlon_inp,dlat_inp,idate,iperiod,lev_list_inp,soil_lev_inp,level_type, &
    npar3d,npar2d,npar3d_soil,field3d,field2d,field3d_soil,alev,blev,val_missing)

! Reads a BOLAM-type MHF

implicit none

! Input

integer :: ifl
character (len=80) :: filename_atm, filename_soil
integer :: data_mode ! 1 - united file, 2 - separated files
logical :: ini_flag

! Output

integer :: level_type, nlon_inp, nlat_inp, nlev_atm_inp, nlev_atm_inp_max, nlevg_inp, nlev_soil_inp_max, &
           idate(5), iperiod(3), npar3d, npar3d_soil, npar2d
real :: x0_inp, y0_inp, alon0_inp, alat0_inp, dlon_inp, dlat_inp, &
        lev_list_inp(nlev_atm_inp_max), soil_lev_inp(nlev_soil_inp_max), &
        alev(nlev_atm_inp_max+1), blev(nlev_atm_inp_max+1), val_missing
real, dimension(nlon_inp,nlat_inp,nlev_atm_inp_max,npar3d) :: field3d
real, dimension(nlon_inp,nlat_inp,npar2d) :: field2d
real, dimension(nlon_inp,nlat_inp,nlev_soil_inp_max,npar3d_soil) :: field3d_soil

! For reading

integer :: unit_atm = 21, unit_soil = 22, unit_const = 23
integer, dimension(50) :: nfdr, nfdr_soil
real, dimension(200)   :: pdr, pdr_soil
character (len=80) :: filename_const = "model_param_constant_inp.bin"
integer, parameter :: nlevsnow=11

! For working

integer :: ierr_open_atm=0, ierr_open_soil=0, ierr_open_const=0, ierr_read=0, &
 ipar2d, ipar3d, ipar3d_soil, jlon, jlat, jklev, jklev_soil, jklev_snow, ird, &
 ierr, nlon_const, nlat_const, nlevg_const, nst_inp, nvt_inp
real :: dlon_const, dlat_const, x0_const, y0_const, alon0_const, alat0_const
real, parameter :: g0=9.807
real, dimension(nlon_inp,nlat_inp) :: read2d_work

 if (data_mode==2) then
   open (unit_atm, file=trim(filename_atm), status='old', form='unformatted', iostat=ierr_open_atm)
   open (unit_soil, file=trim(filename_soil), status='old', form='unformatted', iostat=ierr_open_soil)
 else
   if (ifl == 0) then
     open (unit_atm, file=trim(filename_atm), status='old', form='unformatted', iostat=ierr_open_atm)
     open (unit_soil, file=trim(filename_soil), status='old', form='unformatted', iostat=ierr_open_soil)
   endif
 endif

 if (ierr_open_atm /= 0) then
   print *,"Error in opening of input file ", trim(filename_atm)
   stop
 endif

 if (ierr_open_soil /= 0) then
   print *,"Error in opening of input file ", trim(filename_soil)
   stop
 endif

 read(unit_soil, iostat=ierr_read) nfdr_soil
 read(unit_atm, iostat=ierr_read) nfdr
 if (ierr_read /= 0) then
   print *,"End of file encountered in reading input file ", trim(filename_atm)
   stop
 endif
 read(unit_atm) pdr
 read(unit_soil) pdr_soil

 if (ini_flag) then

   if (data_mode == 1) then
     rewind (unit_atm)
     rewind (unit_soil)
   else
     close (unit_atm)
     close (unit_soil)
   endif

   if (any(nfdr(:) /= nfdr_soil(:))) then
     print *,"Not concidence of nfdr parameters in ",trim(filename_atm)," and ",trim(filename_soil)," input files, stop"
     stop
   endif

   if (any(pdr(:) /= pdr_soil(:))) then
     print *,"Not concidence of pdr parameters in ",trim(filename_atm)," and ",trim(filename_soil)," input files, stop"
     stop
   endif

   level_type    = 2       ! hybrid or sigma levels
   nlon_inp      = nfdr(2)
   nlat_inp      = nfdr(3)
   nlev_atm_inp  = nfdr(4)
   nlevg_inp     = nfdr(15)
   x0_inp        = pdr(39)
   y0_inp        = pdr(38)
   dlon_inp      = pdr(2)
   dlat_inp      = pdr(1)
   alon0_inp     = pdr(5)
   alat0_inp     = pdr(4)
   alev(1)       = pdr(36)
   alev(2)       = pdr(37)
   blev(1:nlev_atm_inp) = pdr(39+1:39+nlev_atm_inp)

   do jklev = 1,nlev_atm_inp
     lev_list_inp(jklev)=float(jklev)
   enddo

   soil_lev_inp(1:nlevg_inp) = pdr(6:6+nlevg_inp-1)

   if (any(nfdr(5:9) /= nfdr_soil(5:9))) then
     print *,"Not coincidence of initial data read from ",trim(filename_atm)," and ",trim(filename_soil),":"
     print *,trim(filename_atm)," ",nfdr(5:9)
     print *,trim(filename_soil)," ",nfdr_soil(5:9)
     print *," stop"
     stop
   endif

   idate(1:5) = nfdr(5:9)

   print*
   print *,'Date (YYYY MM DD) and time (HH MM, analysis time) of the input fields:'
   print *,idate(1:3),'            ',idate(4:5)

   return

 endif

 if (ifl >= 1) then

! Reading of constant physiographical parameters of input model

   open (unit_const, file=trim(filename_const), status='old', form='unformatted', iostat=ierr_open_const)

   if (ierr_open_const /= 0) then
     print *,"Error in opening of input file ", trim(filename_const),", stop"
     stop
   endif

   read (unit_const) nlon_const, nlat_const, nlevg_const, dlon_const, dlat_const, &
 x0_const, y0_const, alon0_const, alat0_const, nst_inp, nvt_inp

   ierr=0
   if (nlon_inp /= nlon_const) ierr=ierr+1
   if (nlat_inp /= nlat_const) ierr=ierr+1
   if (nlevg_inp /= nlevg_const) ierr=ierr+1
   if (dlon_inp /= dlon_const) ierr=ierr+1
   if (dlat_inp /= dlat_const) ierr=ierr+1
   if (x0_inp /= x0_const) ierr=ierr+1
   if (y0_inp /= y0_const) ierr=ierr+1
   if (alon0_inp /= alon0_const) ierr=ierr+1
   if (alat0_inp /= alat0_const-dlat_const*0.5) ierr=ierr+1

   if (ierr /= 0) then
     write (*,*)
     write (*,*) "Error in header parameters in input file, ",trim(filename_const),", not coincident with parameters read from ",&
 trim(filename_atm)
     write (*,*) trim(filename_atm)," nlon, nlat, nlevg, dlon, dlat, x0, y0, alon0, alat0 :", &
 nlon_inp, nlat_inp, nlevg_inp, dlon_inp, dlat_inp, x0_inp, y0_inp, alon0_inp, alat0_inp
     write (*,*) trim(filename_const)," nlon, nlat, nlevg, dlon, dlat, x0, y0, alon0, alat0 :", &
 nlon_const, nlat_const, nlevg_const, dlon_const, dlat_const, x0_const, y0_const, alon0_const, alat0_const-dlat_const*0.5
     write (*,*) "  stop"
     stop
   endif

! Sea-land fraction

   ipar2d = 3        ! fmask
   call rrec2 (unit_const, nlon_inp, nlat_inp, field2d(1:nlon_inp,1:nlat_inp,ipar2d))

! Topography hight

   ipar2d = 2        ! Topography
   call rrec2 (unit_const, nlon_inp, nlat_inp, field2d(1:nlon_inp,1:nlat_inp,ipar2d))
   field2d(:,:,ipar2d) = field2d(:,:,ipar2d)*g0

   do ird = 1,1 ! Topography variation
     call rrec2 (unit_const, nlon_inp, nlat_inp, read2d_work(1:nlon_inp,1:nlat_inp))
   enddo

   do ird = 1,nst_inp+1 ! Soil types
     call rrec2 (unit_const, nlon_inp, nlat_inp, read2d_work(1:nlon_inp,1:nlat_inp))
   enddo

   do ird = 1,nvt_inp+1 ! Vegetation types
     call rrec2 (unit_const, nlon_inp, nlat_inp, read2d_work(1:nlon_inp,1:nlat_inp))
   enddo

   ipar3d_soil = 7     ! qgmax
   do jklev_soil = 1,nlevg_inp
     call rrec2 (unit_const, nlon_inp, nlat_inp, field3d_soil(1:nlon_inp,1:nlat_inp,jklev_soil,ipar3d_soil))
   enddo

   ipar3d_soil = 8     ! qgmin
   do jklev_soil = 1,nlevg_inp
     call rrec2 (unit_const, nlon_inp, nlat_inp, field3d_soil(1:nlon_inp,1:nlat_inp,jklev_soil,ipar3d_soil))
   enddo

   close (unit_const)

 endif ! ifl >= 1

 if (any(nfdr(10:12) /= nfdr_soil(10:12))) then
   print *,"Not coincidence of validity time read from ",trim(filename_atm)," and ",trim(filename_soil),":"
   print *,trim(filename_atm)," ",nfdr(10:12)
   print *,trim(filename_soil)," ",nfdr_soil(10:12)
   print *," stop"
   stop
 endif

 iperiod(1:3) = nfdr(10:12)

 print *,'Validity time if forecast (00 if analysis) (days, hours, minutes):'
 print *,iperiod(1:3)

! Atmospheric variables

 ipar2d = 4        ! Surface pressure
 call rrec2 (unit_atm, nlon_inp, nlat_inp, field2d(1:nlon_inp,1:nlat_inp,ipar2d))

 ipar3d = 3        ! u
 do jklev = 1,nlev_atm_inp
   call rrec2 (unit_atm, nlon_inp, nlat_inp, field3d(1:nlon_inp,1:nlat_inp,jklev,ipar3d))
 enddo

 ipar3d = 4        ! v
 do jklev = 1,nlev_atm_inp
   call rrec2 (unit_atm, nlon_inp, nlat_inp, field3d(1:nlon_inp,1:nlat_inp,jklev,ipar3d))
 enddo

 ipar3d = 2        ! t
 do jklev = 1,nlev_atm_inp
   call rrec2 (unit_atm, nlon_inp, nlat_inp, field3d(1:nlon_inp,1:nlat_inp,jklev,ipar3d))
 enddo

 ipar3d = 5        ! q
 do jklev = 1,nlev_atm_inp
   call rrec2 (unit_atm, nlon_inp, nlat_inp, field3d(1:nlon_inp,1:nlat_inp,jklev,ipar3d))
 enddo

 ipar3d = 7        ! qc
 do jklev = 1,nlev_atm_inp
   call rrec2 (unit_atm, nlon_inp, nlat_inp, field3d(1:nlon_inp,1:nlat_inp,jklev,ipar3d))
 enddo

! Physiographical parameters changing in time

 do ird = 1,4 ! Vegetation LAI, Vegetation fraction, RGM, RGQ
   call rrec2 (unit_soil, nlon_inp, nlat_inp, read2d_work(1:nlon_inp,1:nlat_inp))
 enddo

 ipar2d = 22       ! Sea ice fraction
 call rrec2 (unit_soil, nlon_inp, nlat_inp, field2d(1:nlon_inp,1:nlat_inp,ipar2d))

 ipar2d = 26       ! Sea ice thickness (m)
 call rrec2 (unit_soil, nlon_inp, nlat_inp, field2d(1:nlon_inp,1:nlat_inp,ipar2d))

! Surface, soil, sea variables

 do ird = 1,7 ! Albedo, 2 emisivities, Tot. cloudness, Tot. prec., Conv. prec., Snow prec.
   call rrec2 (unit_soil, nlon_inp, nlat_inp, read2d_work(1:nlon_inp,1:nlat_inp))
 enddo

 ipar2d = 5        ! tsurf
 call rrec2 (unit_soil, nlon_inp, nlat_inp, field2d(1:nlon_inp,1:nlat_inp,ipar2d))

 do ird = 1,1 ! tg surface
   call rrec2 (unit_soil, nlon_inp, nlat_inp, read2d_work(1:nlon_inp,1:nlat_inp))
 enddo

 ipar3d_soil = 1   ! tg
 do jklev = 1,nlevg_inp
   call rrec2 (unit_soil, nlon_inp, nlat_inp, field3d_soil(1:nlon_inp,1:nlat_inp,jklev,ipar3d_soil))
 enddo

 ipar2d = 25       ! qvsurf
 call rrec2 (unit_soil, nlon_inp, nlat_inp, field2d(1:nlon_inp,1:nlat_inp,ipar2d))

 do ird = 1,1 ! qg surface
   call rrec2 (unit_soil, nlon_inp, nlat_inp, read2d_work(1:nlon_inp,1:nlat_inp))
 enddo

 ipar3d_soil = 2   ! qg
 do jklev = 1,nlevg_inp
   call rrec2 (unit_soil, nlon_inp, nlat_inp, field3d_soil(1:nlon_inp,1:nlat_inp,jklev,ipar3d_soil))
 enddo

 do ird = 1,nlevg_inp+1 ! Soil ice fraction at surface and at soil levels
   call rrec2 (unit_soil, nlon_inp, nlat_inp, read2d_work(1:nlon_inp,1:nlat_inp))
 enddo

 ipar2d = 14       ! snow
 call rrec2 (unit_soil, nlon_inp, nlat_inp, field2d(1:nlon_inp,1:nlat_inp,ipar2d))

 do ird = 1,6 ! Snow mass, temperature, ice fraction, age, melting age, density at snow levels
   do jklev_snow = 1,nlevsnow
     call rrec2 (unit_soil, nlon_inp, nlat_inp, read2d_work(1:nlon_inp,1:nlat_inp))
   enddo
 enddo

 do ird = 1, 12   ! Snow albedo, CSWFl, CLWFl, CHFlux, CQFlux, T2Min, T2Max, Runoff, Runoff total, 3 empty
   call rrec2 (unit_soil, nlon_inp, nlat_inp, read2d_work(1:nlon_inp,1:nlat_inp))
 enddo

 if (data_mode == 2) then
   close (unit_atm)
   close (unit_soil)
 endif

return
end
!------------------------------------------------------------------------------
subroutine conv_moloch_data

! Procedure to convert meteorological fields derived from input files of MHF-MOLOCH type
!------------------------------------------------------------------------
! Procedure requests in input following parameters:
! nlevg_inp  - soil levels number in input data;
! nlon_inp  - grid point number of input data along x-axis;
! nlat_inp  - grid point number of input data along y-axis;
! dlon_inp  - grid step of input data along x-axis;
! dlat_inp  - grid step of input data along y-axis;
! alon_inp  - 2d array with geographical longitude of inpunt data grid points; 
! alat_inp  - 2d array with geographical latitude of inpunt data grid points; 
! fmask_inp - 2d array with sea-land fraction (1-sea, 0-land) of input data;
! qg_inp - 3d array with specipic volumetric soil water content (m^3/m^3) at soil levels of input data.
! qgmax_inp - 3d array with maximal specipic volumetric soil water content (m^3/m^3) at soil levels of input data.
! qgmin_inp - 3d array with minimal specipic volumetric soil water content (m^3/m^3) at soil levels of input data.
!
! Following parameters must be defined in output of this procedure:
! qg_inp - 3d array with relative soil water content (proportion) at soil levels of input data.
! 
!------------------------------------------------------------------------

use parameters, only : surf_elaborate
use input_data, alon_inp=>alon_t_inp, alat_inp=>alat_t_inp

implicit none

integer :: i, j

 if (surf_elaborate) then

   do j = 1,nlat_inp
   do i = 1,nlon_inp0

! Redefinition of soil water content in relative terms, using input
! data of specific soil water content and its maximum and minimum values
! (that depend on soil type in input data)

    if (fmask_inp(i,j) < 0.5) then
       qg_inp(i,j,1:nlevg_inp) = min(max((qg_inp(i,j,1:nlevg_inp)-qgmin_inp(i,j,1:nlevg_inp)) &
 /(qgmax_inp(i,j,1:nlevg_inp)-qgmin_inp(i,j,1:nlevg_inp)), 0.), 1.)
      else
       qg_inp(i,j,1:nlevg_inp) = 0.
     endif

! Redefinition of qg over input model sea to a value that defines
! a reasonable deep soil moisture for small islands appearing in open seas

     if (fmask_inp(i,j) >= 0.5.and.qg_inp(i,j,1) < 0.01) qg_inp(i,j,1:nlevg_inp) = 0.50

   enddo
   enddo

   if (nlon_inp0 /= nlon_inp) then
     qg_inp(nlon_inp,:,:) = qg_inp(1,:,:)
   endif

 endif ! surf_elaborate

return
end
!------------------------------------------------------------------------------
subroutine conv_bolam_data(ist)

! Procedure to convert meteorological fields derived from input files of MHF-BOLAM type
! from BOLAM or GLOBO models data
!------------------------------------------------------------------------
! Procedure requests in input following parameters:
! nlev_inp  - atmospheric levels number in input data;
! nlevg_inp  - soil levels number in input data;
! nlon_inp  - grid point number of input data along x-axis;
! nlat_inp  - grid point number of input data along y-axis;
! lev_list_inp - 1d array with atmospheric level list of input data;
! soil_lev_inp - 1d array with soil level list of input data;
! field3d - 4d array with parameters at atmosphereic level;
! field3d_soil - 4d array with parameters at soil level;
! field2d - 3d array with parameters at the surface.
!
! Following parameters must be defined in output of this procedure:
! frame - logical flag: .false. - no frame in input data, .true. - frame in input data
! mask_frame - 2d ingeter array with flag of input data presence in a grid point,
! if no frame, then all values of mask_frame equal 1
! fmask_inp - 2d array with sea-land fraction (1-sea, 0-land);
! ps_inp - 2d array with surface pressure (Pa) of input data;
! htop_inp - 2d array with topography hight (m) of input data;
! zeta_inp - 3d array with geometric altitude (m, over sea surface) of atmospheric levels of input data;
! t_inp - 3d array with temperature (K) at atmospheric levels of input data;
! u_inp - 3d array with u-component of wind (m/s) at atmospheric levels of input data;
! v_inp - 3d array with v-component of wind (m/s) at atmospheric levels of input data;
! q_inp - 3d array with specific humidity (kg/kg) at atmospheric levels of input data;
! qcw_inp - 3d array with specific cloud liquid water content (kg/kg) at atmospheric levels of input data;
! qci_inp - 3d array with specific cloud ice water content (kg/kg) at atmospheric levels of input data;
! tvirt_inp - 3d array with virtual temperature (K) at atmospheric levels of input data;
! w_inp - 3d array with vertical velocity (m/s) at atmospheric levels of input data;
! tg_inp - 3d array with temperature (m/s) at soil levels of input data;
! qg_inp - 3d array with relative soil water content (proportion) at soil levels of input data;
! qgmax_inp - 3d array with maximum specific volumetric soil water content (m^3/m^3) at soil levels of input data;
! qgmin_inp - 3d array with minimum specific volumetric soil water content (m^3/m^3) at soil levels of input data;
! snow_inp - 2d array with total water content of surface snow cover (kg/m^2);
! tsurf_inp - 2d array with surface temperature (K);
! qvsurf_inp - 2d array with specipic humidity (kg/kg) at the surface;
! fice_inp - 2d array with fraction of sea ice cover (proportion) at the surface;
! iceth_inp - 2d array with thickness of sea ice cover (m) at the surface.
! 
!------------------------------------------------------------------------

use parameters, only : pzer, ep, g0, pi, a, rd, nst, surf_elaborate, val_missing, inst_start
use input_data

implicit none

integer :: ist, i, ip1, j, jm1, k, k1
real, allocatable, dimension(:), save :: sig_inp, sigint_inp, dsig, hxv, hxt
real, save :: alfa_inp, dx, dy
real, allocatable, dimension(:), save :: zpbx, zpby, zpbyn
real, allocatable, dimension(:,:), save :: zdiv, zom1, pstend, zdvint
real, allocatable, dimension(:,:,:), save :: zdi1, zdi2

integer, parameter :: nst_inp=15, nvt_inp=14, nsvvar_inp=50

real :: zsigmed, zsigalf, zdsigalf, &
 zp, zqs, zqsw, zqsi, zzz1, zzz2, zzz3, fracw, zwater, zc1, &
 zrdx, zhxvt, zhxvtn, zomeg, zro

 mask_frame(:,:) = 1
 frame = .false.

! Definition of meteorological fields declared in main program
! LIST TO BE CHECKED ! see subroutine read_grib2_data

 do k=1,nlev_inp
   k1=nlev_inp-k+1
   t_inp (1:nlon_inp0,:,k) = field3d(1:nlon_inp0,:,k1,2)
   u_inp (1:nlon_inp0,:,k) = field3d(1:nlon_inp0,:,k1,3)
   v_inp (1:nlon_inp0,:,k) = field3d(1:nlon_inp0,:,k1,4)
   q_inp (1:nlon_inp0,:,k) = field3d(1:nlon_inp0,:,k1,5)
   qc_inp(1:nlon_inp0,:,k) = field3d(1:nlon_inp0,:,k1,7)
 enddo

 if (nlon_inp0 /= nlon_inp) then
   t_inp(nlon_inp,:,:) = t_inp(1,:,:)
   u_inp(nlon_inp,:,:) = u_inp(1,:,:)
   v_inp(nlon_inp,:,:) = v_inp(1,:,:)
   q_inp(nlon_inp,:,:) = q_inp(1,:,:)
   qc_inp(nlon_inp,:,:) = qc_inp(1,:,:)
 endif

 q_inp(:,:,:)  = max(q_inp(:,:,:), 0.)
 qc_inp(:,:,:) = max(qc_inp(:,:,:), 0.)

 ps_inp(1:nlon_inp0,:)    = field2d(1:nlon_inp0,:,4)

! htop_inp_2(1:nlon_inp0,:) = field2d(1:nlon_inp0,:,2)/g0
 htop_inp(1:nlon_inp0,:)   = field2d(1:nlon_inp0,:,2)/g0
 fmask_inp(1:nlon_inp0,:)  = field2d(1:nlon_inp0,:,3) ! 1-sea, 0-land

 if (nlon_inp0 /= nlon_inp) then
   ps_inp(nlon_inp,:) = ps_inp(1,:)
   htop_inp(nlon_inp,:) = htop_inp(1,:)
!   htop_inp_2(nlon_inp,:) = htop_inp_2(1,:)
   fmask_inp(nlon_inp,:) = fmask_inp(1,:)
 endif

 if (ist == inst_start) then

   if (level_type == 1) then
     print *, 'Input data on isobaric levels with the following values:'
     do k=1,nlev_inp
       k1=nlev_inp-k+1
       print '(i3,a2,f5.0,a4)',k,'  ',lev_list_inp(k1)*0.01,'e+02'
     enddo
     print *
   else
     print *,'Input data on hybrid levels:'
     print*, "actual levels available (left col.) and GLOBO/BOLAM level index (right col.)"
     do k=1,nlev_inp
       k1=nlev_inp-k+1
       print '(i3,a,i3)',k,'   ',int(lev_list_inp(k1))
     enddo
     print*
   endif

   allocate (sig_inp(nlev_inp))
   allocate (sigint_inp(nlev_inp))
   allocate (dsig(nlev_inp))
   allocate (hxv(nlat_inp))
   allocate (hxt(nlat_inp))
   allocate (zpbx(nlon_inp))
   allocate (zpby(nlon_inp))
   allocate (zpbyn(nlon_inp))
   allocate (zdi1(nlon_inp,nlat_inp,nlev_inp))
   allocate (zdi2(nlon_inp,nlat_inp,nlev_inp))
   allocate (zdiv(nlon_inp,nlev_inp))
   allocate (zom1(nlon_inp,nlev_inp))
   allocate (pstend(nlon_inp,nlat_inp))
   allocate (zdvint(nlon_inp,nlev_inp))

   alfa_inp=ak(2)
   dx=a*dlon_inp*pi/180.
   dy=a*dlat_inp*pi/180.

   do k = 1,nlev_inp
     k1=nlev_inp-k+1
     sig_inp(k1)=bk(k)
   enddo
   sigint_inp(nlev_inp)=sig_inp(nlev_inp)*0.5
   dsig(nlev_inp)=sig_inp(nlev_inp)
   do k=nlev_inp-1,1,-1
     sigint_inp(k)=(sig_inp(k)+sig_inp(k+1))*0.5
     dsig(k)=sig_inp(k)-sig_inp(k+1)
   enddo

   do j=1,nlat_inp
     hxv(j)=cos((alat0_inp+(j-1)*dlat_inp)*pi/180.)
     hxt(j)=cos((alat0_inp+(j-1)*dlat_inp+dlat_inp*0.5)*pi/180.)
   enddo

 endif ! ist == ist_start

! Definition of virtual temperature, specific humidity,
! cloud liquid water and ice content,
! and geometric altitude (zeta)

 do k = 1,nlev_inp
   zsigalf=sigint_inp(k)**3*(1.+alfa_inp*(1.-sigint_inp(k))*(2.-sigint_inp(k)))
   do j=1,nlat_inp
   do i=1,nlon_inp
     zp=pzer*sigint_inp(k)-(pzer-ps_inp(i,j))*zsigalf
     call qsat_entropy(t_inp(i,j,k),zp,zqs,zqsw,zqsi,zzz1,zzz2,zzz3,fracw)
     zwater=max(qc_inp(i,j,k), 0.)
     qcw_inp(i,j,k)=zwater*fracw
     qci_inp(i,j,k)=zwater*(1.-fracw)
     tvirt_inp(i,j,k)=t_inp(i,j,k)*(1.+ep*q_inp(i,j,k)-zwater)
   enddo
   enddo
 enddo

 zsigmed  = 0.5*(1.+sigint_inp(1))
 zsigalf  = zsigmed**3*(1.+alfa_inp*(1.-zsigmed)*(2.-zsigmed))
 zdsigalf = zsigmed**2*(3.+alfa_inp*(6.-12.*zsigmed+5.*zsigmed**2))
 do j=1,nlat_inp
 do i=1,nlon_inp
   zc1 = (pzer-(pzer-ps_inp(i,j))*zdsigalf)/(pzer*zsigmed-(pzer-ps_inp(i,j))*zsigalf)
   zeta_inp(i,j,1) = htop_inp(i,j)*g0 + rd*(1.-sigint_inp(1))*zc1*tvirt_inp(i,j,1)
 enddo
 enddo

 do k = 2,nlev_inp
   zsigmed  = 0.5*(sigint_inp(k-1)+sigint_inp(k))
   zsigalf  = zsigmed**3*(1.+alfa_inp*(1.-zsigmed)*(2.-zsigmed))
   zdsigalf = zsigmed**2*(3.+alfa_inp*(6.-12.*zsigmed+5.*zsigmed**2))
   do j=1,nlat_inp
   do i=1,nlon_inp
     zc1 = (pzer-(pzer-ps_inp(i,j))*zdsigalf)/(pzer*zsigmed-(pzer-ps_inp(i,j))*zsigalf)
     zeta_inp(i,j,k) = zeta_inp(i,j,k-1) + .5*rd*zc1*(sigint_inp(k-1)-sigint_inp(k))* &
 (tvirt_inp(i,j,k)+tvirt_inp(i,j,k-1))
   enddo
   enddo
 enddo

 zeta_inp(:,:,:) = zeta_inp(:,:,:)/g0

! Definition of vertical velocity W (m/s)
! computing omega on T-points (omega is not defined on western and northern boundaries)

 do j = 1,nlat_inp-1 
   jm1=max(j-1,1)
   zrdx   = 1.      /(hxt(j)*dx)
   zhxvt  = hxv(j  )/(hxt(j)*dy)
   zhxvtn = hxv(j+1)/(hxt(j)*dy)
   do i = 1,nlon_inp
     ip1=min(i+1,nlon_inp)
     zpbx (i) = .5*zrdx  *(ps_inp(i,j  )+ps_inp(ip1,j  ))
     zpby (i) = .5*zhxvt *(ps_inp(i,j  )+ps_inp(i  ,jm1))
     zpbyn(i) = .5*zhxvtn*(ps_inp(i,j+1)+ps_inp(i  ,j  ))
   enddo
   do k = nlev_inp, 1, -1
     do i = 2, nlon_inp
       zdi1(i,j,k) = (u_inp(i,j,k)-u_inp(i-1,j,k))* &
              zrdx+zhxvtn*v_inp(i,j+1,k)-zhxvt*v_inp(i,j,k)
       zdi2(i,j,k) = u_inp(i,j,k)*zpbx(i)-u_inp(i-1,j,k)*zpbx(i-1) &
              + v_inp(i,j+1,k)*zpbyn(i)-v_inp(i,j,k)*zpby(i)
     enddo
   enddo
 enddo

! Definition of surface pressure tendency of (-) integral from top to
! a given half-level of horizontal divergence (zdvint)

 pstend(:,:)=0.
 do j = 1,nlat_inp-1 

   do k = nlev_inp, 1, -1
     zdsigalf = sigint_inp(k)**2*(3.+alfa_inp*(6.-12.*sigint_inp(k)+5.*sigint_inp(k)**2))
     do i = 2, nlon_inp
       zdiv(i,k) = pzer*(1.-zdsigalf)*zdi1(i,j,k) + zdsigalf*zdi2(i,j,k)
       zom1(i,k) = zdi2(i,j,k)-ps_inp(i,j)*zdi1(i,j,k)
       pstend(i,j)=pstend(i,j)-zdiv(i,k)*dsig(k)
       zdvint(i,k)=pstend(i,j)
     enddo
   enddo

!  Omega at T-points and integer levels

   do k = nlev_inp, 1, -1
     zsigalf = sigint_inp(k)**3*(1.+alfa_inp*(1.-sigint_inp(k))*(2.-sigint_inp(k)))
     do i = 2, nlon_inp
       zomeg = zsigalf*zom1(i,k) + zdvint(i,k) + zdiv(i,k)*(sig_inp(k)-sigint_inp(k))
       zp = pzer*sigint_inp(k)-(pzer-ps_inp(i,j))*zsigalf
       zro = zp/(rd*tvirt_inp(i,j,k))
       w_inp(i,j,k) = -zomeg/(zro*g0)
     enddo
   enddo

 enddo

 do k=1,nlev_inp
   do i=2,nlon_inp
     w_inp(i,nlat_inp,k)=w_inp(i,nlat_inp-1,k)
   enddo
   do j=1,nlat_inp
     w_inp(1,j,k)=w_inp(2,j,k)
   enddo
 enddo

 if (surf_elaborate) then

   snow_inp(1:nlon_inp0,:)   = field2d(1:nlon_inp0,:,14)
   tsurf_inp(1:nlon_inp0,:)  = field2d(1:nlon_inp0,:,5)
   qvsurf_inp(1:nlon_inp0,:)  = field2d(1:nlon_inp0,:,25)
   fice_inp(1:nlon_inp0,:)  = min(max( field2d(1:nlon_inp0,:,22), 0.), 1.)
   iceth_inp(1:nlon_inp0,:) = max(field2d(1:nlon_inp0,:,26), 0.)

   tg_inp(1:nlon_inp0,:,1:nlevg_inp) = field3d_soil(1:nlon_inp0,:,1:nlevg_inp,1)
   qg_inp(1:nlon_inp0,:,1:nlevg_inp) = field3d_soil(1:nlon_inp0,:,1:nlevg_inp,2)

   qgmax_inp(1:nlon_inp0,:,1:nlevg_inp) = field3d_soil(1:nlon_inp0,:,1:nlevg_inp,7)
   qgmin_inp(1:nlon_inp0,:,1:nlevg_inp) = field3d_soil(1:nlon_inp0,:,1:nlevg_inp,8)

   if (nlon_inp0 /= nlon_inp) then
     snow_inp(nlon_inp,:) = snow_inp(1,:)
     tsurf_inp(nlon_inp,:) = tsurf_inp(1,:)
     qvsurf_inp(nlon_inp,:) = qvsurf_inp(1,:)
     fice_inp(nlon_inp,:) = fice_inp(1,:)
     iceth_inp(nlon_inp,:) = iceth_inp(1,:)
     tg_inp(nlon_inp,:,:) = tg_inp(1,:,:)
     qg_inp(nlon_inp,:,:) = qg_inp(1,:,:)
     qgmax_inp(nlon_inp,:,:) = qgmax_inp(1,:,:)
     qgmin_inp(nlon_inp,:,:) = qgmin_inp(1,:,:)
   endif

   do j = 1,nlat_inp
   do i = 1,nlon_inp

! In GLOBO or BOLAM in water body and glaciers qg is 1., not 0.

     if (qg_inp(i,j,1) > 0.99) qg_inp(i,j,1:nlevg_inp)=0.

! Redefinition of soil water content in relative terms, using input
! data of specific soil water content and its maximum and minimum values
! (that depend on soil type in input data)

    if (fmask_inp(i,j) < 0.5) then
       qg_inp(i,j,1:nlevg_inp) = min(max((qg_inp(i,j,1:nlevg_inp)-qgmin_inp(i,j,1:nlevg_inp)) &
 /(qgmax_inp(i,j,1:nlevg_inp)-qgmin_inp(i,j,1:nlevg_inp)), 0.), 1.)
      else
       qg_inp(i,j,1:nlevg_inp) = 0.
     endif

! Redefinition of qg over input model sea to a value that defines
! a reasonable deep soil moisture for small islands appearing in open seas

     if (fmask_inp(i,j) >= 0.5.and.qg_inp(i,j,1) < 0.01) qg_inp(i,j,1:nlevg_inp) = 0.50

   enddo
   enddo

 endif ! surf_elaborate

return
end
!------------------------------------------------------------------------------
subroutine conv_ifs_data(ist)

! Procedure to convert meteorological fields derived from input files of IFS-ECMWF
!------------------------------------------------------------------------
! Procedure requests in input following parameters:
! nlev_inp  - atmospheric levels number in input data;
! nlevg_inp  - soil levels number in input data;
! nlon_inp  - grid point number of input data along x-axis;
! nlat_inp  - grid point number of input data along y-axis;
! lev_list_inp - 1d array with atmospheric level list of input data;
! soil_lev_inp - 1d array with soil level list of input data;
! field3d - 4d array with parameters at atmosphereic level;
! field3d_soil - 4d array with parameters at soil level;
! field2d - 3d array with parameters at the surface.
! idate0_inp - 1d array with date, time of simulation start or analysis
!
! Following parameters must be defined in output of this procedure:
! frame - logical flag: .false. - no frame in input data, .true. - frame in input data
! mask_frame - 2d ingeter array with flag of input data presence in a grid point,
! if no frame, then all values of mask_frame equal 1
! iperiod_inp - 1d array with simulation term
! fmask_inp - 2d array with sea-land fraction (1-sea, 0-land);
! ps_inp - 2d array with surface pressure (Pa) of input data;
! htop_inp - 2d array with topography hight (m) of input data;
! htop_atm_inp - only in the case of hybrid model atmospheric levels in input data: 
! 2d array with topography hight at the lowest atmospperic level (m) of input data;
! zeta_inp - 3d array with geometric altitude (m, over sea surface) of atmospheric levels of input data;
! t_inp - 3d array with temperature (K) at atmospheric levels of input data;
! u_inp - 3d array with u-component of wind (m/s) at atmospheric levels of input data;
! v_inp - 3d array with v-component of wind (m/s) at atmospheric levels of input data;
! q_inp - 3d array with specific humidity (kg/kg) at atmospheric levels of input data;
! qcw_inp - 3d array with specific cloud liquid water content (kg/kg) at atmospheric levels of input data;
! qci_inp - 3d array with specific cloud ice water content (kg/kg) at atmospheric levels of input data;
! tvirt_inp - 3d array with virtual temperature (K) at atmospheric levels of input data;
! w_inp - 3d array with vertical velocity (m/s) at atmospheric levels of input data;
! tg_inp - 3d array with temperature (m/s) at soil levels of input data;
! qg_inp - 3d array with relative soil water content (proportion) at soil levels of input data;
! snow_inp - 2d array with total water content of surface snow cover (kg/m^2);
! tsurf_inp - 2d array with surface temperature (K);
! qvsurf_inp - 2d array with specific humidity (kg/kg) at the surface;
! fice_inp - 2d array with fraction of sea ice cover (proportion) at the surface;
! iceth_inp - 2d array with thickness of sea ice cover (m) at the surface.
! 
!------------------------------------------------------------------------

use parameters, only : g0, eps, ep, rd, surf_elaborate, val_missing, inst_start
use input_data, alon_inp=>alon_t_inp, alat_inp=>alat_t_inp

implicit none

integer, save :: nlon_inp_old, nlat_inp_old, nlev_all_inp
real, dimension(:), allocatable :: p_level_inp, ph_all_level_inp, pl_all_level_inp
real, dimension(:,:,:), allocatable :: p_inp_local
integer, dimension(:), allocatable :: h_level_inp
real, dimension(:,:), allocatable :: soil_type_inp, work_inp
real, dimension(:,:), allocatable, save :: soil_type_inp_save

integer, parameter :: nst_inp=7, nst_inp2=1
real, dimension(nst_inp) :: qgmax_inp_work=(/0.403, 0.439, 0.430, 0.520, 0.614, 0.766, 0.590/), &
 qgmin_inp_work=(/0., 0., 0., 0., 0., 0., 0./)
real, dimension(nst_inp2) :: qgmax_inp_work2=(/0.472/), qgmin_inp_work2=(/0./)

integer :: ist, i, j, k, k1, ind_field, iflag_cl, iflag_clw, iflag_cli, iflag, iday, nsmooth
real :: zqcmin=1.e-7, qsat, qsatw, qsati, esat, esatw, esati, eee, fracw, zzz, wei

 mask_frame(:,:) = 1
 frame = .false.

! Control of grid resolution changing

 res_change = 0
 if(ist > inst_start .and.(nlon_inp /= nlon_inp_old.or.nlat_inp /= nlat_inp_old)) then
   print*
   print*, "The IFS grid resolution has changed at instant: ist =", ist
   print*
   print*
   res_change = 1
 endif
 nlon_inp_old = nlon_inp
 nlat_inp_old = nlat_inp

 if (iperiod_inp_grib2(1)==1) then         ! Time unit is hour
   iperiod_inp(1) = iperiod_inp_grib2(2)/24                                     ! Days
   iperiod_inp(2) = iperiod_inp_grib2(2)-iperiod_inp(1)*24                      ! Hours
   iperiod_inp(3) = 0                                                           ! Minutes
 elseif (iperiod_inp_grib2(1)==0) then     ! Time unit is minute
   iperiod_inp(1) = iperiod_inp_grib2(2)/24/60                                  ! Days
   iperiod_inp(2) = (iperiod_inp_grib2(2)-iperiod_inp(1)*24*60)/60              ! Hours
   iperiod_inp(3) = iperiod_inp_grib2(2)-iperiod_inp(1)*24*60-iperiod_inp(2)*60 ! Minutes
 endif

! Allocation of internal work arrays

 allocate (p_level_inp(nlev_atm_inp_max))
 allocate (ph_all_level_inp(nlev_atm_inp_max+1))
 allocate (pl_all_level_inp(nlev_atm_inp_max))
 allocate (h_level_inp(nlev_atm_inp_max))
 allocate (p_inp_local(nlon_inp,nlat_inp,nlev_atm_inp_max))
 allocate (soil_type_inp(nlon_inp,nlat_inp))
 allocate (work_inp(nlon_inp,nlat_inp))

! Atmospheric level definition

 if (level_type == 1) then ! Isobaric levels

   do k=1,nlev_inp
     k1=nlev_inp-k+1
     p_level_inp(k)  = lev_list_inp(k1)
   enddo

 else ! Hybrid levels

   do k=1,nlev_inp
     k1=nlev_inp-k+1
     h_level_inp(k)  = int(lev_list_inp(k1))
   enddo

! Definition of hynbrid level number in input model

   if (ist == inst_start) then 
     do k = 1, nlev_atm_inp_max+1
       if (ak(k) < 1.e-4.and.abs(bk(k)-1) < 1.e-4) then
         nlev_all_inp=k-1
         exit
       endif
     enddo
   endif

 endif

 if (ist == inst_start) then
   print*
   if (level_type == 1) then ! Isobaric levels
    write(*,'(a,i3)') " Number of isobaric levels in input data ", nlev_inp
    print *,'Input data are availables at the following isobaric levels (hPa):'
    do k = 1,nlev_inp
      print '(i4,a6,f5.0,a2)',k,'   p =',p_level_inp(k)*0.01,'e2'
    enddo
   else ! Hybrid levels
    write(*,'(a,i3)') " Number of hybrid levels in input data ", nlev_inp
    print*, "Index of levels available (left col.) and IFS hybrid level index (right col.)"
    do k = 1,nlev_inp
      print '(a,i3,a,i3)', '   ',k,'   ',h_level_inp(k)
    enddo
   endif
   print*
 endif

! For the case in which input data are defined only on frames:

 if (ist > inst_start) then
   print *
   ind_field = 2 ! Temperature at atm. levels in input data
   k = nlev_inp
   if (any(int(field3d(:,:,k,ind_field)) == int(val_missing))) then
     frame = .true.
     print *,'Input data fields defined only on frames'
     do j = 1,nlat_inp
     do i = 1,nlon_inp
       if (int(field3d(i,j,k,ind_field)) == int(val_missing)) then
         mask_frame(i,j) = 0
         field3d(i,j,:,:) = field3d(1,1,:,:)
         field3d_soil(i,j,:,:) = field3d_soil(1,1,:,:)
         field2d(i,j,:) = field2d(1,1,:)
       endif
     enddo
     enddo
   else
     print *,'Input data fields defined on full area (not on frames only)'
   endif
 endif

! Definition of meteorological fields declared in main program
! LIST TO BE CHECKED ! see subroutine read_grib2_data

 if (level_type == 1) then ! Isobaric levels
   do k=1,nlev_inp
     k1=nlev_inp-k+1
! Geopotential
     if (any(int(field3d(:,:,k,1)) == int(val_missing)) ) then
       print *,'No geopotential data in input at level ',p_level_inp(k)*0.01,'e2, stop'
       stop
     else
       zeta_inp(1:nlon_inp0,:,k) = field3d(1:nlon_inp0,:,k1,1)/g0
     endif
   enddo
   if (nlon_inp0 /= nlon_inp) then
     zeta_inp(nlon_inp,:,:) = zeta_inp(1,:,:)
   endif
 else ! Hybrid levels
! Logarithm of surface pressure
   if (any(int(field2d(:,:,4)) == int(val_missing)) ) then
     print *,'No surface pressure logarithm data in input, stop'
     stop
   else
     psl_inp(1:nlon_inp0,:) = field2d(1:nlon_inp0,:,4)
     if (nlon_inp0 /= nlon_inp) then
       psl_inp(nlon_inp,:) = psl_inp(1,:)
     endif
   endif
 endif

 do k=1,nlev_inp
   k1=nlev_inp-k+1
! Temperature
   if (any(int(field3d(:,:,k,2)) == int(val_missing)) ) then
     if (level_type == 1) then
       print *,'No temperature data in input at level ',p_level_inp(k)*0.01,'e2, stop'
     else
       print *,'No temperature data in input at level ',h_level_inp(k),', stop'
     endif
     stop
   else
     t_inp(1:nlon_inp0,:,k) = field3d(1:nlon_inp0,:,k1,2)
   endif
! U-component of wind
   if (any(int(field3d(:,:,k,3)) == int(val_missing)) ) then
     if (level_type == 1) then
       print *,'No data of U-component of wind in input at level ',p_level_inp(k)*0.01,'e2, stop'
     else
       print *,'No data of U-component of wind in input at level ',h_level_inp(k),', stop'
     endif
     stop
   else
     u_inp(1:nlon_inp0,:,k) = field3d(1:nlon_inp0,:,k1,3)
   endif
! V-component of wind
   if (any(int(field3d(:,:,k,4)) == int(val_missing)) ) then
     if (level_type == 1) then
       print *,'No data of V-component of wind in input at level ',p_level_inp(k)*0.01,'e2, stop'
     else
       print *,'No data of V-component of wind in input at level ',h_level_inp(k),', stop'
     endif
     stop
   else
     v_inp(1:nlon_inp0,:,k) = field3d(1:nlon_inp0,:,k1,4)
   endif
! Specific Hhumidity
   if (any(int(field3d(:,:,k,5)) == int(val_missing)) ) then
     if (level_type == 1) then
       print *,'No specific humidity data in input at level ',p_level_inp(k)*0.01,'e2, stop'
     else
       print *,'No specific humidity data in input at level ',h_level_inp(k),', stop'
     endif
     stop
   else
     q_inp(1:nlon_inp0,:,k) = field3d(1:nlon_inp0,:,k1,5)
   endif

   if (nlon_inp0 /= nlon_inp) then
     t_inp(nlon_inp,:,:) = t_inp(1,:,:)
     u_inp(nlon_inp,:,:) = u_inp(1,:,:)
     v_inp(nlon_inp,:,:) = v_inp(1,:,:)
     q_inp(nlon_inp,:,:) = q_inp(1,:,:)
   endif

 enddo

! Definition of pressure at input atmospheric level

 if (level_type == 2) then ! Hybrid levels

   do j = 1,nlat_inp
     do i = 1,nlon_inp

! Computation of p on half levels, with the expression:
! p(k+1/2) = a(k+1/2) + b(k+1/2)*ps

       do k = 1, nlev_all_inp+1
         ph_all_level_inp(k) = ak(k) + bk(k)*exp(psl_inp(i,j))
       enddo

! Definition of ln(p) on full levels, with the expression:
! p(k) = 0.5*(p(k+1/2) + p(k-1/2))

       do k = 1, nlev_all_inp
         pl_all_level_inp(k) = alog(0.5*(ph_all_level_inp(k) + ph_all_level_inp(k+1)))
       enddo

! Definition of p on availaible full levels

       do k = 1,nlev_inp
         k1 = h_level_inp(k)
           p_inp_local(i,j,k)=exp(pl_all_level_inp(k1))
       enddo

     enddo
   enddo

 else ! Isobaric level

   do j = 1,nlat_inp
     do i = 1,nlon_inp
       p_inp_local(i,j,1:nlev_inp) = p_level_inp(1:nlev_inp)
     enddo
   enddo

 endif

! Cloud water content

! Note that in the following the last index denotes:
! 7: total cloud water content (sum of water and ice - parameter normally not available from IFS-ECMWF);
! 8: cloud liquid water; 9: cloud ice.

 qc_inp(:,:,:) = 0.
 qcw_inp(:,:,:) = 0.
 qci_inp(:,:,:) = 0.

! Check availability of total cloud water (liquid + ice) in input data

 if (any(int(field3d(:,:,1:nlev_inp,7)) == int(val_missing)).or.maxval(field3d(:,:,1:nlev_inp,7)) < zqcmin) then
   if (ist == inst_start) print*, "Total cloud water (liquid + ice) is not available in input"
   iflag_cl = 0
 else
   iflag_cl = 1
   if (ist == inst_start) print*, "Total cloud water (liquid + ice) is available in input"
   do k=1,nlev_inp
     k1=nlev_inp-k+1
     qc_inp(1:nlon_inp0,:,k) = max(0., field3d(1:nlon_inp0,:,k1,7))
   enddo
   if (nlon_inp0 /= nlon_inp) then
     qc_inp(nlon_inp,:,:) = qc_inp(1,:,:)
   endif
 endif

! Check availability of cloud liquid water in input data

 if (any(int(field3d(:,:,1:nlev_inp,8)) == int(val_missing)).or.maxval(field3d(:,:,1:nlev_inp,8)) < zqcmin) then
   if (ist == inst_start) print*, "Cloud liquid water is not available in input"
   iflag_clw = 0
 else
   iflag_clw = 1
   if (ist == inst_start) print*, "Cloud liquid water is available in input"
   do k=1,nlev_inp
     k1=nlev_inp-k+1
     qcw_inp(1:nlon_inp0,:,k) = max(0., field3d(1:nlon_inp0,:,k1,8))
   enddo
   if (nlon_inp0 /= nlon_inp) then
     qcw_inp(nlon_inp,:,:) = qcw_inp(1,:,:)
   endif
 endif

! Check availability of cloud ice in input data

 if (any(int(field3d(:,:,1:nlev_inp,9)) == int(val_missing)).or.maxval(field3d(:,:,1:nlev_inp,9)) < zqcmin) then
   if (ist == inst_start) print*, "Cloud ice is not available in input"
   iflag_cli = 0
 else
   iflag_cli = 1
   if (ist == inst_start) print*, "Cloud ice is available in input"
   do k=1,nlev_inp
     k1=nlev_inp-k+1
     qci_inp(1:nlon_inp0,:,k) = max(0., field3d(1:nlon_inp0,:,k1,9))
   enddo
   if (nlon_inp0 /= nlon_inp) then
     qci_inp(nlon_inp,:,:) = qci_inp(1,:,:)
   endif
 endif

! Control of cloud water content and division total cloud water content into
! liquid water and ice
! Definition of virtual temperature

 do k = 1,nlev_inp
   do j = 1,nlat_inp
     do i = 1,nlon_inp

       q_inp(i,j,k) = max(q_inp(i,j,k), zqcmin)

       if (iflag_cl == 0.and.(iflag_clw == 1.or.iflag_cli == 1)) then
         qc_inp(i,j,k) = qcw_inp(i,j,k) + qci_inp(i,j,k)
       endif

       qc_inp(i,j,k) = max( qc_inp(i,j,k), (qcw_inp(i,j,k)+qci_inp(i,j,k)) )

! In the case of absence of cloud water/ice data in input
! controlq procedure check that Q does not exceed (significantly) saturation and
! increases slightly q values close to saturation
       if (iflag_cl == 0.and.iflag_clw == 0.and.iflag_cli == 0) then
         call controlq (q_inp(i,j,k),t_inp(i,j,k),p_inp_local(i,j,k),eps)
       endif

       if (iflag_cl == 1.and.(iflag_clw == 0.or.iflag_cli == 0)) then
         call qsat_entropy(t_inp(i,j,k),p_inp_local(i,j,k),qsat,qsatw,qsati,esat,esatw,esati,fracw)
         qcw_inp(i,j,k)=qc_inp(i,j,k)*fracw
         qci_inp(i,j,k)=qc_inp(i,j,k)*(1.-fracw)
       endif

       tvirt_inp(i,j,k)=t_inp(i,j,k)*(1.+ep*q_inp(i,j,k)-qc_inp(i,j,k))

     enddo
   enddo
 enddo

! Definition of topography hight (htop_inp) using the surface geopotential

! If available, the 2-D geopotential at the ground surface is used, otherwise
! the "3-D" geop. (model level) at the ground surface is used to define htop_atm_inp.
! The viceversa is not possible in case of hybrid level data: if the model level
! geopotential is missing, the program stops with a message.
! In case of input data on isobaric levels, the 3-D geopotential is not required.

 if (ist == inst_start) then

   if ((any(int(field2d(:,:,2)) == int(val_missing))).and.(any(int(field2d(:,:,1)) == int(val_missing)))) then
     print*, "Neither the 3-D model level geopotential nor the 2-D geopotential"
     print*, "at the surface are available in IFS-ECMWF input grib data, stops"
     stop
   endif

   if (any (int(field2d(:,:,1)) == int(val_missing)) ) then
     print*, "Warning: 2-D geopotential at the surface (gaussian grid topography)"
     print*, "is missing in IFS-ECMWF input grib data."
     print*, "Therefore it is substituted with the 3-D model level surface geopotential"
     print*, "This may imply some errors in interpolating surface variables"
     print*, "from the input data ground surface to the output ground surface."
     htop_atm_inp(1:nlon_inp0,:) = field2d(1:nlon_inp0,:,2)/g0
     if (nlon_inp0 /= nlon_inp) htop_atm_inp(nlon_inp,:) = htop_atm_inp(1,:)
     htop_inp(:,:) = htop_atm_inp(:,:)
   else
     htop_inp(1:nlon_inp0,:) = field2d(1:nlon_inp0,:,1)/g0
     if (nlon_inp0 /= nlon_inp) htop_inp(nlon_inp,:) = htop_inp(1,:)
     allocate (htop_inp_save(nlon_inp,nlat_inp))
     htop_inp_save(:,:) = htop_inp(:,:)
   endif

   if (level_type == 2) then ! Hybrid levels
     if (any (int(field2d(:,:,2)) == int(val_missing)) ) then
       print*, "The 3-D model surface level geopotential is missing in IFS-ECMWF input data,"
       print*, "but this field is essential for a correct processing of vertical coordinate"
       print*, "when input data are on hybrid levels, stop"
       stop
     else
       htop_atm_inp(1:nlon_inp0,:) = field2d(1:nlon_inp0,:,2)/g0
       if (nlon_inp0 /= nlon_inp) htop_atm_inp(nlon_inp,:) = htop_atm_inp(1,:)
       allocate (htop_atm_inp_save(nlon_inp,nlat_inp))
       htop_atm_inp_save(:,:) = htop_atm_inp(:,:)
     endif
   endif

 else ! ist > inst_start

   if (any (int(field2d(:,:,2)) == int(val_missing)).and.any (int(field2d(:,:,1)) == int(val_missing)).and.res_change /= 0 ) then
     print *,"Grid resolution of IFS input data has changed at instant = ",ist
     print *,"but neither the field of surface geopotential in IFS input data in this instant, stop" 
     stop
   endif

   if (res_change /= 0) then
     deallocate(htop_inp_save)
     allocate(htop_inp_save(nlon_inp,nlat_inp))
     if (any (int(field2d(:,:,1)) == int(val_missing)) ) then
       print*, "Warning: 2-D geopotential at the surface (gaussian grid topography)"
       print*, "is missing in IFS-ECMWF input grib data."
       print*, "Therefore it is substituted with the 3-D model level surface geopotential"
       print*, "This may imply some errors in interpolating surface variables"
       print*, "from the input data ground surface to the output ground surface."
       
       htop_inp(1:nlon_inp0,:) = field2d(1:nlon_inp0,:,2)/g0
       if (nlon_inp0 /= nlon_inp) htop_inp(nlon_inp,:) = htop_inp(1,:)
     else
       htop_inp(1:nlon_inp0,:) = field2d(1:nlon_inp0,:,1)/g0
       if (nlon_inp0 /= nlon_inp) htop_inp(nlon_inp,:) = htop_inp(1,:)
     endif
     htop_inp_save(:,:) = htop_inp(:,:)
   else
     htop_inp(:,:) = htop_inp_save(:,:)
   endif

   if (level_type == 2) then ! Hybrid levels
     if (res_change /= 0) then
       if (any (int(field2d(:,:,2)) == int(val_missing)) ) then
         print *,"Grid resolution of IFS input data has changed at instant = ",ist
         print *,"but the field of 3-D model level surface geopotential is missing in IFS input data in this instant, stop" 
         stop
       else
         htop_atm_inp(1:nlon_inp0,:) = field2d(1:nlon_inp0,:,2)/g0
         if (nlon_inp0 /= nlon_inp) htop_atm_inp(nlon_inp,:) = htop_atm_inp(1,:)
         deallocate (htop_atm_inp_save)
         allocate (htop_atm_inp_save(nlon_inp,nlat_inp))
         htop_atm_inp_save(:,:) = htop_atm_inp(:,:)
       endif
     else
       htop_atm_inp(:,:) = htop_atm_inp_save(:,:)
     endif
   endif

 endif ! ist

! Definition of level zeta for hybrid coordinate case

 if (level_type == 2) then ! Hybrid levels

   do j = 1,nlat_inp
     do i = 1,nlon_inp

! ln(p) on input atmospheric levels

       p_level_inp(1:nlev_inp)=log(p_inp_local(i,j,1:nlev_inp))

       zeta_inp(i,j,1) = htop_atm_inp(i,j) + (psl_inp(i,j)-p_level_inp(1))*rd*tvirt_inp(i,j,1)/g0
       do k = 2,nlev_inp
         zeta_inp(i,j,k) = zeta_inp(i,j,k-1) + (p_level_inp(k-1)-p_level_inp(k))/g0*rd*0.5*(tvirt_inp(i,j,k-1)+tvirt_inp(i,j,k))
       enddo

     enddo
   enddo

 endif

! Horizontal filtering of the upper level (atmospheric) input fields

 if (.not.frame) then
   wei = 0.5
   do k = 1,nlev_inp
     zzz = -8000.*log(p_inp_local(1,1,k)/1000.e2)
     nsmooth = int((zzz/1000.)**2/45.)
     nsmooth = nsmooth/3
     if ( ist == inst_start .and.nsmooth > 0) print *,"IFS lev.",h_level_inp(k),"p(1,1), hPa",p_inp_local(1,1,k)/100.,"nsmooth",nsmooth
     if (nsmooth >= 1) then
       call smooth_soil(zeta_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
       call smooth_soil(t_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
       call smooth_soil(tvirt_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
       call smooth_soil(u_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
       call smooth_soil(v_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
       call smooth_soil(q_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
       call smooth_soil(qc_inp(1,1,k),work_inp,nlon_inp,nlat_inp,wei,nsmooth)
       call smooth_soil(qcw_inp(1,1,k),work_inp,nlon_inp,nlat_inp,wei,nsmooth)
       call smooth_soil(qci_inp(1,1,k),work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     endif
   enddo
 endif
   
! Definition of surface pressure (ps_inp) of the case of isobaric level

 if (level_type == 1) then ! Isobaric levels
   do j = 1,nlat_inp
     do i = 1,nlon_inp
       ps_inp(i,j) = exp( alog(p_inp_local(i,j,1))+g0*(zeta_inp(i,j,1)-htop_inp(i,j))/(rd*tvirt_inp(i,j,1)) )  
     enddo
   enddo
 else ! Hybrid levels
   ps_inp(:,:) = exp(psl_inp(:,:))
 endif

! Vertical velocity

 w_inp(:,:,:) = 0.

 if (ist == inst_start)  then
   allocate(fmask_inp_save(nlon_inp,nlat_inp))
   fmask_inp_save(:,:) = val_missing
   allocate(soil_type_inp_save(nlon_inp,nlat_inp))
 endif

 if (surf_elaborate) then

! Definition of meteorological fields declared in main program
! LIST TO BE CHECKED ! see subroutine read_grib2_data

! Land-sea fraction

   if (any (int(field2d(:,:,3)) == int(val_missing)) ) then
     if (res_change /= 0) then
       print *,"The land-sea fraction field is missing in IFS input data in instant ",ist 
       print *,"but surface analysis has been required and grid resolution of IFS input data has changed"
       print *,"Stop"
       stop
     else
       if (any (int(fmask_inp_save(:,:)) == int(val_missing))) then
         print *,"The land-sea fraction field is missing in IFS input data in instant ",ist 
         print *,"but surface analysis has been required and this filed is not save from a previous instant"
         print *,"Stop"
         stop
       else
         fmask_inp(:,:) = fmask_inp_save(:,:)
       endif
     endif
   else
     fmask_inp(1:nlon_inp0,:) = field2d(1:nlon_inp0,:,3)
     if (nlon_inp0 /= nlon_inp) fmask_inp(nlon_inp,:) = fmask_inp(1,:)
     fmask_inp(:,:) = min(max(1.-fmask_inp(:,:),0.),1.) ! Conversion of FMASK: 0-sea, 1-land to 1-sea, 0-land
     deallocate(fmask_inp_save)
     allocate(fmask_inp_save(nlon_inp,nlat_inp))
     fmask_inp_save(:,:) = fmask_inp(:,:)
   endif

! Soil types

   if (any (int(field2d(:,:,21)) == int(val_missing)) ) then
     if (res_change /= 0) then
       print *,"After 06/06/2007 grib1 parameter 043 (soil type) is required in input"
       print *,"The soil type field is missing in IFS input data in instant ",ist 
       print *,"but surface analysis has been required and grid resolution of iFS input data has changed"
       print *,"Stop"
       stop
     else
       if (any (int(soil_type_inp_save(:,:)) == int(val_missing))) then
         print *,"The soil type field is missing in IFS input data in instant ",ist 
         print *,"but surface analysis has been required and this filed is not save from a previous instant"
         print *,"Stop"
         stop
       else
         soil_type_inp(:,:) = soil_type_inp_save(:,:)
       endif
     endif
   else
     soil_type_inp(1:nlon_inp0,:) = field2d(1:nlon_inp0,:,21)
     if (nlon_inp0 /= nlon_inp) soil_type_inp(nlon_inp,:) = soil_type_inp(1,:)
     deallocate(soil_type_inp_save)
     allocate(soil_type_inp_save(nlon_inp,nlat_inp))
     soil_type_inp_save(:,:) = soil_type_inp(:,:)
   endif

! Soil temperature and soil water content

   if (nlevg_inp == 0) then
     print *,'No soil parameter data in input,'
     print *,'but surface analysis has been required, stop'
     stop
   endif

   do k=1,nlevg_inp
! Temperature
     iflag=1
     loop_j_tg: do j = 1,nlat_inp
       do i = 1,nlon_inp
         if (int(field3d_soil(i,j,k,1)) == int(val_missing).and.fmask_inp(i,j) < 1.e-7) then
           iflag=0
           exit loop_j_tg
         endif
       enddo
     enddo loop_j_tg
     if (iflag == 0) then 
       print *,'No soil temperature data in input at soil level ',soil_lev_inp(k)
       print *,'but surface analysis has been required, stop'
       stop
     else
       tg_inp(1:nlon_inp0,:,k) = field3d_soil(1:nlon_inp0,:,k,1)
     endif
! Water content
     iflag=1
     loop_j_qg: do j = 1,nlat_inp
       do i = 1,nlon_inp
         if (int(field3d_soil(i,j,k,2)) == int(val_missing).and.fmask_inp(i,j) < 1.e-7) then
           iflag=0
           exit loop_j_qg
         endif
       enddo
     enddo loop_j_qg
     if (iflag == 0) then 
       print *,'No soil water content data in input at soil level ',soil_lev_inp(k)
       print *,'but surface analysis has been required, stop'
       stop
     else
       qg_inp(:,:,k) = field3d_soil(:,:,k,2)
       qg_inp(1:nlon_inp0,:,k) = field3d_soil(1:nlon_inp0,:,k,2)
     endif
   enddo

   if (nlon_inp0 /= nlon_inp) then
     tg_inp(nlon_inp,:,:) = tg_inp(1,:,:)
     qg_inp(nlon_inp,:,:) = qg_inp(1,:,:)
   endif

! Surface temperature

   if (any (int(field2d(:,:,5)) == int(val_missing))) then
     print *,'      Attention:'
     print *,'No surface temperature data in input but surface analysis has been required'
   else
     tsurf_inp(1:nlon_inp0,:) = field2d(1:nlon_inp0,:,5)
     if (nlon_inp0 /= nlon_inp) tsurf_inp(nlon_inp,:) = tsurf_inp(1,:)
   endif

! Snow water content

   iflag=1
   loop_j_snow: do j = 1,nlat_inp
     do i = 1,nlon_inp
       if (int(field2d(i,j,14)) == int(val_missing).and.fmask_inp(i,j) < 1.e-7) then
         iflag=0
         exit loop_j_snow
       endif
     enddo
   enddo loop_j_snow
   if (iflag == 0) then 
     print *,'No data about water content in snow cover in input'
     print *,'but surface analysis has been required, stop'
   else
     do j = 1,nlat_inp
       do i = 1,nlon_inp0
         snow_inp(i,j) = max(0., field2d(i,j,14)*1.e-3) ! Conversion from kg m**-2 (mm) into m of water
       enddo
     enddo
     if (nlon_inp0 /= nlon_inp) snow_inp(nlon_inp,:) = snow_inp(1,:)
   endif

! Sea ice fraction and temperature

   iflag=1
   loop_j_fice: do j = 1,nlat_inp
     do i = 1,nlon_inp
       if (int(field2d(i,j,22)) == int(val_missing).and.fmask_inp(i,j) > 0.99) then
         iflag=0
         exit loop_j_fice
       endif
     enddo
   enddo loop_j_fice
   if (iflag == 0) then 
     print *,'      Attention:'
     print *,'No sea ice fraction data in input but surface analysis has been required'
     fice_inp(:,:) = 0.
   else
     fice_inp(1:nlon_inp0,:) = min( max( field2d(1:nlon_inp0,:,22), 0.), 1.)
     if (nlon_inp0 /= nlon_inp) fice_inp(nlon_inp,:) = fice_inp(1,:)
   endif

   iflag=1
   loop_j_tice: do j = 1,nlat_inp
     do i = 1,nlon_inp
       if (int(field3d_soil(i,j,1,6)) == int(val_missing).and.fmask_inp(i,j) > 0.99) then
         iflag=0
         exit loop_j_tice
       endif
     enddo
   enddo loop_j_tice
   if (iflag == 0) then 
     print *,'      Attention:'
     print *,'No sea ice temperature data in input but surface analysis has been required'
     tice_inp(:,:,:) = val_missing
   else
     tice_inp(1:nlon_inp0,:,1:nlevg_inp) = min( max( field3d_soil(1:nlon_inp0,:,1:nlevg_inp,6), 200.), 273.)
     if (nlon_inp0 /= nlon_inp) tice_inp(nlon_inp,:,1:nlevg_inp) = tice_inp(1,:,1:nlevg_inp)
   endif

! There are not data about sea ice thickness in IFS data

   iceth_inp(:,:) = 0.

! Conversion of specific volumetric soil water content into relative soil humidity

! nst_inp - Number of soil types
! qgmin_inp_work- minimum volumetric water content (m**3/m**3)
! qgmax_inp_work - maximum (saturation, porosity) volumetric water conent (m**3/m**3)

! In IFS
! After 06/06/2007:
! Soil texture types: 1 - Coarse, 2 - Medium, 3 - Medium-Fine,
!                     4 - Fine, 5 - Very Fine, 6 - Organic
!                     7 - unknown!
! Before 06/06/2007 (DATE=2007-06-06):
! a unique soil texture type is used in IFS-ECMWF model: 1 - Loamy

   iday=idate0_inp(1)*10000+idate0_inp(2)*100+idate0_inp(3)   

   if ( iday>= 20070606) then

     do j = 1,nlat_inp
       do i = 1,nlon_inp
         k1=int(soil_type_inp(i,j))
         if (k1 /= 0) then
           if (k1 >= 1.and.k1 <= nst_inp) then
             do k = 1,nlevg_inp
               qg_inp(i,j,k) = (qg_inp(i,j,k)-qgmin_inp_work(k1))/(qgmax_inp_work(k1)-qgmin_inp_work(k1))
             enddo
           else
             print *,'Attention: soil texture type in input file ',k1,' is outside the allowed range ',nst_inp,' at point ',i,j
           endif
         else
           qg_inp(i,j,1:nlevg_inp) = 0.
         endif
       enddo
     enddo

   else

     k1 = 1 ! soil type
     do k = 1,nlevg_inp
       do j = 1,nlat_inp
         do i = 1,nlon_inp
           qg_inp(i,j,k) = (qg_inp(i,j,k)-qgmin_inp_work2(k1))/(qgmax_inp_work2(k1)-qgmin_inp_work2(k1))
         enddo
       enddo
     enddo

   endif

! Definition of temperature and soil water content in the case of missing data over the sea

   do k = 1,nlevg_inp
     do j = 1,nlat_inp
       do i = 1,nlon_inp
         if (int(tg_inp(i,j,k))==int(val_missing).and.fmask_inp(i,j) >= 0.5) tg_inp(i,j,k) = tsurf_inp(i,j)
         if (int(qg_inp(i,j,k))==int(val_missing).or.fmask_inp(i,j) >= 0.5) qg_inp(i,j,k) = 0.50 ! to be used to define qg on small islands
       enddo
     enddo
   enddo

   qg_inp(:,:,:) = max(min(qg_inp(:,:,:),1.),0.) ! reset to min-max of relative values

 endif ! surf_elaborate

! Deallocation of internal work arrays

 deallocate (p_level_inp)
 deallocate (h_level_inp)
 deallocate (ph_all_level_inp)
 deallocate (pl_all_level_inp)
 deallocate (p_inp_local)
 deallocate (soil_type_inp)
 deallocate (work_inp)

return
end
!------------------------------------------------------------------------------
subroutine conv_gfs_data(ist)

! Procedure to convert meteorological fields derived from input files of GFS-NCEP model
!------------------------------------------------------------------------
! Procedure requests in input following parameters:
! nlev_inp  - atmospheric levels number in input data;
! nlevg_inp  - soil levels number in input data;
! nlon_inp  - grid point number of input data along x-axis;
! nlat_inp  - grid point number of input data along y-axis;
! lev_list_inp - 1d array with atmospheric level list of input data;
! soil_lev_inp - 1d array with soil level list of input data;
! field3d - 4d array with parameters at atmosphereic level;
! field3d_soil - 4d array with parameters at soil level;
! field2d - 3d array with parameters at the surface.
! idate0_inp - 1d array with date, time of simulation start or analysis
!
! Following parameters must be defined in output of this procedure:
! frame - logical flag: .false. - no frame in input data, .true. - frame in input data
! mask_frame - 2d ingeter array with flag of input data presence in a grid point,
! if no frame, then all values of mask_frame equal 1
! iperiod_inp  1d array with simulation term
! fmask_inp - 2d array with sea-land fraction (1-sea, 0-land);
! ps_inp - 2d array with surface pressure (Pa) of input data;
! htop_inp - 2d array with topography hight (m) of input data;
! zeta_inp - 3d array with geometric altitude (m, over sea surface) of atmospheric levels of input data;
! t_inp - 3d array with temperature (K) at atmospheric levels of input data;
! u_inp - 3d array with u-component of wind (m/s) at atmospheric levels of input data;
! v_inp - 3d array with v-component of wind (m/s) at atmospheric levels of input data;
! q_inp - 3d array with specific humidity (kg/kg) at atmospheric levels of input data;
! qcw_inp - 3d array with specific cloud liquid water content (kg/kg) at atmospheric levels of input data;
! qci_inp - 3d array with specific cloud ice water content (kg/kg) at atmospheric levels of input data;
! tvirt_inp - 3d array with virtual temperature (K) at atmospheric levels of input data;
! w_inp - 3d array with vertical velocity (m/s) at atmospheric levels of input data;
! tg_inp - 3d array with temperature (m/s) at soil levels of input data;
! qg_inp - 3d array with relative soil water content (proportion) at soil levels of input data;
! snow_inp - 2d array with total water content of surface snow cover (kg/m^2);
! tsurf_inp - 2d array with surface temperature (K);
! qvsurf_inp - 2d array with specipic humidity (kg/kg) at the surface;
! fice_inp - 2d array with fraction of sea ice cover (proportion) at the surface;
! iceth_inp - 2d array with thickness of sea ice cover (m) at the surface.
! 
!------------------------------------------------------------------------

use parameters, only : g0, eps, ep, rd, pi, surf_elaborate, val_missing, inst_start
use input_data, alon_inp=>alon_t_inp, alat_inp=>alat_t_inp

implicit none

integer, parameter :: nst_inp=1
integer, save :: nlon_inp_old, nlat_inp_old
real, dimension(:), allocatable :: p_level_inp
real, dimension(:,:,:), allocatable :: rh_inp
real, dimension(:,:), allocatable :: p80_inp, u80_inp, v80_inp, t80_inp, q80_inp, work_inp
real, dimension(nst_inp) :: qgmax_inp_work=(/0.470/),qgmin_inp_work=(/0./)
integer, dimension(12) :: imon=(/31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31/)

integer :: ist, i, j, k, k1, ktop_cl, k80m, iflag_cloude, iflag_80m, iflag, nday, nsmooth
real, save :: day
real :: qsat, qsatw, qsati, esat, esatw, esati, eee, fracw, zwater, qcw80_inp, qci80_inp, tvirt80_inp, &
 day1, day2, zflatt, zf1, zf2, zflatq, zdiftp, zwf, zeta1, zzz, wei
real, dimension(1) :: zeta80_inp, qc80_inp
integer, dimension(1) :: iv
real, dimension(nlevg_inp) :: zdtg

 mask_frame(:,:) = 1
 frame = .false.

! Control of grid resolution changign

 res_change = 0
 if(ist > inst_start .and.(nlon_inp /= nlon_inp_old.or.nlat_inp /= nlat_inp_old)) then
   print*
   print*, "The GFS grid resolution has changed at instant: ist =", ist
   print*
   print*
   res_change = 1
 endif
 nlon_inp_old = nlon_inp
 nlat_inp_old = nlat_inp

 if (iperiod_inp_grib2(1)==1) then         ! Time unit is hour
   iperiod_inp(1) = iperiod_inp_grib2(2)/24                                     ! Days
   iperiod_inp(2) = iperiod_inp_grib2(2)-iperiod_inp(1)*24                      ! Hours
   iperiod_inp(3) = 0                                                           ! Minutes
 elseif (iperiod_inp_grib2(1)==0) then     ! Time unit is minute
   iperiod_inp(1) = iperiod_inp_grib2(2)/24/60                                  ! Days
   iperiod_inp(2) = (iperiod_inp_grib2(2)-iperiod_inp(1)*24*60)/60              ! Hours
   iperiod_inp(3) = iperiod_inp_grib2(2)-iperiod_inp(1)*24*60-iperiod_inp(2)*60 ! Minutes
 endif

 if (ist == inst_start) then
   nday = idate0_inp(3)
   do j = 1,idate0_inp(2)-1
     nday = nday + imon(j)
   enddo
   day = float(nday-1)+float(idate0_inp(4))/24. ! day of the year as real (with hour precision)
 endif

! Allocation of internal work arrays

 allocate (p_level_inp(nlev_atm_inp_max))
 allocate (rh_inp(nlon_inp,nlat_inp,nlev_atm_inp_max))
 allocate (p80_inp(nlon_inp,nlat_inp))
 allocate (u80_inp(nlon_inp,nlat_inp))
 allocate (v80_inp(nlon_inp,nlat_inp))
 allocate (t80_inp(nlon_inp,nlat_inp))
 allocate (q80_inp(nlon_inp,nlat_inp))
 allocate (work_inp(nlon_inp,nlat_inp))

 do k=1,nlev_inp
   k1=nlev_inp-k+1
   p_level_inp(k)  = lev_list_inp(k1)
 enddo

 if (ist == inst_start) then
  write(*,'(a,i3)') " Number of isobaric levels in input data ", nlev_inp
  print *,'Isobaric levels for which T is available in input data:'
  do k = 1,nlev_inp
  print '(i4,a6,f5.0,a2)',k,'   p =',p_level_inp(k)*0.01,'e2'
  enddo
  print*
 endif

! Definition of meteorological fields declared in main program
! LIST TO BE CHECKED ! see subroutine read_grib2_data

 do k=1,nlev_inp
   k1=nlev_inp-k+1
! Geopotential
   if (any( int(field3d(:,:,k1,1)) == int(val_missing) )) then 
     print *,'No geopotential data in input at level ',p_level_inp(k)*0.01,'e2, stop'
     stop
   else
     zeta_inp(1:nlon_inp0,:,k) = field3d(1:nlon_inp0,:,k1,1)/g0
   endif
! Temperature
   if (any( int(field3d(:,:,k1,2)) == int(val_missing) )) then 
     print *,'No temperature data in input at level ',p_level_inp(k)*0.01,'e2, stop'
     stop
   else
     t_inp(1:nlon_inp0,:,k) = field3d(1:nlon_inp0,:,k1,2)
   endif
! U-component of wind
   if (any( int(field3d(:,:,k1,3)) == int(val_missing) )) then 
     print *,'No data of U-component of wind in input at level ',p_level_inp(k)*0.01,'e2, stop'
     stop
   else
     u_inp(1:nlon_inp0,:,k) = field3d(1:nlon_inp0,:,k1,3)
   endif
! V-component of wind
   if (any( int(field3d(:,:,k1,4)) == int(val_missing) )) then 
     print *,'No data of V-component of wind in input at level ',p_level_inp(k)*0.01,'e2, stop'
     stop
   else
     v_inp(1:nlon_inp0,:,k) = field3d(1:nlon_inp0,:,k1,4)
   endif
! Relative humidity
   if (any( int(field3d(:,:,k1,6)) == int(val_missing) ).and.p_level_inp(k) > 100.e2) then 
     print *,'No relative humidity data in input at level ',p_level_inp(k)*0.01,'e2, stop'
     stop
   else
     rh_inp  (1:nlon_inp0,:,k) = field3d(1:nlon_inp0,:,k1,6)
   endif
   if(p_level_inp(k) <=   1.e2) rh_inp(:,:,k) = 0.0003
   if(p_level_inp(k) <=   3.e2) rh_inp(:,:,k) = 0.004
   if(p_level_inp(k) <=  10.e2) rh_inp(:,:,k) = 0.05
   if(p_level_inp(k) <=  20.e2) rh_inp(:,:,k) = 0.5
   if(p_level_inp(k) <=  30.e2) rh_inp(:,:,k) = 1.0
   if(p_level_inp(k) <=  70.e2) rh_inp(:,:,k) = 2.0
   if(p_level_inp(k) <= 100.e2) rh_inp(:,:,k) = 4.0
 enddo

 if (nlon_inp0 /= nlon_inp) then
   zeta_inp(nlon_inp,:,:) = zeta_inp(1,:,:)
   t_inp(nlon_inp,:,:) = t_inp(1,:,:)
   u_inp(nlon_inp,:,:) = u_inp(1,:,:)
   v_inp(nlon_inp,:,:) = v_inp(1,:,:)
   rh_inp(nlon_inp,:,:) = rh_inp(1,:,:)
 endif

! Cloud water content

 qc_inp(:,:,:) = 0.

 do k = 1,nlev_inp
   if (lev_list_inp(k) > 150.e2) then
     ktop_cl=k
     exit
   endif
 enddo

 if (any(int(field3d(:,:,ktop_cl:nlev_inp,7)) == int(val_missing)).or.maxval(field3d(:,:,ktop_cl:nlev_inp,7))<1.e-7) then
   iflag_cloude = 0
   if (ist == inst_start) print*, "Cloud total water (liquid+ice) is not available in input"
 else
   iflag_cloude = 1
   do k1 = ktop_cl,nlev_inp
     k=nlev_inp-k1+1
     qc_inp(1:nlon_inp0,:,k) = field3d(1:nlon_inp0,:,k1,7)
   enddo
   if (nlon_inp0 /= nlon_inp) qc_inp(nlon_inp,:,:) = qc_inp(1,:,:)
   if( ist == inst_start ) print*, "Cloud total water (liquid+ice) is available in input"
 endif

! Conversion of relative humidity into specific humidity
! Control of cloud water content and division total cloud water content into
! liquid water and ice
! Definition of virtual temperature

 do k = 1,nlev_inp
   do j = 1,nlat_inp
     do i = 1,nlon_inp

       rh_inp(i,j,k) = max(rh_inp(i,j,k),0.)
       rh_inp(i,j,k) = min(rh_inp(i,j,k),102.)
       call qsat_tetens(t_inp(i,j,k), p_level_inp(k), eps, qsat, qsatw, qsati, esat, esatw, esati)
       eee = esat*rh_inp(i,j,k)*1.e-2
       q_inp(i,j,k) = eps*eee/(eps*eee-eee+p_level_inp(k))
       q_inp(i,j,k) = max(q_inp(i,j,k), 1.e-7)

! Reduction of cloud water+ice

       if (p_level_inp(k) < 280.e2) then
         qc_inp(i,j,k) = qc_inp(i,j,k)*(p_level_inp(k)/280.e2)**2 ! Reduction of cloud water/ice at high levels
       endif

       qc_inp(i,j,k) = max(qc_inp(i,j,k), 0.)
       qc_inp(i,j,k) = min(qc_inp(i,j,k),1.5e-3)   ! to avoid excessive condensate 
       if (rh_inp(i,j,k) > 0..and.rh_inp(i,j,k) <= 60.) qc_inp(i,j,k) = 0.  ! to avoid condensate at low relative humidity

! In the case of absence of cloud water/ice data in input
! controlq procedure check that Q does not exceed (significantly) saturation and
! increases slightly q values close to saturation
       if (iflag_cloude == 0) then
         call controlq (q_inp(i,j,k),t_inp(i,j,k),p_level_inp(k),eps)
       endif

       call qsat_entropy(t_inp(i,j,k),p_level_inp(k),qsat,qsatw,qsati,esat,esatw,esati,fracw)
       qcw_inp(i,j,k)=qc_inp(i,j,k)*fracw
       qci_inp(i,j,k)=qc_inp(i,j,k)*(1.-fracw)

       tvirt_inp(i,j,k)=t_inp(i,j,k)*(1.+ep*q_inp(i,j,k)-qc_inp(i,j,k))

     enddo
   enddo
 enddo

! Definition of topography hight (htop_inp) using the surface geopotential

 if (ist == inst_start) then

   if (any (int(field2d(:,:,1)) == int(val_missing)) ) then
     print*, "The topography field is missing in GFS input data in 1-st instant, stop" 
     stop
   else
     htop_inp(1:nlon_inp0,:) = field2d(1:nlon_inp0,:,1)/g0
     if (nlon_inp0 /= nlon_inp) htop_inp(nlon_inp,:) = htop_inp(1,:)
     allocate (htop_inp_save(nlon_inp,nlat_inp))
     htop_inp_save(:,:) = htop_inp(:,:)
   endif

 else ! ist > inst_start

   if (res_change /= 0) then
     if (any (int(field2d(:,:,1)) == int(val_missing)) ) then
       print *,"Grid resolution of GFS input data has changed at instant = ",ist
       print *,"but the topography field is missing in GFS input data in this instant, stop" 
       stop
     else
       htop_inp(1:nlon_inp0,:) = field2d(1:nlon_inp0,:,1)/g0
       if (nlon_inp0 /= nlon_inp) htop_inp(nlon_inp,:) = htop_inp(1,:)
       deallocate (htop_inp_save)
       allocate (htop_inp_save(nlon_inp,nlat_inp))
       htop_inp_save(:,:) = htop_inp(:,:)
     endif
   else
     htop_inp(:,:) = htop_inp_save(:,:)
   endif

 endif ! ist

! Correction of zeta from first level located below ground
! A compromise solution is applied: weighted average between the old and the
! new geopotential, corrected as a function of the distance between the GFS orography
! and the level considered (zwr=0.: no correct.; zwf=1.: full correct.)

 do j = 1,nlat_inp
   do i = 1,nlon_inp

     do k = 1,nlev_inp
       if (zeta_inp(i,j,k) >= htop_inp(i,j)) then
         k1=k
         exit
       endif
     enddo

     if (k1 > 1) then
       do k = k1-1,1,-1
         zdiftp = max(htop_inp(i,j)-zeta_inp(i,j,k), 0.)
         zwf = min(zdiftp/150.,1.)
         zeta1 = zeta_inp(i,j,k)
         zeta_inp(i,j,k) = zeta_inp(i,j,k+1) + (log(p_level_inp(k+1)/p_level_inp(k))*rd*.5*           &
                   ((1.+ep*q_inp(i,j,k))*t_inp(i,j,k)+(1.+ep*q_inp(i,j,k+1))*t_inp(i,j,k+1)))/g0
         zeta_inp(i,j,k) = zwf*zeta_inp(i,j,k)+(1.-zwf)*zeta1
       enddo
     endif

   enddo
 enddo

! Horizontal filtering of the upper level (atmospheric) input fields

 if ( ist == inst_start.and.nsmooth > 0) write (*,*)
 wei = 0.5
 do k = 1,nlev_inp
   zzz = -8000.*log(p_level_inp(k)/1000.e2)
   nsmooth = int((zzz/1000.)**2/45.)
   nsmooth = nsmooth/4
   if ( ist == inst_start.and.nsmooth > 0) write (*,'(a,i4,a,f8.3,a,i3)') " GFS lev.",k,",  p(k) hPa",p_level_inp(k)/100.,", nsmooth",nsmooth
   if (nsmooth >= 1) then
     call smooth_soil(zeta_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooth_soil(t_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooth_soil(tvirt_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooth_soil(u_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooth_soil(v_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooth_soil(q_inp(1,1,k), work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooth_soil(qc_inp(1,1,k),work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooth_soil(qcw_inp(1,1,k),work_inp,nlon_inp,nlat_inp,wei,nsmooth)
     call smooth_soil(qci_inp(1,1,k),work_inp,nlon_inp,nlat_inp,wei,nsmooth)
   endif
 enddo
   
! Definition of surface pressure (ps_inp)

 do j = 1,nlat_inp
   do i = 1,nlon_inp
     ps_inp(i,j) = exp( alog(p_level_inp(1))+g0*(zeta_inp(i,j,1)-htop_inp(i,j))/(rd*tvirt_inp(i,j,1)) )  
   enddo
 enddo

!! Introducing of eventual input data level at 80 m above the surface
!
! iflag_80m=1
! if (any( int(field2d(:,:,40)) == int(val_missing) )) then 
!   iflag_80m=0
! else
!   p80_inp(:,:)  = field2d(:,:,40)
! endif
! if (any( int(field2d(:,:,41)) == int(val_missing) )) then 
!   iflag_80m=0
! else
!   u80_inp(:,:)  = field2d(:,:,41)
! endif
! if (any( int(field2d(:,:,42)) == int(val_missing) )) then 
!   iflag_80m=0
! else
!   v80_inp(:,:)  = field2d(:,:,42)
! endif
! if (any( int(field2d(:,:,38)) == int(val_missing) )) then 
!   iflag_80m=0
! else
!   t80_inp(:,:)  = field2d(:,:,38)
! endif
! if (any( int(field2d(:,:,39)) == int(val_missing) )) then 
!   iflag_80m=0
! else
!   q80_inp(:,:)  = field2d(:,:,39)
! endif
!
! if (iflag_80m == 1) then
!
!  if (ist == inst_start) then
!    print *,"There are input data at additional level 80 m above the surface"
!  endif
!
!   do j = 1,nlat_inp
!     do i = 1,nlon_inp
!
!       zeta80_inp(1)=80.+htop_inp(i,j)
!       call near (zeta80_inp(1:1), 1, zeta_inp(i,j,1:nlev_inp), nlev_inp, iv(1:1))
!       call interp_spline_1d (qc80_inp(1:1), zeta80_inp(1:1), 1, &
! qc_inp(i,j,1:nlev_inp), zeta_inp(i,j,1:nlev_inp), nlev_inp, iv(1:1), 0.6,0.85,0.5)
!       qc80_inp(1) = max(qc80_inp(1), 0.)
!       qc80_inp(1) = min(qc80_inp(1),1.5e-3)   ! to avoid excessive condensate 
!       call qsat_entropy(t80_inp(i,j),p80_inp(i,j),qsat,qsatw,qsati,esat,esatw,esati,fracw)
!       qcw80_inp=qc80_inp(1)*fracw
!       qci80_inp=qc80_inp(1)*(1.-fracw)
!
!       tvirt80_inp=t80_inp(i,j)*(1.+ep*q80_inp(i,j)-qc80_inp(1))
!
!       do k = 1,nlev_inp
!         if (zeta_inp(i,j,k) >= zeta80_inp(1)) then
!           k80m=k
!           exit
!         endif
!       enddo
!
!       do k = nlev_inp,k80m,-1
!         zeta_inp(i,j,k+1) = zeta_inp(i,j,k)
!         u_inp(i,j,k+1) = u_inp(i,j,k)
!         v_inp(i,j,k+1) = v_inp(i,j,k)
!         t_inp(i,j,k+1) = t_inp(i,j,k)
!         q_inp(i,j,k+1) = q_inp(i,j,k)
!         qc_inp(i,j,k+1) = qc_inp(i,j,k)
!         qcw_inp(i,j,k+1) = qcw_inp(i,j,k)
!         qci_inp(i,j,k+1) = qci_inp(i,j,k)
!         tvirt_inp(i,j,k+1) = tvirt_inp(i,j,k)
!       enddo
!
!       zeta_inp(i,j,k80m) = zeta80_inp(1)
!       u_inp(i,j,k80m) = u80_inp(i,j)
!       v_inp(i,j,k80m) = v80_inp(i,j)
!       t_inp(i,j,k80m) = t80_inp(i,j)
!       q_inp(i,j,k80m) = q80_inp(i,j)
!       qc_inp(i,j,k80m) = qc80_inp(1)
!       qcw_inp(i,j,k80m) = qcw80_inp
!       qci_inp(i,j,k80m) = qci80_inp
!       tvirt_inp(i,j,k80m) = tvirt80_inp
!
!     enddo
!   enddo
!
!   nlev_inp = nlev_inp+1
!
! endif

! Vertical velocity

 w_inp(:,:,:) = 0.

 if (ist == inst_start)  then
   allocate(fmask_inp_save(nlon_inp,nlat_inp))
   fmask_inp_save(:,:) = val_missing
 endif

 if (surf_elaborate) then

! Land-sea fraction

   if (any (int(field2d(:,:,3)) == int(val_missing)).and.any (int(field2d(:,:,46)) == int(val_missing)) ) then
     if (res_change /= 0) then
       print *,"The land-sea fraction field is missing in GFS input data in instant ",ist 
       print *,"but surface analysis has been required and grid resolution of GFS input data has changed"
       print *,"Stop"
       stop
     else
       if (any (int(fmask_inp_save(:,:)) == int(val_missing))) then
         print *,"The land-sea fraction field is missing in GFS input data in instant ",ist 
         print *,"but surface analysis has been required and this filed is not save from a previous instant"
         print *,"Stop"
         stop
       else
         fmask_inp(:,:) = fmask_inp_save(:,:)
       endif
     endif
   else
! Land-sea mask LANDN (coding discipline=2, category=0, parameter=218, index=46 here), valid
! after 19.07.2017, takes precedence over the "old" LAND (discipline=2, category=0,
! parameter=0, index=3 here), which is the standard land-sea mask to be used before 19.07.2017.
     if (all (int(field2d(:,:,3)) /= int(val_missing)) ) fmask_inp(1:nlon_inp0,:) = field2d(1:nlon_inp0,:,3)
     if (all (int(field2d(:,:,46)) /= int(val_missing)) ) fmask_inp(1:nlon_inp0,:) = field2d(1:nlon_inp0,:,46)
     if (nlon_inp0 /= nlon_inp) fmask_inp(nlon_inp,:) = fmask_inp(1,:)
     fmask_inp(:,:) = min(max(1.-fmask_inp(:,:),0.),1.) ! Conversion of FMASK: 0-sea, 1-land to 1-sea, 0-land
     deallocate(fmask_inp_save)
     allocate(fmask_inp_save(nlon_inp,nlat_inp))
     fmask_inp_save(:,:) = fmask_inp(:,:)
   endif

! Definition of meteorological fields declared in main program
! LIST TO BE CHECKED ! see subroutine read_grib2_data

! Soil temperature and soil water content

   if (nlevg_inp == 0) then
     print *,'No soil parameter data in input,'
     print *,'but surface analysis has been required, stop'
     stop
   endif

   do k=1,nlevg_inp
! Temperature
     iflag=1
     loop_j_tg: do j = 1,nlat_inp
       do i = 1,nlon_inp
         if (int(field3d_soil(i,j,k,1)) == int(val_missing).and.fmask_inp(i,j) < 1.e-7) then
           iflag=0
           exit loop_j_tg
         endif
       enddo
     enddo loop_j_tg
     if (iflag == 0) then 
       print *,'No soil temperature data in input at soil level ',soil_lev_inp(k)
       print *,'but surface analysis has been required, stop'
       stop
     else
       tg_inp(1:nlon_inp0,:,k) = field3d_soil(1:nlon_inp0,:,k,1)
     endif
! Water content
     iflag=1
     loop_j_qg: do j = 1,nlat_inp
       do i = 1,nlon_inp
         if (int(field3d_soil(i,j,k,2)) == int(val_missing).and.fmask_inp(i,j) < 1.e-7) then
           iflag=0
           exit loop_j_qg
         endif
       enddo
     enddo loop_j_qg
     if (iflag == 0) then 
       print *,'No soil water content data in input at soil level ',soil_lev_inp(k)
       print *,'but surface analysis has been required, stop'
       stop
     else
       qg_inp(1:nlon_inp0,:,k) = field3d_soil(1:nlon_inp0,:,k,2)
     endif
   enddo
   if (nlon_inp0 /= nlon_inp) then
     tg_inp(nlon_inp,:,:) = tg_inp(1,:,:)
     qg_inp(nlon_inp,:,:) = qg_inp(1,:,:)
   endif

! Surface temperature

   if (any (int(field2d(:,:,5)) == int(val_missing))) then
     print *,'      Attention:'
     print *,'No surface temperature data in input but surface analysis has been required'
   else
     tsurf_inp(1:nlon_inp0,:) = field2d(1:nlon_inp0,:,5)
     if (nlon_inp0 /= nlon_inp) tsurf_inp(nlon_inp,:) = tsurf_inp(1,:)
   endif

! Snow water content

   iflag=1
   loop_j_snow: do j = 1,nlat_inp
     do i = 1,nlon_inp
       if (int(field2d(i,j,14)) == int(val_missing).and.fmask_inp(i,j) < 1.e-7) then
         iflag=0
         exit loop_j_snow
       endif
     enddo
   enddo loop_j_snow
   if (iflag == 0) then 
     print *,'No data about water content in snow cover in input'
     print *,'but surface analysis has been required, stop'
     stop
   else
     do j = 1,nlat_inp
       do i = 1,nlon_inp0
         snow_inp(i,j) = max(0., field2d(i,j,14)*1.e-3) ! Conversion from kg m**-2 (mm) into m of water
       enddo
     enddo
     if (nlon_inp0 /= nlon_inp) snow_inp(nlon_inp,:) = snow_inp(1,:)
   endif

! Sea ice fraction and thickness

   iflag=1
   loop_j_fice: do j = 1,nlat_inp
     do i = 1,nlon_inp
       if (int(field2d(i,j,22)) == int(val_missing).and.fmask_inp(i,j) > 0.99) then
         iflag=0
         exit loop_j_fice
       endif
     enddo
   enddo loop_j_fice
   if (iflag == 0) then 
     print *,'      Attention:'
     print *,'No sea ice fraction data in input but surface analysis has been required'
   else
     fice_inp(1:nlon_inp0,:) = min( max( field2d(1:nlon_inp0,:,22), 0.), 1.)
     if (nlon_inp0 /= nlon_inp) fice_inp(nlon_inp,:) = fice_inp(1,:)
   endif

   iflag=1
   loop_j_iceth: do j = 1,nlat_inp
     do i = 1,nlon_inp
       if (int(field2d(i,j,26)) == int(val_missing).and.fmask_inp(i,j) > 0.99) then
         iflag=0
         exit loop_j_iceth
       endif
     enddo
   enddo loop_j_iceth
   if (iflag == 0) then 
     print *,'      Attention:'
     print *,'No sea ice thickness data in input but surface analysis has been required'
   else
     iceth_inp(1:nlon_inp0,:) = max( field2d(1:nlon_inp0,:,26), 0.)
     if (nlon_inp0 /= nlon_inp) iceth_inp(nlon_inp,:) = iceth_inp(1,:)
   endif

! Conversion of specific volumetric soil water content into relative soil humidity

! nst_inp - Number of soil types
! qgmin_inp_work- minimum volumetric water content (m**3/m**3)
! qgmax_inp_work - maximum (saturation, porosity) volumetric water conent (m**3/m**3)

! GFS (NOAA-NCEP) global model
! 0.470 is the max. water soil content ((m**3/m**3), this value has been
! empirically verified by data during period 01.06.2008-30.06.2009

   k1 = 1 ! soil type
   do k = 1,nlevg_inp
     do j = 1,nlat_inp
       do i = 1,nlon_inp
         qg_inp(i,j,k) = (qg_inp(i,j,k)-qgmin_inp_work(k1))/(qgmax_inp_work(k1)-qgmin_inp_work(k1))
       enddo
     enddo
   enddo

! Definition of temperature and soil water content in the case of missing data over the sea,

   do k = 1,nlevg_inp
     do j = 1,nlat_inp
       do i = 1,nlon_inp
         if (int(tg_inp(i,j,k))==int(val_missing)) tg_inp(i,j,k) = tsurf_inp(i,j)
         if (int(qg_inp(i,j,k))==int(val_missing)) qg_inp(i,j,k) = 0.50 ! to be used to define qg on small islands
       enddo
     enddo
   enddo

! --- Ad hoc corrections of some fields because of problems found in input data ----

   day1 = day+365.*0.5
   if (day1>365.) day1 = day1-365.

   do j = 1,nlat_inp
     do i = 1,nlon_inp

! Correction of apparent overestimation of water soil content in some areas:
! Calabria, Sicilia, Sardegna

! Sardegna

       if (alon_inp(i,j) > 8..and.alon_inp(i,j) < 10..and.alat_inp(i,j) > 38.8.and.alat_inp(i,j) < 41.15) then
         qg_inp(i,j,1)   = qg_inp(i,j,1)*.90*(1.-fmask_inp(i,j))
         qg_inp(i,j,2:nlevg_inp) = qg_inp(i,j,2:nlevg_inp)*.80*(1.-fmask_inp(i,j))
       endif

! Sicilia e Calabria

       if (alon_inp(i,j) > 12..and.alon_inp(i,j) < 17.2.and.alat_inp(i,j) > 36.5.and.alat_inp(i,j) < 39.1) then
         qg_inp(i,j,1)   = qg_inp(i,j,1)*.90*(1.-fmask_inp(i,j))
         qg_inp(i,j,2:nlevg_inp) = qg_inp(i,j,2:nlevg_inp)*.80*(1.-fmask_inp(i,j))
       endif

! Correction of the bias of soil T and Qrel (levels 1 to 4)

! CAUTION: the following corrections should be verified in time
! Last update Aug. 2009 (Oxana Drofa), after 1 year verification of soil T using
! Central Europe stations (July 2008) and comparison between GFS and ECMWF values
! (August 2009)
! Corrections for soil T are based on differences between GFS and observed values
! over Central Europe, and extended to other areas based on differences between GFS
! and ECMWF values (using data in the period 01.06.2008-30.06.2009)
! Corrections for soil moisture are based only on differences between GFS and ECMWF
! values (using data 01.06.2008-30.06.2009), assuming that ECMWF mean values are correct
! Corrections for T and water have been generalized to all latitudes (incl. SH) after
! bias was verified at different geographical zones
! Corrections in time based on analytical sinusoidal functions
! (describing annual and semi-annual periods - curve fitting of gnuplot used) -
! the correction amplitudes are the same for NH and SH, with time dependency anti-symmetric
! From comparison of soil T between ECMWF and GFS data in 2012 over Europe and Med., it seems that at
! least in the NH the sign of correction might even change over north Africa - therefore reduced
! correction (only a constant part - see below zdtg) is applied between about 35 deg. N and S

       if (alat_inp(i,j) >= 0.) then
         day2 = day    ! N. Hemis.
       else
         day2 = day1   ! S. Hemis.: time shift of half year
       endif

! Soil temperature

       zflatt  = 1.-exp(-(alat_inp(i,j)/32.)**2.)
       if (abs(alat_inp(i,j)).lt.39.) zflatt = zflatt*max((abs(alat_inp(i,j))-34.)/5., 0.)

       zdtg(1) = 0.5+zflatt*(0.25-0.63*cos((day2-11.0)/365.*2.*pi)+0.67*cos((day2+18.3)/365.*4.*pi))
       zdtg(2) = 1.3+zflatt*(1.19-3.77*cos((day2+ 8.1)/365.*2.*pi)+1.08*cos((day2+ 9.6)/365.*4.*pi))
       zdtg(3) = 0.8+zflatt*(1.63-4.11*cos((day2+ 3.3)/365.*2.*pi)+0.84*cos((day2+ 0.7)/365.*4.*pi))
       zdtg(4) = 0.8+zflatt*(1.51-3.97*cos((day2- 2.7)/365.*2.*pi)+0.61*cos((day2-10.5)/365.*4.*pi))

! Revision of T corrections after comparing BOLAM equil. values vs GFS (July 2016 - cumulative over the two above)
! Correction of atmospheric layers temp. as a function of zdtg eliminated (July 2016)

       zdtg(1) = 0.50*zdtg(1)
       zdtg(2) = 0.88*zdtg(2)
       zdtg(3) = 0.87*zdtg(3)
       zdtg(4) = 0.86*zdtg(4)
       if (alat_inp(i,j).lt.34.) zdtg(:) = 0.  ! July 2016: GFS soil T seems too high over Sahara

       tg_inp(i,j,1:4) = tg_inp(i,j,1:4)+zdtg(1:4)*(1.-fmask_inp(i,j))

! Correction of soil moisture depend. on latitude and season (larger reduction in summer, with also
! a latitudinal seasonal shift - but intended here only for the North Africa-Europe area)

       zf1 = cos((day2-35.0)/365.*2.*pi)
       zf2 = cos((day -35.0)/365.*2.*pi)

! Reduction of drying correction, larger at mid-high lat. (aug. 2014)

       zflatq = 0.5*(1.-0.65*(0.9-0.1*zf1)*exp(-((abs(alat_inp(i,j))-27.+2.5*(1.+zf2))/ 5.)**2.))  &
             +  0.5*(1.-0.65*(0.9-0.1*zf1)*exp(-((abs(alat_inp(i,j))-29.+2.5*(1.+zf2))/12.)**2.))
       zflatq = 0.5*zflatq + 0.5

      if (alat_inp(i,j) > 0.) then  ! if uncommented, excludes moisture correction in the South. Hemis.
        qg_inp(i,j,:) = zflatq*qg_inp(i,j,:)
      endif

     enddo
   enddo

   qg_inp(:,:,:) = max(min(qg_inp(:,:,:),1.),0.) ! reset to min-max of relative values

   print *
   print *, "Soil temperature and soil water content has been corrected"

 endif ! surf_elaborate

! Deallocation of internal work arrays

 deallocate (p_level_inp)
 deallocate (rh_inp)
 deallocate (p80_inp)
 deallocate (u80_inp)
 deallocate (v80_inp)
 deallocate (t80_inp)
 deallocate (q80_inp)
 deallocate (work_inp)

return
end
!------------------------------------------------------------------------------
subroutine conv_cosmo_data(ist)

! Procedure to convert meteorological fields derived from input files of COSMO (SIMC-APRAE)
!------------------------------------------------------------------------
! Procedure requests in input following parameters:
! nlev_inp  - atmospheric levels number in input data;
! nlevg_inp  - soil levels number in input data;
! nlon_inp  - grid point number of input data along x-axis;
! nlat_inp  - grid point number of input data along y-axis;
! lev_list_inp - 1d array with atmospheric level list of input data;
! soil_lev_inp - 1d array with soil level list of input data;
! field3d - 4d array with parameters at atmosphereic level;
! field3d_soil - 4d array with parameters at soil level;
! field2d - 3d array with parameters at the surface.
! idate0_inp - 1d array with date, time of simulation start or analysis
!
! Following parameters must be defined in output of this procedure:
! frame - logical flag: .false. - no frame in input data, .true. - frame in input data
! mask_frame - 2d ingeter array with flag of input data presence in a grid point,
! if no frame, then all values of mask_frame equal 1
! iperiod_inp - 1d array with simulation term
! fmask_inp - 2d array with sea-land fraction (1-sea, 0-land);
! ps_inp - 2d array with surface pressure (Pa) of input data;
! htop_inp - 2d array with topography hight (m) of input data;
! zeta_inp - 3d array with geometric altitude (m, over sea surface) of integer atmospheric levels of input data;
! zetah_inp - 3d array with geometric altitude (m, over sea surface) of half atmospheric levels of input data;
! p_inp - 3d array with pressure (Ps) at atmospheric levels of input data;
! t_inp - 3d array with temperature (K) at atmospheric levels of input data;
! u_inp - 3d array with u-component of wind (m/s) at atmospheric levels of input data;
! v_inp - 3d array with v-component of wind (m/s) at atmospheric levels of input data;
! q_inp - 3d array with specific humidity (kg/kg) at atmospheric levels of input data;
! qcw_inp - 3d array with specific cloud liquid water content (kg/kg) at atmospheric levels of input data;
! qci_inp - 3d array with specific cloud ice water content (kg/kg) at atmospheric levels of input data;
! tvirt_inp - 3d array with virtual temperature (K) at atmospheric levels of input data;
! w_inp - 3d array with vertical velocity (m/s) at atmospheric half-levels of input data;
! tg_inp - 3d array with temperature (m/s) at soil levels of input data;
! qg_inp - 3d array with relative soil water content (proportion) at soil levels of input data;
! snow_inp - 2d array with total water content of surface snow cover (kg/m^2);
! tsurf_inp - 2d array with surface temperature (K);
! qvsurf_inp - 2d array with specipic humidity (kg/kg) at the surface;
! fice_inp - 2d array with fraction of sea ice cover (proportion) at the surface;
! iceth_inp - 2d array with thickness of sea ice cover (m) at the surface.
! 
!------------------------------------------------------------------------

use parameters, only : ep, surf_elaborate, val_missing, inst_start
use input_data, alon_inp=>alon_t_inp, alat_inp=>alat_t_inp

implicit none

integer, parameter :: nlev_all_inp=45
real, dimension(nlev_all_inp+1) :: vert_coord_par1=(/22700.00, 21300.00, 19959.39, 18676.88, 17451.15, 16280.90, &
 15164.83, 14101.64, 13090.02, 12128.67, 11216.28, 10351.55, 9533.18,  8759.86,  8030.29,  7343.16,&
 6697.18,  6091.04, 5523.43, 4993.04,  4498.59,  4038.76,  3612.25,  3217.75,  2853.97, 2519.59, &
 2213.32,  1933.85,  1679.87,  1450.09,  1243.20,  1057.89,  892.87, 746.82,   618.45,   506.45, &
  409.51,  326.34,   255.63,  196.08, 146.37, 105.22,    71.30,    43.33,    20.00,     0.00/)
real, parameter :: vert_coord_par2=11430.

integer, save :: nlon_inp_old, nlat_inp_old
real, dimension(nlev_all_inp) :: zeta_all_level_inp
real, dimension(nlev_all_inp+1) :: zetah_all_level_inp
integer, dimension(:), allocatable :: h_level_inp
real, dimension(:,:,:), allocatable :: qgw_rel_inp, qgi_rel_inp

integer :: ist, i, j, k, k1, ind_field, iflag
real :: zqcmin=1.e-7

 mask_frame(:,:) = 1
 frame = .false.

! Control of grid resolution changing

 res_change = 0
 if(ist > inst_start .and.(nlon_inp /= nlon_inp_old.or.nlat_inp /= nlat_inp_old)) then
   print*
   print*, "The COSMO grid resolution has changed at instant: ist =", ist
   print*
   print*
   res_change = 1
 endif
 nlon_inp_old = nlon_inp
 nlat_inp_old = nlat_inp

 if (iperiod_inp_grib2(1)==1) then         ! Time unit is hour
   iperiod_inp(1) = iperiod_inp_grib2(2)/24                                     ! Days
   iperiod_inp(2) = iperiod_inp_grib2(2)-iperiod_inp(1)*24                      ! Hours
   iperiod_inp(3) = 0                                                           ! Minutes
 elseif (iperiod_inp_grib2(1)==0) then     ! Time unit is minute
   iperiod_inp(1) = iperiod_inp_grib2(2)/24/60                                  ! Days
   iperiod_inp(2) = (iperiod_inp_grib2(2)-iperiod_inp(1)*24*60)/60              ! Hours
   iperiod_inp(3) = iperiod_inp_grib2(2)-iperiod_inp(1)*24*60-iperiod_inp(2)*60 ! Minutes
 endif

! Allocation of internal work arrays

 allocate (h_level_inp(nlev_atm_inp_max))

! Atmospheric level definition

! If there are vertical velocity data in input data (at half-levels),
! then nlev_inp became number of half-levels and must be corrected

 if (int(field3d(1,1,1,10)) /= int(val_missing)) then
   nlev_inp = nlev_inp-1
 endif

 do k=1,nlev_inp
   k1=nlev_inp-k+1
   h_level_inp(k)  = int(lev_list_inp(k1))
 enddo

! Definition of hynbrid level number in input model

 do k = 1, nlev_all_inp+1
   ak(k) = vert_coord_par1(k)
   if (vert_coord_par1(k) >= vert_coord_par2) then
     bk(k) = 0.
   else
     bk(k) = (vert_coord_par2 - vert_coord_par1(k))/vert_coord_par2
   endif
 enddo

 if (ist == inst_start) then
   print*
   write(*,'(a,i3)') " Number of hybrid levels in input data ", nlev_inp
   if (nlev_inp /= nlev_all_inp) then
     print*, "Index of levels available (left col.) and COSMO hybrid level index (right col.)"
     do k = 1,nlev_inp
       print '(a,i3,a,i3)', '   ',k,'   ',h_level_inp(k)
     enddo
   endif
   print*
 endif

! For the case in which input data are defined only on frames:

 if (ist > inst_start) then
   print *
   ind_field = 2 ! Temperature at atm. levels in input data
   k = nlev_inp
   if (any(int(field3d(:,:,k,ind_field)) == int(val_missing))) then
     frame = .true.
     print *,'Input data fields defined only on frames'
     do j = 1,nlat_inp
     do i = 1,nlon_inp
       if (int(field3d(i,j,k,ind_field)) == int(val_missing)) then
         mask_frame(i,j) = 0
         field3d(i,j,:,:) = field3d(1,1,:,:)
         field3d_soil(i,j,:,:) = field3d_soil(1,1,:,:)
         field2d(i,j,:) = field2d(1,1,:)
       endif
     enddo
     enddo
   else
     print *,'Input data fields defined on full area (not on frames only)'
   endif
 endif

! Definition of meteorological fields declared in main program
! LIST TO BE CHECKED ! see subroutine read_grib2_data

! Surface pressure
 if (any(int(field2d(:,:,4)) == int(val_missing)) ) then
   print *,'No surface pressure data in input, stop'
   stop
 else
   ps_inp(:,:) = field2d(:,:,4)
 endif

 do k=1,nlev_inp
   k1=nlev_inp-k+1

! Temperature
   if (any(int(field3d(:,:,k,2)) == int(val_missing)) ) then
     print *,'No temperature data in input at level ',h_level_inp(k),', stop'
     stop
   else
     t_inp(:,:,k) = field3d(:,:,k1,2)
   endif
! U-component of wind
   if (any(int(field3d(:,:,k,3)) == int(val_missing)) ) then
     print *,'No data of U-component of wind in input at level ',h_level_inp(k),', stop'
     stop
   else
     u_inp(:,:,k) = field3d(:,:,k1,3)
   endif
! V-component of wind
   if (any(int(field3d(:,:,k,4)) == int(val_missing)) ) then
     print *,'No data of V-component of wind in input at level ',h_level_inp(k),', stop'
     stop
   else
     v_inp(:,:,k) = field3d(:,:,k1,4)
   endif
! Specific Hhumidity
   if (any(int(field3d(:,:,k,5)) == int(val_missing)) ) then
     print *,'No specific humidity data in input at level ',h_level_inp(k),', stop'
     stop
   else
     q_inp(:,:,k) = field3d(:,:,k1,5)
   endif
! Pressure
   if (any(int(field3d(:,:,k,11)) == int(val_missing)) ) then
     print *,'No pressure data in input at level ',h_level_inp(k),', stop'
     stop
   else
     p_inp(:,:,k) = field3d(:,:,k1,11)
   endif
! Cloud liquid water content
   if (any(int(field3d(:,:,k,8)) == int(val_missing)) ) then
     print *,'No cloud liquid water content data in input at level ',h_level_inp(k),', stop'
     stop
   else
     qcw_inp(:,:,k) = max( field3d(:,:,k1,8), 0.)
   endif
! Cloud ice water content
   if (any(int(field3d(:,:,k,9)) == int(val_missing)) ) then
     print *,'No cloud ice water content data in input at level ',h_level_inp(k),', stop'
     stop
   else
     qci_inp(:,:,k) = max( field3d(:,:,k1,9), 0.)
   endif

 enddo

! Vertical velocity at half-levels

 do k=1,nlev_inp+1
   k1=nlev_inp-k+2
   if (any(int(field3d(:,:,k,10)) == int(val_missing)) ) then
     if (k > 1) then
       print *,'No vertical velocity data in input at level ',h_level_inp(k),', stop'
     else
       print *,'No vertical velocity data in input at level ',h_level_inp(nlev_inp)+1,', stop'
     endif
     stop
   else
     w_inp(:,:,k) = field3d(:,:,k1,10)
   endif
 enddo

! Cloud water content

 qc_inp(:,:,:) = qcw_inp(:,:,:) + qci_inp(:,:,:)

! Control of specific humidity 

 q_inp(:,:,:) = max(q_inp(:,:,:), zqcmin)

! Definition of virtual temperature

 tvirt_inp(:,:,:)=t_inp(:,:,:)*(1.+ep*q_inp(:,:,:)-qc_inp(:,:,:))

! Definition of topography hight (htop_inp)

 if (ist == inst_start) then

   if (any (int(field2d(:,:,9)) == int(val_missing)) ) then
     print*, "The topography field is missing in COSMO input data in 1-st instant, stop"
     stop
   else
     htop_inp(:,:) = field2d(:,:,9)
     allocate (htop_inp_save(nlon_inp,nlat_inp))
     htop_inp_save(:,:) = htop_inp(:,:)
   endif

 else ! ist > inst_start

   if (res_change /= 0) then
     if (any (int(field2d(:,:,1)) == int(val_missing)) ) then
       print *,"Grid resolution of COSMO input data has changed at instant = ",ist
       print *,"but the topography field is missing in COSMO input data in this instant, stop"
       stop
     else
       htop_inp(:,:) = field2d(:,:,9)
       deallocate (htop_inp_save)
       allocate (htop_inp_save(nlon_inp,nlat_inp))
       htop_inp_save(:,:) = htop_inp(:,:)
     endif
   else
     htop_inp(:,:) = htop_inp_save(:,:)
   endif

 endif ! ist

! Definition of zeta at levels

 do j = 1,nlat_inp
   do i = 1,nlon_inp

! Compute the height of the model half-levels

     zetah_all_level_inp(nlev_all_inp+1) = htop_inp(i,j)

     do k = 1, nlev_all_inp
       zetah_all_level_inp(k) = ak(k) + bk(k)*zetah_all_level_inp(nlev_all_inp+1)
     enddo

! Compute the height of the model integer-levels

     do k = 1,nlev_all_inp
       zeta_all_level_inp(k) = (zetah_all_level_inp(k)+zetah_all_level_inp(k+1))*0.5
     enddo

     do k = 1,nlev_inp
       k1 = h_level_inp(k)
       zeta_inp(i,j,k) = zeta_all_level_inp(k1)
       zetah_inp(i,j,k+1) = zetah_all_level_inp(k1)
     enddo

     k=1
     k1=h_level_inp(1)+1
     zetah_inp(i,j,k) = zetah_all_level_inp(k1)

   enddo
 enddo

 if (ist == inst_start)  then
   allocate(fmask_inp_save(nlon_inp,nlat_inp))
   fmask_inp_save(:,:) = val_missing
 endif

 if (surf_elaborate) then

   allocate (qgw_rel_inp(nlon_inp,nlat_inp,nlevg_inp))
   allocate (qgi_rel_inp(nlon_inp,nlat_inp,nlevg_inp))

! Definition of meteorological fields declared in main program
! LIST TO BE CHECKED ! see subroutine read_grib2_data

! Land-sea fraction

   if (any (int(field2d(:,:,3)) == int(val_missing)) ) then
     if (res_change /= 0) then
       print *,"The land-sea fraction field is missing in COSMO input data in instant ",ist 
       print *,"but surface analysis has been required and grid resolution of COSMO input data has changed"
       print *,"Stop"
       stop
     else
       if (any (int(fmask_inp_save(:,:)) == int(val_missing))) then
         print *,"The land-sea fraction field is missing in IFS input data in instant ",ist 
         print *,"but surface analysis has been required and this filed is not save from a previous instant"
         print *,"Stop"
         stop
       else
         fmask_inp(:,:) = fmask_inp_save(:,:)
       endif
     endif
   else
     fmask_inp(:,:) = field2d(:,:,3)
     fmask_inp(:,:) = min(max(1.-fmask_inp(:,:),0.),1.) ! Conversion of FMASK: 0-sea, 1-land to 1-sea, 0-land
     deallocate(fmask_inp_save)
     allocate(fmask_inp_save(nlon_inp,nlat_inp))
     fmask_inp_save(:,:) = fmask_inp(:,:)
   endif

! Soil temperature and soil water content
! Note: in COSMO data soil water content is separated to liquid and frozen
! water content and are in the term of relative (!!!) content

   if (nlevg_inp == 0) then
     print *,'No soil parameter data in input,'
     print *,'but surface analysis has been required, stop'
     stop
   endif

   do k=1,nlevg_inp
! Temperature
     iflag=1
     loop_j_tg: do j = 1,nlat_inp
       do i = 1,nlon_inp
         if (int(field3d_soil(i,j,k,1)) == int(val_missing).and.fmask_inp(i,j) < 0.5) then
           iflag=0
           exit loop_j_tg
         endif
       enddo
     enddo loop_j_tg
     if (iflag == 0) then 
       print *,'No soil temperature data in input at soil level ',soil_lev_inp(k)
       print *,'but surface analysis has been required, stop'
       stop
     else
       tg_inp(:,:,k) = field3d_soil(:,:,k,1)
     endif
! Liquid relative water content
     iflag=1
     loop_j_qg: do j = 1,nlat_inp
       do i = 1,nlon_inp
         if (int(field3d_soil(i,j,k,3)) == int(val_missing).and.fmask_inp(i,j) < 0.5) then
           iflag=0
           exit loop_j_qg
         endif
       enddo
     enddo loop_j_qg
     if (iflag == 0) then 
       print *,'No soil liquid water content data in input at soil level ',soil_lev_inp(k)
       print *,'but surface analysis has been required, stop'
       stop
     else
       qgw_rel_inp(:,:,k) = field3d_soil(:,:,k,3)
     endif
! Frozen relative water content
     iflag=1
     loop_j_qgi: do j = 1,nlat_inp
       do i = 1,nlon_inp
         if (int(field3d_soil(i,j,k,4)) == int(val_missing).and.fmask_inp(i,j) < 0.5) then
           iflag=0
           exit loop_j_qgi
         endif
       enddo
     enddo loop_j_qgi
     if (iflag == 0) then 
       print *,'No soil frozen water content data in input at soil level ',soil_lev_inp(k)
       print *,'but surface analysis has been required, stop'
       stop
     else
       qgi_rel_inp(:,:,k) = field3d_soil(:,:,k,4)
     endif
   enddo

   qg_inp(:,:,1:nlevg_inp) = qgw_rel_inp(:,:,1:nlevg_inp) + qgi_rel_inp(:,:,1:nlevg_inp)

   qg_inp(:,:,:) = max(min(qg_inp(:,:,:),1.),0.) ! reset to min-max of relative values

! Redefinition of qg over input model sea to a value that defines
! a reasonable deep soil moisture for small islands appearing in open seas

   do j = 1,nlat_inp
   do i = 1,nlon_inp
     if (fmask_inp(i,j) >= 0.5.and.qg_inp(i,j,1) < 0.01) qg_inp(i,j,1:nlevg_inp) = 0.50
   enddo
   enddo

! Surface temperature

   if (any (int(field2d(:,:,5)) == int(val_missing))) then
     print *,'      Attention:'
     print *,'No surface temperature data in input but surface analysis has been required'
   else
     tsurf_inp(:,:) = field2d(:,:,5)
   endif

! Snow water content

   iflag=1
   loop_j_snow: do j = 1,nlat_inp
     do i = 1,nlon_inp
       if (int(field2d(i,j,14)) == int(val_missing).and.fmask_inp(i,j) < 1.e-7) then
         iflag=0
         exit loop_j_snow
       endif
     enddo
   enddo loop_j_snow
   if (iflag == 0) then 
     print *,'No data about water content in snow cover in input'
     print *,'but surface analysis has been required, stop'
     stop
   else
     do j = 1,nlat_inp
       do i = 1,nlon_inp
         snow_inp(i,j) = max(0., field2d(i,j,14)*1.e-3) ! Conversion from kg m**-2 (mm) into m of water
       enddo
     enddo
   endif

! Sea ice fraction and thikness

   iflag=1
   loop_j_fice: do j = 1,nlat_inp
     do i = 1,nlon_inp
       if (int(field2d(i,j,22)) == int(val_missing).and.fmask_inp(i,j) > 0.99) then
         iflag=0
         exit loop_j_fice
       endif
     enddo
   enddo loop_j_fice
   if (iflag == 0) then 
     print *,'      Attention:'
     print *,'No sea ice fraction data in input but surface analysis has been required'
     fice_inp(:,:) = 0.
   else
     fice_inp(:,:) = min( max( field2d(:,:,22), 0.), 1.)
   endif

   iflag=1
   loop_j_iceth: do j = 1,nlat_inp
     do i = 1,nlon_inp
       if (int(field2d(i,j,26)) == int(val_missing).and.fmask_inp(i,j) > 0.99) then
         iflag=0
         exit loop_j_iceth
       endif
     enddo
   enddo loop_j_iceth
   if (iflag == 0) then 
     print *,'      Attention:'
     print *,'No sea ice thickness data in input but surface analysis has been required'
     iceth_inp(:,:) = 0.
   else
     iceth_inp(:,:) = max( field2d(:,:,26), 0.)
   endif

   deallocate (qgw_rel_inp)
   deallocate (qgi_rel_inp)

 endif ! surf_elaborate

! Deallocation of internal work arrays

 deallocate (h_level_inp)

return
end
!------------------------------------------------------------------------------
subroutine wrec2 (kunit, nlon, nlat, vect)

implicit none

integer :: kunit, nlon, nlat
real, dimension(nlon,nlat) :: vect

 write(kunit) vect(1:nlon,1:nlat)

! call flush (kunit)

return
end subroutine wrec2
!------------------------------------------------------------------------------
subroutine wrec2_int (kunit, nlon, nlat, ivect)

implicit none

integer :: kunit, nlon, nlat
integer, dimension(nlon,nlat) :: ivect

 write(kunit) ivect(1:nlon,1:nlat)

! call flush (kunit)

return
end subroutine wrec2_int
!------------------------------------------------------------------------------
subroutine write_mhf_atm(nf)

! Writes a MHF file of MOLOCH with atmospheric variables

use model
implicit none

integer :: nf, iunit=32, i, j, k
character(len=30) :: file_output

 write (file_output,'(a,i2.2,a)') 'input_atm_',nf,'.mhf'

 open (iunit,file=file_output,form='unformatted')

 write (iunit) nfdr
 write (iunit) pdr

 do k = 1,nlev
   call wrec2 (iunit, nlon, nlat, p(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlev
   call wrec2 (iunit, nlon, nlat, u(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlev
   call wrec2 (iunit, nlon, nlat, v(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlev+1
   call wrec2 (iunit, nlon, nlat, w(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlev
   call wrec2 (iunit, nlon, nlat, t(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlev
   call wrec2 (iunit, nlon, nlat, q(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlev
   call wrec2 (iunit, nlon, nlat, qcw(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlev
   call wrec2 (iunit, nlon, nlat, qci(1:nlon,1:nlat,k))
 enddo

! flush (iunit)
 close (iunit)

 write (*,*)
 write (*,*) 'Output mhf file ',trim(file_output),' written'
 write (*,*)

#ifdef oper
!!! call system("ls -l -L "//file_output)
!!! call system("date")
 open  (iunit, file=trim(file_output)//'.txt', status='unknown')
 write (iunit,'(2a)') trim(file_output),' is full and closed'
 close (iunit)
#endif

return
end
!------------------------------------------------------------------------------
subroutine write_mhf_soil(nf)

! Writes a MHF file of MOLOCH with surface, sea, soil variables

use model
implicit none

integer :: nf, iunit=32, k, i, j, iwr
character(len=30) :: file_output
real, dimension(nlon,nlat) :: field2d_add, snow_albedo, runoff_tot

 snow_albedo(:,:) = 0.71
 runoff_tot(:,:) = 0.

 write (file_output,'(a,i2.2,a)') 'input_soil_',nf,'.mhf'

 open (iunit,file=file_output,form='unformatted')

 write(iunit) nfdr
 write(iunit) pdr

 call wrec2 (iunit, nlon, nlat, veg_lai(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, veg_frac(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, rgm(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, rgq(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, iceth(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, fice(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, albedo(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, emismap1(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, emismap2(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, cloudt(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, totpre(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, snfall(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, tsurf(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, tgsurf(1:nlon,1:nlat))

 do k = 1,nlevg
   call wrec2 (iunit, nlon, nlat, tg(1:nlon,1:nlat,k))
 enddo

 call wrec2 (iunit, nlon, nlat, qvsurf(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, qgsurf(1:nlon,1:nlat))

 do k = 1,nlevg
   call wrec2 (iunit, nlon, nlat, qg(1:nlon,1:nlat,k))
 enddo

 call wrec2 (iunit, nlon, nlat, fice_soil_surf(1:nlon,1:nlat))

 do k = 1,nlevg
   call wrec2 (iunit, nlon, nlat, fice_soil(1:nlon,1:nlat,k))
 enddo

 call wrec2 (iunit, nlon, nlat, snow(1:nlon,1:nlat))

 do k = 1,nlevsnow
   call wrec2 (iunit, nlon, nlat, snow_lev(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevsnow
   call wrec2 (iunit, nlon, nlat, snow_t(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevsnow
   call wrec2 (iunit, nlon, nlat, snow_fice(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevsnow
   call wrec2 (iunit, nlon, nlat, snow_age(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevsnow
   call wrec2 (iunit, nlon, nlat, snow_melt_age(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevsnow
   call wrec2 (iunit, nlon, nlat, snow_dens(1:nlon,1:nlat,k))
 enddo

 call wrec2 (iunit, nlon, nlat, snow_albedo(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, cswfl_down(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, cswfl(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, clwfl(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, chflux(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, cqflux(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, t2min(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, t2max(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, ws10max(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, runoff(1:nlon,1:nlat))
 call wrec2 (iunit, nlon, nlat, runoff_tot(1:nlon,1:nlat))

! Writing of additional 2D fields

 field2d_add(:,:) = 0.
 do iwr = 1,4
   call wrec2 (iunit, nlon, nlat, field2d_add(1:nlon,1:nlat))
 enddo

! flush (iunit)
 close (iunit)

 write (*,*)
 write (*,*) 'Output mhf file ',trim(file_output),' written'
 write (*,*)

#ifdef oper
!!! call system("ls -l -L "//file_output)
!!! call system("date")
 open  (iunit, file=trim(file_output)//'.txt', status='unknown')
 write (iunit,'(2a)') trim(file_output),' is full and closed'
 close (iunit)
#endif

return
end
!------------------------------------------------------------------------------
subroutine write_param_const_old

! Writes an additional output file with all constant (in time)
! model physiographical parameters

use model, only : nlon, nlat, nlevg, nlevsnow, x0, y0, alon0, alat0, dlon, dlat, &
 phig, htopvar, fmask, rgm, rgq, soil_map, veg_map, &
 soil_qmax, soil_qmin, soil_c, soil_rho, soil_psi, soil_k, soil_par_b, soil_par_c, soil_qrel_wilt, soil_qrel_ref, &
 soil_albedo_dry, soil_albedo_wet, soil_emiss1_dry, soil_emiss1_wet, soil_emiss2_dry, soil_emiss2_wet, &
 veg_lai, veg_frac, veg_root_depth, veg_roughness, veg_albedo, veg_emiss1, veg_emiss2, &
 ind_lev_soil_h_bottom, ind_lev_soil_w_bottom, veg_lai_max, snow_dirt
use parameters, only : nst, nvt, g0

implicit none
integer :: iunit=60, i, j, k, iwr
character(len=30) :: file_output="model_param_constant.bin"

 open (iunit,file=file_output,form='unformatted')

 write (iunit) nlon, nlat, nlevg, dlon, dlat, x0, y0, alon0, alat0+dlat*0.5, nst, nvt

 do j = 1,nlat
   write(iunit) (fmask(i,j),i=1,nlon)
 enddo

 do j = 1,nlat
   write(iunit) (phig(i,j)/g0,i=1,nlon)
 enddo

 do j = 1,nlat
   write(iunit) (htopvar(i,j),i=1,nlon)
 enddo

 do k = 1,nst+1
   do j = 1,nlat
     write(iunit) (soil_map(i,j,k),i=1,nlon)
   enddo
 enddo

 do k = 1,nvt+1
   do j = 1,nlat
     write(iunit) (veg_map(i,j,k),i=1,nlon)
   enddo
 enddo

 do k = 1,nlevg
   do j = 1,nlat
     write(iunit) (soil_qmax(i,j,k),i=1,nlon)
   enddo
 enddo

 do k = 1,nlevg
   do j = 1,nlat
     write(iunit) (soil_qmin(i,j,k),i=1,nlon)
   enddo
 enddo

 do k = 1,nlevg
   do j = 1,nlat
     write(iunit) (soil_c(i,j,k),i=1,nlon)
   enddo
 enddo

 do k = 1,nlevg
   do j = 1,nlat
     write(iunit) (soil_rho(i,j,k),i=1,nlon)
   enddo
 enddo

 do k = 1,nlevg
   do j = 1,nlat
     write(iunit) (soil_psi(i,j,k),i=1,nlon)
   enddo
 enddo

 do k = 1,nlevg
   do j = 1,nlat
     write(iunit) (soil_k(i,j,k),i=1,nlon)
   enddo
 enddo

 do k = 1,nlevg
   do j = 1,nlat
     write(iunit) (soil_par_b(i,j,k),i=1,nlon)
   enddo
 enddo

 do k = 1,nlevg
   do j = 1,nlat
     write(iunit) (soil_par_c(i,j,k),i=1,nlon)
   enddo
 enddo

 do k = 1,nlevg
   do j = 1,nlat
     write(iunit) (soil_qrel_wilt(i,j,k),i=1,nlon)
   enddo
 enddo

 do k = 1,nlevg
   do j = 1,nlat
     write(iunit) (soil_qrel_ref(i,j,k),i=1,nlon)
   enddo
 enddo

 do j = 1,nlat
   write(iunit) (soil_albedo_dry(i,j),i=1,nlon)
 enddo

 do j = 1,nlat
   write(iunit) (soil_albedo_wet(i,j),i=1,nlon)
 enddo

 do j = 1,nlat
   write(iunit) (soil_emiss1_dry(i,j),i=1,nlon)
 enddo

 do j = 1,nlat
   write(iunit) (soil_emiss1_wet(i,j),i=1,nlon)
 enddo

 do j = 1,nlat
   write(iunit) (soil_emiss2_dry(i,j),i=1,nlon)
 enddo

 do j = 1,nlat
   write(iunit) (soil_emiss2_wet(i,j),i=1,nlon)
 enddo

 do j = 1,nlat
   write(iunit) (veg_root_depth(i,j),i=1,nlon)
 enddo

 do j = 1,nlat
   write(iunit) (veg_roughness(i,j),i=1,nlon)
 enddo

 do j = 1,nlat
   write(iunit) (veg_albedo(i,j),i=1,nlon)
 enddo

 do j = 1,nlat
   write(iunit) (veg_emiss1(i,j),i=1,nlon)
 enddo

 do j = 1,nlat
   write(iunit) (veg_emiss2(i,j),i=1,nlon)
 enddo

 do j = 1,nlat
   write(iunit) (ind_lev_soil_h_bottom(i,j),i=1,nlon)
 enddo

 do j = 1,nlat
   write(iunit) (ind_lev_soil_w_bottom(i,j),i=1,nlon)
 enddo

 do j = 1,nlat
   write(iunit) (snow_dirt(i,j),i=1,nlon)
 enddo

 write(iunit) veg_lai_max

 flush (iunit)
 close (iunit)

 write (*,*)
 write (*,*) 'Output file ',trim(file_output),' written'
 write (*,*)

#ifdef oper
!!! call system("ls -l -L "//file_output)
!!! call system("date")
 open  (iunit, file=trim(file_output)//'.txt', status='unknown')
 write (iunit,'(2a)') trim(file_output),' is full and closed'
 close (iunit)
#endif

return
end
!------------------------------------------------------------------------------
subroutine write_param_const

! Writes an additional output file with all constant (in time)
! model physiographical parameters

use model, only : nlon, nlat, nlevg, nlevsnow, x0, y0, alon0, alat0, dlon, dlat, &
 phig, htopvar, fmask, rgm, rgq, soil_map, veg_map, &
 soil_qmax, soil_qmin, soil_c, soil_rho, soil_psi, soil_k, soil_par_b, soil_par_c, soil_qrel_wilt, soil_qrel_ref, &
 soil_albedo_dry, soil_albedo_wet, soil_emiss1_dry, soil_emiss1_wet, soil_emiss2_dry, soil_emiss2_wet, &
 water_table_depth, tg_bottom, qg_rel_bottom, qg_rel_surf_approx, &
 veg_lai, veg_frac, veg_root_depth, veg_roughness, veg_albedo, veg_emiss1, veg_emiss2, &
 ind_lev_soil_h_bottom, ind_lev_soil_w_bottom, veg_lai_max, snow_dirt
use parameters, only : nst, nvt, g0

implicit none
integer :: iunit=60, i, j, k, iwr
character(len=30) :: file_output="model_param_constant.bin"

 open (iunit,file=file_output,form='unformatted')

 write (iunit) nlon, nlat, nlevg, dlon, dlat, x0, y0, alon0, alat0+dlat*0.5, nst, nvt

 call wrec2 (iunit, nlon, nlat, fmask(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, phig(1:nlon,1:nlat)/g0)

 call wrec2 (iunit, nlon, nlat, htopvar(1:nlon,1:nlat))

 do k = 1,nst+1
   call wrec2 (iunit, nlon, nlat, soil_map(1:nlon,1:nlat,k))
 enddo

 do k = 1,nvt+1
   call wrec2 (iunit, nlon, nlat, veg_map(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevg
   call wrec2 (iunit, nlon, nlat, soil_qmax(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevg
   call wrec2 (iunit, nlon, nlat, soil_qmin(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevg
   call wrec2 (iunit, nlon, nlat, soil_c(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevg
   call wrec2 (iunit, nlon, nlat, soil_rho(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevg
   call wrec2 (iunit, nlon, nlat, soil_psi(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevg
   call wrec2 (iunit, nlon, nlat, soil_k(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevg
   call wrec2 (iunit, nlon, nlat, soil_par_b(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevg
   call wrec2 (iunit, nlon, nlat, soil_par_c(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevg
   call wrec2 (iunit, nlon, nlat, soil_qrel_wilt(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevg
   call wrec2 (iunit, nlon, nlat, soil_qrel_ref(1:nlon,1:nlat,k))
 enddo

 call wrec2 (iunit, nlon, nlat, soil_albedo_dry(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, soil_albedo_wet(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, soil_emiss1_dry(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, soil_emiss1_wet(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, soil_emiss2_dry(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, soil_emiss2_wet(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, veg_root_depth(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, veg_roughness(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, veg_albedo(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, veg_emiss1(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, veg_emiss2(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, water_table_depth(1:nlon,1:nlat))
 
 call wrec2 (iunit, nlon, nlat, tg_bottom(1:nlon,1:nlat))
 
 call wrec2 (iunit, nlon, nlat, qg_rel_bottom(1:nlon,1:nlat))
 
 call wrec2 (iunit, nlon, nlat, qg_rel_surf_approx(1:nlon,1:nlat))

 call wrec2_int (iunit, nlon, nlat, ind_lev_soil_h_bottom(1:nlon,1:nlat))

 call wrec2_int (iunit, nlon, nlat, ind_lev_soil_w_bottom(1:nlon,1:nlat))

 call wrec2 (iunit, nlon, nlat, snow_dirt(1:nlon,1:nlat))

 write(iunit) veg_lai_max

 flush (iunit)
 close (iunit)

 write (*,*)
 write (*,*) 'Output file ',trim(file_output),' written'
 write (*,*)

#ifdef oper
!!! call system("ls -l -L "//file_output)
!!! call system("date")
 open  (iunit, file=trim(file_output)//'.txt', status='unknown')
 write (iunit,'(2a)') trim(file_output),' is full and closed'
 close (iunit)
#endif

return
end
!------------------------------------------------------------------------------
subroutine read_param_const(flag_data)

! Reads input file with all constant (in time)
! model physiographical parameters

use model, only : nlon, nlat, nlevg, nlevsnow, x0, y0, alon0, alat0, dlon, dlat, &
 phig, htopvar, fmask, rgm, rgq, soil_map, veg_map, &
 water_table_depth, tg_bottom, qg_rel_bottom, qg_rel_surf_approx, &
 soil_qmax, soil_qmin, soil_c, soil_rho, soil_psi, soil_k, soil_par_b, soil_par_c, soil_qrel_wilt, soil_qrel_ref, &
 soil_albedo_dry, soil_albedo_wet, soil_emiss1_dry, soil_emiss1_wet, soil_emiss2_dry, soil_emiss2_wet, &
 veg_lai, veg_frac, veg_root_depth, veg_roughness, veg_albedo, veg_emiss1, veg_emiss2, &
 ind_lev_soil_h_bottom, ind_lev_soil_w_bottom, veg_lai_max, snow_dirt
use parameters, only : nst, nvt, g0

implicit none
integer :: flag_data, iunit=60, &
 nlon_read, nlat_read, nlevg_read, nst_read, nvt_read, ierr_open, flag, ird, k 
real :: x0_read, y0_read, alon0_read, alat0_read, dlon_read, dlat_read
character(len=30) :: file_data="model_param_constant.bin"

 flag_data=0

 open (iunit, file=file_data, form='unformatted', status='old', iostat=ierr_open)

 if (ierr_open /= 0) then
   flag_data=1
   return
 endif

 read (iunit) nlon_read, nlat_read, nlevg_read, dlon_read, dlat_read, x0_read, y0_read, alon0_read, alat0_read, nst_read, nvt_read

 flag=1
 if (nlon_read /= nlon) flag=0
 if (nlat_read /= nlat) flag=0
 if (nlevg_read /= nlevg) flag=0
 if (abs(dlon_read-dlon) > 1.e-4) flag=0
 if (abs(dlat_read-dlat) > 1.e-4) flag=0
 if (abs(x0_read-x0) > 1.e-4) flag=0
 if (abs(y0_read-y0) > 1.e-4) flag=0
 if (abs(alon0_read-alon0) > 1.e-4) flag=0
 if (abs(alat0_read-(alat0+dlat*0.5)) > 1.e-4) flag=0

 if (flag == 0) then
   write (*,*)
   write (*,*) "Error in header parameters in input file ,",trim(file_data),", not coincident with defined parameters"
   write (*,*) "Model nlon, nlat, nlevg, dlon, dlat, x0, y0, alon0, alat0 :", &
 nlon, nlat, nlevg, dlon, dlat, x0, y0, alon0, alat0
   write (*,*)"Read nlon, nlat, nlevg, dlon, dlat, x0, y0, alon0, alat0 :", &
 nlon_read, nlat_read, nlevg_read, dlon_read, dlat_read, x0_read, y0_read, alon0_read, alat0_read
   write (*,*) "File with constant model parameter fields is erroneous and not will be used"
   write (*,*)
   flag_data=1
   return
 endif

 call rrec2 (iunit, nlon, nlat, fmask(1:nlon,1:nlat))

 call rrec2 (iunit, nlon, nlat, phig(1:nlon,1:nlat))

 call rrec2 (iunit, nlon, nlat, htopvar(1:nlon,1:nlat))

 do k = 1,nst+1
   call rrec2 (iunit, nlon, nlat, soil_map(1:nlon,1:nlat,k))
 enddo

 do k = 1,nvt+1
   call rrec2 (iunit, nlon, nlat, veg_map(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevg
   call rrec2 (iunit, nlon, nlat, soil_qmax(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevg
   call rrec2 (iunit, nlon, nlat, soil_qmin(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevg
   call rrec2 (iunit, nlon, nlat, soil_c(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevg
   call rrec2 (iunit, nlon, nlat, soil_rho(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevg
   call rrec2 (iunit, nlon, nlat, soil_psi(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevg
   call rrec2 (iunit, nlon, nlat, soil_k(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevg
   call rrec2 (iunit, nlon, nlat, soil_par_b(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevg
   call rrec2 (iunit, nlon, nlat, soil_par_c(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevg
   call rrec2 (iunit, nlon, nlat, soil_qrel_wilt(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevg
   call rrec2 (iunit, nlon, nlat, soil_qrel_ref(1:nlon,1:nlat,k))
 enddo

 call rrec2 (iunit, nlon, nlat, soil_albedo_dry(1:nlon,1:nlat))

 call rrec2 (iunit, nlon, nlat, soil_albedo_wet(1:nlon,1:nlat))

 call rrec2 (iunit, nlon, nlat, soil_emiss1_dry(1:nlon,1:nlat))

 call rrec2 (iunit, nlon, nlat, soil_emiss1_wet(1:nlon,1:nlat))

 call rrec2 (iunit, nlon, nlat, soil_emiss2_dry(1:nlon,1:nlat))

 call rrec2 (iunit, nlon, nlat, soil_emiss2_wet(1:nlon,1:nlat))

 call rrec2 (iunit, nlon, nlat, veg_root_depth(1:nlon,1:nlat))

 call rrec2 (iunit, nlon, nlat, veg_roughness(1:nlon,1:nlat))

 call rrec2 (iunit, nlon, nlat, veg_albedo(1:nlon,1:nlat))

 call rrec2 (iunit, nlon, nlat, veg_emiss1(1:nlon,1:nlat))

 call rrec2 (iunit, nlon, nlat, veg_emiss2(1:nlon,1:nlat))

 call rrec2 (iunit, nlon, nlat, water_table_depth(1:nlon,1:nlat))

 call rrec2 (iunit, nlon, nlat, tg_bottom(1:nlon,1:nlat))

 call rrec2 (iunit, nlon, nlat, qg_rel_bottom(1:nlon,1:nlat))

 call rrec2 (iunit, nlon, nlat, qg_rel_surf_approx(1:nlon,1:nlat))

 call rrec2_int (iunit, nlon, nlat, ind_lev_soil_h_bottom(1:nlon,1:nlat))

 call rrec2_int (iunit, nlon, nlat, ind_lev_soil_w_bottom(1:nlon,1:nlat))

 call rrec2 (iunit, nlon, nlat, snow_dirt(1:nlon,1:nlat))

 read (iunit) veg_lai_max

 close (iunit)

 write (*,*)
 write (*,*) 'File with model constant parameter fields ',trim(file_data),' read'
 write (*,*)

return
end
!------------------------------------------------------------------------------
subroutine rrec2 (kunit, nlon, nlat, vect)

implicit none

integer :: kunit, nlon, nlat
real, dimension(nlon,nlat) :: vect

 read(kunit) vect(1:nlon,1:nlat)

return
end subroutine rrec2
!------------------------------------------------------------------------------
subroutine rrec2_int (kunit, nlon, nlat, ivect)

implicit none

integer :: kunit, nlon, nlat
integer, dimension(nlon,nlat) :: ivect

 read(kunit) ivect(1:nlon,1:nlat)

return
end subroutine rrec2_int
!------------------------------------------------------------------------------
subroutine read_forecast_mhf_soil_old(iflag)

! Reads a MHF file of MOLOCH with surface and soil variables 
! simulated by a forecast run with siutable validity date and hour

use model, only : nlon, nlat, nlevg, nlevsnow, nfdr, pdr, &
 iceth, fice, tsurf, tgsurf, tg, qvsurf, qgsurf, qg, fice_soil_surf, fice_soil, &
 snow, snow_lev, snow_t, snow_fice, snow_age, snow_melt_age, snow_dens, &
 iceth_frc, fice_frc, tsurf_frc, tgsurf_frc, tg_frc, qvsurf_frc, qgsurf_frc, qg_frc, fice_soil_surf_frc, fice_soil_frc, &
 snow_frc, snow_lev_frc, snow_t_frc, snow_fice_frc, snow_age_frc, snow_melt_age_frc, snow_dens_frc

implicit none

integer :: iflag, iunit=11, iopen_err=0, iread=0, iread_err=0, iflag_found=0, ird, ierr=0, i, j, k, ndayr, &
 iniyear, inimonth, iniday, inihour, iniminute, &
 year_frc, month_frc, day_frc, hour_frc, minute_frc
character(len=30) :: file_inp="moloch_forecast_soil.mhf",str_date0,str_frc_term,str_date_frc
integer, dimension(50) :: nfdr_frc
real, dimension(100)   :: pdr_frc
real, dimension(nlon,nlat) :: field2d_add, snow_albedo_rfc, runoff_tot_frc

 iflag=1

 open (iunit,file=file_inp,form='unformatted',status='old',iostat=iopen_err)

 if (iopen_err /= 0) then
   write (*,*)
   write (*,*) '   Not found file ',trim(file_inp),' with forecast surface, soil and snow data' 
   write (*,*)
   iflag=0
   return
 else
   write (*,*)
   write (*,*) '   Reading on unit ',iunit,' file ',trim(file_inp),&
 ' with forecast surface, soil and snow data, variables redefinition' 
   write (*,*)
 endif

 read(iunit) nfdr_frc
 read(iunit) pdr_frc

 ierr=0
 if (nfdr_frc(2) /= nfdr(2)) ierr=ierr+1 ! nlon
 if (nfdr_frc(3) /= nfdr(3)) ierr=ierr+1 ! nlat
 if (nfdr_frc(15) /= nfdr(15)) ierr=ierr+1 ! nlevg
 if (pdr_frc(2) /= pdr(2)) ierr=ierr+1 ! dlon
 if (pdr_frc(1) /= pdr(1)) ierr=ierr+1 ! dlat
 if (pdr_frc(39) /= pdr(39)) ierr=ierr+1 ! x0
 if (pdr_frc(38) /= pdr(38)) ierr=ierr+1 ! y0
 if (pdr_frc(5) /= pdr(5)) ierr=ierr+1 ! alon0
 if (pdr_frc(4) /= pdr(4)) ierr=ierr+1 ! alat0

 if (ierr /= 0) then
   write (*,*)
   write (*,*) "Error in header parameters in input file ,",trim(file_inp),", not coincident with defined parameters"
   write (*,*) "Model nlon, nlat, nlevg, dlon, dlat, x0, y0, alon0, alat0 :", &
 nfdr(2), nfdr(3), nfdr(15), pdr(2), pdr(1), pdr(39), pdr(38), pdr(5), pdr(4)
   write (*,*)"Read nlon, nlat, nlevg, dlon, dlat, x0, y0, alon0, alat0 :", &
 nfdr_frc(2), nfdr_frc(3), nfdr_frc(15), pdr_frc(2), pdr_frc(1), pdr_frc(39), pdr_frc(38), pdr_frc(5), pdr_frc(4)
   write (*,*)
   iflag=0
   return
 endif

 rewind (iunit)

 do while (.true.)

   iread=iread+1

   read(iunit,iostat=iread_err) nfdr_frc

   if (iread_err == 0) then

     read(iunit) pdr_frc

     call calendar (nfdr(5), nfdr(6), nfdr(7), nfdr(8), nfdr(9), nfdr(10), nfdr(11), nfdr(12), &
 iniyear, inimonth, iniday, inihour, iniminute, ndayr)

     call calendar (nfdr_frc(5), nfdr_frc(6), nfdr_frc(7), nfdr_frc(8), nfdr_frc(9), nfdr_frc(10), nfdr_frc(11), nfdr_frc(12), &
 year_frc, month_frc, day_frc, hour_frc, minute_frc, ndayr)

     if (iread == 1) then
       write (*,*)
       write (*,*) "In input ",trim(file_inp)," the following data found:"
       write (*,*) "Initialisation date and time (year, month, day, hour, minute): ", nfdr_frc(5:9)
     endif
     write (*,*) "Forecast validation date and time (year, month, day, hour, minute): ", & 
 year_frc, month_frc, day_frc, hour_frc, minute_frc

     ierr=0
     if (year_frc /= iniyear) ierr=ierr+1
     if (month_frc /= inimonth) ierr=ierr+1
     if (day_frc /= iniday) ierr=ierr+1
!DANIELE!     if (hour_frc /= inihour) ierr=ierr+1
!DANIELE!     if (minute_frc /= iniminute) ierr=ierr+1

     if (ierr /= 0) then

! Read all data of single check-off

       do ird=1,14
         do j = 1,nlat
           read(iunit) (field2d_add(i,j),i=1,nlon)
         enddo
       enddo
       do k=1,nlevg
         do j = 1,nlat
           read(iunit) (field2d_add(i,j),i=1,nlon)
         enddo
       enddo
       do ird=1,2
         do j = 1,nlat
           read(iunit) (field2d_add(i,j),i=1,nlon)
         enddo
       enddo
       do k=1,nlevg
         do j = 1,nlat
           read(iunit) (field2d_add(i,j),i=1,nlon)
         enddo
       enddo
       do ird=1,1
         do j = 1,nlat
           read(iunit) (field2d_add(i,j),i=1,nlon)
         enddo
       enddo
       do k=1,nlevg
         do j = 1,nlat
           read(iunit) (field2d_add(i,j),i=1,nlon)
         enddo
       enddo
       do ird=1,1
         do j = 1,nlat
           read(iunit) (field2d_add(i,j),i=1,nlon)
         enddo
       enddo
       do ird=1,6
         do k=1,nlevsnow
           do j = 1,nlat
             read(iunit) (field2d_add(i,j),i=1,nlon)
           enddo
         enddo
       enddo
       do ird = 1,15 ! Snow albedo, CSWFl, CLWFl, CHFlux, CQFlux, T2Min, T2Max, WS10Max, Runoff, Runoff total, CHFluxbottom, CWVflux, Wfluxbottom, LevSnowfall, 1 empty
         do j = 1,nlat
           read(iunit) (field2d_add(i,j),i=1,nlon)
         enddo
       enddo

     else

! Found proper data and time of forecast validation
       iflag=1
       exit

     endif

   else ! iread_err /= 0

     write (*,*)
     write (*,*) "Not found proper data and time of forecast validation in input file ",trim(file_inp) 
     write (*,*)
     iflag=0
     return

   endif ! iread_err

 enddo  

 write (str_date0,'(4(i2.2,a),i4.4)') nfdr_frc(8),':',nfdr_frc(9),' ',nfdr_frc(7),'/',nfdr_frc(6),'/',nfdr_frc(5)
 write (str_frc_term,'(a,i3,a,2(i2,a))') '+',nfdr_frc(10),'day ',nfdr_frc(11),'hour ',nfdr_frc(12),'minute'
 write (str_date_frc,'(4(i2.2,a),i4.4)') hour_frc,':',minute_frc,' ',day_frc,'/',month_frc,'/',year_frc

 do ird=1,4 ! veg_lai, veg_frac, rgm, rgq
   do j = 1,nlat
     read(iunit) (field2d_add(i,j),i=1,nlon)
   enddo
 enddo

 do j = 1,nlat
   read(iunit) (iceth_frc(i,j),i=1,nlon)
 enddo
 do j = 1,nlat
   read(iunit) (fice_frc(i,j),i=1,nlon)
 enddo

 do ird=1,6 ! albedo, emismap1, emismap2, cloudt, totpre, snfall
   do j = 1,nlat
     read(iunit) (field2d_add(i,j),i=1,nlon)
   enddo
 enddo

 do j = 1,nlat
   read(iunit) (tsurf_frc(i,j),i=1,nlon)
 enddo
 do j = 1,nlat
   read(iunit) (tgsurf_frc(i,j),i=1,nlon)
 enddo
 do k = 1,nlevg
   do j = 1,nlat
     read(iunit) (tg_frc(i,j,k),i=1,nlon)
   enddo
 enddo
 do j = 1,nlat
   read(iunit) (qvsurf_frc(i,j),i=1,nlon)
 enddo
 do j = 1,nlat
   read(iunit) (qgsurf_frc(i,j),i=1,nlon)
 enddo
 do k = 1,nlevg
   do j = 1,nlat
     read(iunit) (qg_frc(i,j,k),i=1,nlon)
   enddo
 enddo
 do j = 1,nlat
   read(iunit) (fice_soil_surf_frc(i,j),i=1,nlon)
 enddo
 do k = 1,nlevg
   do j = 1,nlat
     read(iunit) (fice_soil_frc(i,j,k),i=1,nlon)
   enddo
 enddo
 do j = 1,nlat
   read(iunit) (snow_frc(i,j),i=1,nlon)
 enddo
 do k = 1,nlevsnow
   do j = 1,nlat
     read(iunit) (snow_lev_frc(i,j,k),i=1,nlon)
   enddo
 enddo
 do k = 1,nlevsnow
   do j = 1,nlat
     read(iunit) (snow_t_frc(i,j,k),i=1,nlon)
   enddo
 enddo
 do k = 1,nlevsnow
   do j = 1,nlat
     read(iunit) (snow_fice_frc(i,j,k),i=1,nlon)
   enddo
 enddo
 do k = 1,nlevsnow
   do j = 1,nlat
     read(iunit) (snow_age_frc(i,j,k),i=1,nlon)
   enddo
 enddo
 do k = 1,nlevsnow
   do j = 1,nlat
     read(iunit) (snow_melt_age_frc(i,j,k),i=1,nlon)
   enddo
 enddo
 do k = 1,nlevsnow
   do j = 1,nlat
     read(iunit) (snow_dens_frc(i,j,k),i=1,nlon)
   enddo
 enddo

! do ird=1,13 ! snow_albedo, cswfl, clwfl, chflux, cqflux, t2min, t2max, ws10max, runoff, runoff_tot, 3 additional 2D fields 
!   do j = 1,nlat
!     read(iunit) (field2d_add(i,j),i=1,nlon)
!   enddo
! enddo

 close (iunit)

 write (*,*)
 write (*,*) "Soil and snow prognostic parameters (temperature, water content, ect.) values"
 write (*,*) "are read from forecast output data of run start"
 write (*,*) trim(str_date0)," forcast term ",trim(str_frc_term)," valid ",trim(str_date_frc)

return
end
!------------------------------------------------------------------------------
subroutine read_forecast_mhf_soil(iflag)

! Reads a MHF file of MOLOCH with surface and soil variables 
! simulated by a forecast run with siutable validity date and hour

use model, only : nlon, nlat, nlevg, nlevsnow, nfdr, pdr, &
 iceth, fice, tsurf, tgsurf, tg, qvsurf, qgsurf, qg, fice_soil_surf, fice_soil, &
 snow, snow_lev, snow_t, snow_fice, snow_age, snow_melt_age, snow_dens, &
 iceth_frc, fice_frc, tsurf_frc, tgsurf_frc, tg_frc, qvsurf_frc, qgsurf_frc, qg_frc, fice_soil_surf_frc, fice_soil_frc, &
 snow_frc, snow_lev_frc, snow_t_frc, snow_fice_frc, snow_age_frc, snow_melt_age_frc, snow_dens_frc

implicit none

integer :: iflag, iunit=11, iopen_err=0, iread=0, iread_err=0, iflag_found=0, ird, ierr=0, i, j, k, ndayr, &
 iniyear, inimonth, iniday, inihour, iniminute, &
 year_frc, month_frc, day_frc, hour_frc, minute_frc
character(len=30) :: file_inp="moloch_forecast_soil.mhf",str_date0,str_frc_term,str_date_frc
integer, dimension(50) :: nfdr_frc
real, dimension(100)   :: pdr_frc
real, dimension(nlon,nlat) :: field2d_add, snow_albedo_rfc, runoff_tot_frc

 iflag=1

 open (iunit,file=file_inp,form='unformatted',status='old',iostat=iopen_err)

 if (iopen_err /= 0) then
   write (*,*)
   write (*,*) '   Not found file ',trim(file_inp),' with forecast surface, soil and snow data' 
   write (*,*)
   iflag=0
   return
 else
   write (*,*)
   write (*,*) '   Reading on unit ',iunit,' file ',trim(file_inp),&
 ' with forecast surface, soil and snow data, variables redefinition' 
   write (*,*)
 endif

 read(iunit) nfdr_frc
 read(iunit) pdr_frc

 ierr=0
 if (nfdr_frc(2) /= nfdr(2)) ierr=ierr+1 ! nlon
 if (nfdr_frc(3) /= nfdr(3)) ierr=ierr+1 ! nlat
 if (nfdr_frc(15) /= nfdr(15)) ierr=ierr+1 ! nlevg
 if (pdr_frc(2) /= pdr(2)) ierr=ierr+1 ! dlon
 if (pdr_frc(1) /= pdr(1)) ierr=ierr+1 ! dlat
 if (pdr_frc(39) /= pdr(39)) ierr=ierr+1 ! x0
 if (pdr_frc(38) /= pdr(38)) ierr=ierr+1 ! y0
 if (pdr_frc(5) /= pdr(5)) ierr=ierr+1 ! alon0
 if (pdr_frc(4) /= pdr(4)) ierr=ierr+1 ! alat0

 if (ierr /= 0) then
   write (*,*)
   write (*,*) "Error in header parameters in input file ,",trim(file_inp),", not coincident with defined parameters"
   write (*,*) "Model nlon, nlat, nlevg, dlon, dlat, x0, y0, alon0, alat0 :", &
 nfdr(2), nfdr(3), nfdr(15), pdr(2), pdr(1), pdr(39), pdr(38), pdr(5), pdr(4)
   write (*,*)"Read nlon, nlat, nlevg, dlon, dlat, x0, y0, alon0, alat0 :", &
 nfdr_frc(2), nfdr_frc(3), nfdr_frc(15), pdr_frc(2), pdr_frc(1), pdr_frc(39), pdr_frc(38), pdr_frc(5), pdr_frc(4)
   write (*,*)
   iflag=0
   return
 endif

 rewind (iunit)

 do while (.true.)

   iread=iread+1

   read(iunit,iostat=iread_err) nfdr_frc

   if (iread_err == 0) then

     read(iunit) pdr_frc

     call calendar (nfdr(5), nfdr(6), nfdr(7), nfdr(8), nfdr(9), nfdr(10), nfdr(11), nfdr(12), &
 iniyear, inimonth, iniday, inihour, iniminute, ndayr)

     call calendar (nfdr_frc(5), nfdr_frc(6), nfdr_frc(7), nfdr_frc(8), nfdr_frc(9), nfdr_frc(10), nfdr_frc(11), nfdr_frc(12), &
 year_frc, month_frc, day_frc, hour_frc, minute_frc, ndayr)

     if (iread == 1) then
       write (*,*)
       write (*,*) "In input ",trim(file_inp)," the following data found:"
       write (*,*) "Initialisation date and time (year, month, day, hour, minute): ", nfdr_frc(5:9)
     endif
     write (*,*) "Forecast validation date and time (year, month, day, hour, minute): ", & 
 year_frc, month_frc, day_frc, hour_frc, minute_frc

     ierr=0
     if (year_frc /= iniyear) ierr=ierr+1
     if (month_frc /= inimonth) ierr=ierr+1
     if (day_frc /= iniday) ierr=ierr+1
     if (hour_frc /= inihour) ierr=ierr+1
     if (minute_frc /= iniminute) ierr=ierr+1

     if (ierr /= 0) then

! Read all data of single check-off

       do ird=1,14
         call rrec2 (iunit, nlon, nlat, field2d_add(1:nlon,1:nlat))
       enddo
       do k=1,nlevg
         call rrec2 (iunit, nlon, nlat, field2d_add(1:nlon,1:nlat))
       enddo
       do ird=1,2
         call rrec2 (iunit, nlon, nlat, field2d_add(1:nlon,1:nlat))
       enddo
       do k=1,nlevg
         call rrec2 (iunit, nlon, nlat, field2d_add(1:nlon,1:nlat))
       enddo
       do ird=1,1
         call rrec2 (iunit, nlon, nlat, field2d_add(1:nlon,1:nlat))
       enddo
       do k=1,nlevg
         call rrec2 (iunit, nlon, nlat, field2d_add(1:nlon,1:nlat))
       enddo
       do ird=1,1
         call rrec2 (iunit, nlon, nlat, field2d_add(1:nlon,1:nlat))
       enddo
       do ird=1,6
         do k=1,nlevsnow
           call rrec2 (iunit, nlon, nlat, field2d_add(1:nlon,1:nlat))
         enddo
       enddo
       do ird = 1,15 ! Snow albedo, CSWFl, CLWFl, CHFlux, CQFlux, T2Min, T2Max, WS10Max, Runoff, Runoff total, CHFluxbottom, CWVflux, Wfluxbottom, LevSnowfall, 1 empty
         call rrec2 (iunit, nlon, nlat, field2d_add(1:nlon,1:nlat))
       enddo

     else

! Found proper data and time of forecast validation
       iflag=1
       exit

     endif

   else ! iread_err /= 0

     write (*,*)
     write (*,*) "Not found proper data and time of forecast validation in input file ",trim(file_inp) 
     write (*,*)
     iflag=0
     close (iunit)
     return

   endif ! iread_err

 enddo  

 write (str_date0,'(4(i2.2,a),i4.4)') nfdr_frc(8),':',nfdr_frc(9),' ',nfdr_frc(7),'/',nfdr_frc(6),'/',nfdr_frc(5)
 write (str_frc_term,'(a,i3,a,2(i2,a))') '+',nfdr_frc(10),'day ',nfdr_frc(11),'hour ',nfdr_frc(12),'minute'
 write (str_date_frc,'(4(i2.2,a),i4.4)') hour_frc,':',minute_frc,' ',day_frc,'/',month_frc,'/',year_frc

 do ird=1,4 ! veg_lai, veg_frac, rgm, rgq
   call rrec2 (iunit, nlon, nlat, field2d_add(1:nlon,1:nlat))
 enddo

 call rrec2 (iunit, nlon, nlat, iceth_frc(1:nlon,1:nlat))

 call rrec2 (iunit, nlon, nlat, fice_frc(1:nlon,1:nlat))

 do ird=1,6 ! albedo, emismap1, emismap2, cloudt, totpre, snfall
   call rrec2 (iunit, nlon, nlat, field2d_add(1:nlon,1:nlat))
 enddo

 call rrec2 (iunit, nlon, nlat, tsurf_frc(1:nlon,1:nlat))

 call rrec2 (iunit, nlon, nlat, tgsurf_frc(1:nlon,1:nlat))

 do k = 1,nlevg
   call rrec2 (iunit, nlon, nlat, tg_frc(1:nlon,1:nlat,k))
 enddo

 call rrec2 (iunit, nlon, nlat, qvsurf_frc(1:nlon,1:nlat))

 call rrec2 (iunit, nlon, nlat, qgsurf_frc(1:nlon,1:nlat))

 do k = 1,nlevg
   call rrec2 (iunit, nlon, nlat, qg_frc(1:nlon,1:nlat,k))
 enddo

 call rrec2 (iunit, nlon, nlat, fice_soil_surf_frc(1:nlon,1:nlat))

 do k = 1,nlevg
   call rrec2 (iunit, nlon, nlat, fice_soil_frc(1:nlon,1:nlat,k))
 enddo

 call rrec2 (iunit, nlon, nlat, snow_frc(1:nlon,1:nlat))

 do k = 1,nlevsnow
   call rrec2 (iunit, nlon, nlat, snow_lev_frc(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevsnow
   call rrec2 (iunit, nlon, nlat, snow_t_frc(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevsnow
   call rrec2 (iunit, nlon, nlat, snow_fice_frc(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevsnow
   call rrec2 (iunit, nlon, nlat, snow_age_frc(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevsnow
   call rrec2 (iunit, nlon, nlat, snow_melt_age_frc(1:nlon,1:nlat,k))
 enddo

 do k = 1,nlevsnow
   call rrec2 (iunit, nlon, nlat, snow_dens_frc(1:nlon,1:nlat,k))
 enddo

! do ird=1,13 ! snow_albedo, cswfl, clwfl, chflux, cqflux, t2min, t2max, ws10max, runoff, runoff_tot, 3 additional 2D fields 
!   call rrec2 (iunit, nlon, nlat, field2d_add(1:nlon,1:nlat))
! enddo

 close (iunit)

 write (*,*)
 write (*,*) "Soil and snow prognostic parameters (temperature, water content, ect.) values"
 write (*,*) "are read from forecast output data of run start"
 write (*,*) trim(str_date0)," forcast term ",trim(str_frc_term)," valid ",trim(str_date_frc)

return
end
!------------------------------------------------------------------------------
subroutine read_forecast_mhf_ascii_soil(iflag)

! Reads a MHF file of BOLAM with surface and soil variables 
! simulated by forecast (+24) run of previous day 

use model, only : nlon, nlat, nlevg, nlevsnow, nfdr, pdr, &
 iceth, fice, tsurf, tgsurf, tg, qvsurf, qgsurf, qg, fice_soil_surf, fice_soil, &
 snow, snow_lev, snow_t, snow_fice, snow_age, snow_melt_age, snow_dens, &
 iceth_frc, fice_frc, tsurf_frc, tgsurf_frc, tg_frc, qvsurf_frc, qgsurf_frc, qg_frc, fice_soil_surf_frc, fice_soil_frc, &
 snow_frc, snow_lev_frc, snow_t_frc, snow_fice_frc, snow_age_frc, snow_melt_age_frc, snow_dens_frc

implicit none

integer :: iflag, iunit=11, iopen_err=0, ird, ierr=0, i, j, k, ndayr, iread, &
 iniyear, inimonth, iniday, inihour, iniminute, &
 year_frc, month_frc, day_frc, hour_frc, minute_frc
character(len=30) :: file_inp="moloch_forecast_soil.dat",str_date0,str_frc_term,str_date_frc
integer, dimension(50) :: nfdr_frc
real, dimension(200)   :: pdr_frc
real, dimension(nlon,nlat) :: field2d_add, snow_albedo_rfc, runoff_tot_frc

 iflag=1

 open (iunit,file=file_inp,form='formatted',status='old',iostat=iopen_err)

 if (iopen_err /= 0) then
   write (*,*)
   write (*,*) '   Not found file ',trim(file_inp),' with forecast surface, soil and snow data' 
   write (*,*)
   iflag=0
   return
 else
   write (*,*)
   write (*,*) '   Reading on unit ',iunit,' file ',trim(file_inp),&
 ' with forecast surface, soil and snow data, variables redefinition' 
   write (*,*)
 endif

 read(iunit,1002) nfdr_frc
 read(iunit,1001) pdr_frc

 ierr=0
 if (nfdr_frc(2) /= nfdr(2)) ierr=ierr+1 ! nlon
 if (nfdr_frc(3) /= nfdr(3)) ierr=ierr+1 ! nlat
 if (nfdr_frc(15) /= nfdr(15)) ierr=ierr+1 ! nlevg
 if (pdr_frc(2) /= pdr(2)) ierr=ierr+1 ! dlon
 if (pdr_frc(1) /= pdr(1)) ierr=ierr+1 ! dlat
 if (pdr_frc(39) /= pdr(39)) ierr=ierr+1 ! x0
 if (pdr_frc(38) /= pdr(38)) ierr=ierr+1 ! y0
 if (pdr_frc(5) /= pdr(5)) ierr=ierr+1 ! alon0
 if (pdr_frc(4) /= pdr(4)) ierr=ierr+1 ! alat0

 if (ierr /= 0) then
   write (*,*)
   write (*,*) "Error in header parameters in input file ,",trim(file_inp),", not coincident with defined parameters"
   write (*,*) "Model nlon, nlat, nlevg, dlon, dlat, x0, y0, alon0, alat0 :", &
 nfdr(2), nfdr(3), nfdr(15), pdr(2), pdr(1), pdr(39), pdr(38), pdr(5), pdr(4)
   write (*,*)"Read nlon, nlat, nlevg, dlon, dlat, x0, y0, alon0, alat0 :", &
 nfdr_frc(2), nfdr_frc(3), nfdr_frc(15), pdr_frc(2), pdr_frc(1), pdr_frc(39), pdr_frc(38), pdr_frc(5), pdr_frc(4)
   write (*,*)
   iflag=0
   return
 endif

 call calendar (nfdr(5), nfdr(6), nfdr(7), nfdr(8), nfdr(9), nfdr(10), nfdr(11), nfdr(12), &
 iniyear, inimonth, iniday, inihour, iniminute, ndayr)

 call calendar (nfdr_frc(5), nfdr_frc(6), nfdr_frc(7), nfdr_frc(8), nfdr_frc(9), nfdr_frc(10), nfdr_frc(11), nfdr_frc(12), &
 year_frc, month_frc, day_frc, hour_frc, minute_frc, ndayr)

 if (iread == 1) then
   write (*,*)
   write (*,*) "In input ",trim(file_inp)," the following data found:"
   write (*,*) "Initialisation date and time (year, month, day, hour, minute): ", &
 iniyear, inimonth, iniday, inihour, iniminute
 endif
   write (*,*) "Forecast validation date and time (year, month, day, hour, minute): ", & 
   year_frc, month_frc, day_frc, hour_frc, minute_frc

 ierr=0
 if (year_frc /= iniyear) ierr=ierr+1
 if (month_frc /= inimonth) ierr=ierr+1
 if (day_frc /= iniday) ierr=ierr+1
 if (hour_frc /= inihour) ierr=ierr+1
 if (minute_frc /= iniminute) ierr=ierr+1

 if (ierr /= 0) then
   write (*,*)
   write (*,*) "Error in date and time parameters in input file ,",trim(file_inp)
   write (*,*) "Initialisation date and time (year, month, day, hour, minute): ", &
 iniyear, inimonth, iniday, inihour, iniminute
   write (*,*) "Read data valid at followind date and time (year, month, day, hour, minute): ", & 
 year_frc, month_frc, day_frc, hour_frc, minute_frc
   write (*,*) "Read initial date and time (year, month, day, hour, minute): ", nfdr_frc(5:9)
   print *,"Read forecast term (day, hour, minute): ",nfdr_frc(10:12)
   write (*,*)
   iflag=0
   return
 endif

 write (str_date0,'(4(i2.2,a),i4.4)') nfdr_frc(8),':',nfdr_frc(9),' ',nfdr_frc(7),'/',nfdr_frc(6),'/',nfdr_frc(5)
 write (str_frc_term,'(a,i3,a,2(i2,a))') '+',nfdr_frc(10),'day ',nfdr_frc(11),'hour ',nfdr_frc(12),'minute'
 write (str_date_frc,'(4(i2.2,a),i4.4)') hour_frc,':',minute_frc,' ',day_frc,'/',month_frc,'/',year_frc

 do ird=1,4 ! veg_lai, veg_frac, rgm, rgq
   do j = 1,nlat
     read(iunit,1001) (field2d_add(i,j),i=1,nlon)
   enddo
 enddo

 do j = 1,nlat
   read(iunit,1001) (iceth_frc(i,j),i=1,nlon)
 enddo
 do j = 1,nlat
   read(iunit,1001) (fice_frc(i,j),i=1,nlon)
 enddo

 do ird=1,6 ! albedo, emismap1, emismap2, cloudt, totpre, snfall
   do j = 1,nlat
     read(iunit,1001) (field2d_add(i,j),i=1,nlon)
   enddo
 enddo

 do j = 1,nlat
   read(iunit,1001) (tsurf_frc(i,j),i=1,nlon)
 enddo
 do j = 1,nlat
   read(iunit,1001) (tgsurf_frc(i,j),i=1,nlon)
 enddo
 do k = 1,nlevg
   do j = 1,nlat
     read(iunit,1001) (tg_frc(i,j,k),i=1,nlon)
   enddo
 enddo
 do j = 1,nlat
   read(iunit,1001) (qvsurf_frc(i,j),i=1,nlon)
 enddo
 do j = 1,nlat
   read(iunit,1001) (qgsurf_frc(i,j),i=1,nlon)
 enddo
 do k = 1,nlevg
   do j = 1,nlat
     read(iunit,1001) (qg_frc(i,j,k),i=1,nlon)
   enddo
 enddo
 do j = 1,nlat
   read(iunit,1001) (fice_soil_surf_frc(i,j),i=1,nlon)
 enddo
 do k = 1,nlevg
   do j = 1,nlat
     read(iunit,1001) (fice_soil_frc(i,j,k),i=1,nlon)
   enddo
 enddo
 do j = 1,nlat
   read(iunit,1001) (snow_frc(i,j),i=1,nlon)
 enddo
 do k = 1,nlevsnow
   do j = 1,nlat
     read(iunit,1001) (snow_lev_frc(i,j,k),i=1,nlon)
   enddo
 enddo
 do k = 1,nlevsnow
   do j = 1,nlat
     read(iunit,1001) (snow_t_frc(i,j,k),i=1,nlon)
   enddo
 enddo
 do k = 1,nlevsnow
   do j = 1,nlat
     read(iunit,1001) (snow_fice_frc(i,j,k),i=1,nlon)
   enddo
 enddo
 do k = 1,nlevsnow
   do j = 1,nlat
     read(iunit,1001) (snow_age_frc(i,j,k),i=1,nlon)
   enddo
 enddo
 do k = 1,nlevsnow
   do j = 1,nlat
     read(iunit,1001) (snow_melt_age_frc(i,j,k),i=1,nlon)
   enddo
 enddo
 do k = 1,nlevsnow
   do j = 1,nlat
     read(iunit,1001) (snow_dens_frc(i,j,k),i=1,nlon)
   enddo
 enddo

! do ird=1,12 ! snow_albedo, cswfl, clwfl, chflux, cqflux, t2min, t2max, runoff, runoff_tot, 3 additional 2D fields 
!   do j = 1,nlat
!     read(iunit,1001) (field2d_add(i,j),i=1,nlon)
!   enddo
! enddo

 close (iunit)

 write (*,*)
 write (*,*) "Soil and snow prognostic parameters (temperature, water content, ect.) values"
 write (*,*) "are read from forecast output data of run start"
 write (*,*) trim(str_date0)," forcast term ",trim(str_frc_term)," valid ",trim(str_date_frc)

1001 format (100e16.8)
1002 format (100i10)

return
end
!------------------------------------------------------------------------------
subroutine premoloch_surf(in)

! Elaborates input data and defines model fields of all surface/soil variables

use model
use input_data
use parameters

implicit none

real, dimension(nlon_inp,nlat_inp) :: sst_inp, sstcl_inp, fice_inp_ini, work
real, dimension(nlon,nlat) :: sst, sstcl, ts
real, dimension(nlon,nlat,nlevg_inp) :: tg_inp_mod, qg_inp_mod, tice_inp_mod
real, dimension(200) :: zlinp, zlout, zfinp, zfout
integer, dimension(200) :: iv

integer :: i, j, k, in, ng, nk, nlsnow
real :: diftop, zhtop, zlapse, zzh1, zzh2, ztlake, twater, fhard, topcr, &
        ws, fsnow, ordip, wf, thard, al, zzz, z1, z2, zterm, zterq, tland, &
        zdens_age, zdens_firn, zdens_depth

 if (nlevg_inp < 6) then
   ng = 1
 else
   ng = 2
 endif

! Definition of thick sea ice temperature at nlevg_inp levels as TG (before applying landtemp)

 tice_inp(:,:,:) = tg_inp(:,:,:)

!-----------------------------------------------------------------------
! Extrapolation of sea temperature from sea to land, using input data
! a deep soil level for defining lake temperature (SST)
!-----------------------------------------------------------------------

! Over land T is prescribed as a deep soil T (at about 50 cm)
! to be used below to define lake temperature.

 if (input_model == 'IFS'.or.input_model == 'GFS') then

   do j=1,nlat_inp
   do i=1,nlon_inp
     if (fmask_inp(i,j) >= 0.5) then
       if (input_model == 'GFS') then  ! for GFS, SST can be defined only if tsurf_inp is available
         d2_inp(i,j) = tsurf_inp(i,j)
       else
         d2_inp(i,j) = tg_inp(i,j,1)
       endif
     else
       d2_inp(i,j) = 0.5*(tg_inp(i,j,nlevg_inp/2)+tg_inp(i,j,nlevg_inp/2+1)) ! guess for T of lakes
     endif
   enddo
   enddo

 else ! GLOBO, BOLAM, MOLOCH

   do j=1,nlat_inp
   do i=1,nlon_inp
     if (fmask_inp(i,j) >= 0.5) then
       d2_inp(i,j)=tsurf_inp(i,j)
     else
       d2_inp(i,j) = 0.5*(tg_inp(i,j,4)+tg_inp(i,j,5)) ! t at about -50 cm
     endif
   enddo
   enddo

 endif

 call seatemp(d2_inp,fmask_inp,sst_inp,nlon_inp,nlat_inp,4,1,0.9)                  ! SST
 call seatemp(tg_inp(:,:,nlevg_inp),fmask_inp,sstcl_inp,nlon_inp,nlat_inp,4,1,0.9) ! reference sea temp.

!-----------------------------------------------------------------------
! Extrapolation of soil temperature and soil relative water content
! from land to sea to land for input data at all soil levels
!-----------------------------------------------------------------------

 if (minval(tsurf_inp) > 100.) call landtemp(tsurf_inp,fmask_inp,nlon_inp,nlat_inp,4,0,0.9)
 do k=1,nlevg_inp
   call landtemp(tg_inp(:,:,k),fmask_inp,nlon_inp,nlat_inp,4,0,0.9)
   call landtemp(qg_inp(:,:,k),fmask_inp,nlon_inp,nlat_inp,4,0,0.9)
 enddo

!-----------------------------------------------------------------------
! Extending fice_inp from sea to land
! Extending tice_inp from the thick sea ice area, defined where ficef >= 0.8
!-----------------------------------------------------------------------

 fice_inp_ini(:,:) = fice_inp(:,:)
 
 if (input_model == 'IFS') then

   if (maxval(fice_inp_ini) > 0.02) then
     call seatemp(fice_inp_ini,fmask_inp,fice_inp,nlon_inp,nlat_inp,3,1,0.9)
   else
     fice_inp(:,:) = 0.
   endif

   if (minval(tice_inp) > 180..and.maxval(fice_inp_ini) > 0.02) then  ! excluding case of tice_inp not defined
     do k=1,nlevg_inp
       work(:,:) = tice_inp(:,:,k)
       call seatemp(work,fice_inp_ini,tice_inp(:,:,k),nlon_inp,nlat_inp,3,1,0.9)   ! expands tice towards the ice-free sea
     enddo
   else
     do k=1,nlevg_inp
       tice_inp(:,:,k) = min(d2_inp(:,:), 271.4)  ! d2_inp contains a temperature suitable for sea and lake ice
       tice_inp(:,:,k) = max(tice_inp(:,:,k), 230.)
     enddo
   endif

 elseif (input_model == 'GFS') then

! For GFS, definition of tice_inp from tg_inp

   do j=1,nlat_inp
   do i=1,nlon_inp
     tice_inp(i,j,:) = d2_inp(i,j)  ! d2_inp contains a temperature suitable for sea and lake ice
     do k=1,nlevg_inp
       tice_inp(i,j,k) = max(tice_inp(i,j,k), t_inp(i,j,1)-12.)
       tice_inp(i,j,k) = min(tice_inp(i,j,k), 271.4)
     enddo
   enddo
   enddo

   call seatemp(fice_inp_ini,fmask_inp,fice_inp,nlon_inp,nlat_inp,3,1,0.9)
   work(:,:) = iceth_inp(:,:)
   call seatemp(work,fmask_inp,iceth_inp,nlon_inp,nlat_inp,3,1,0.9)
   do k=1,nlevg_inp
     work(:,:) = tice_inp(:,:,k)
     call seatemp(work,fice_inp_ini,tice_inp(:,:,k),nlon_inp,nlat_inp,3,1,0.9) ! expands tice_inp towards the ice-free sea
   enddo

 else ! GLOBO, BOLAM, MOLOCH

   work(:,:) = 1.
   do j=1,nlat_inp
   do i=1,nlon_inp
    if (fice_inp(i,j) > 0.8) work(i,j) = 0.
   enddo
   enddo
   do k=1,nlevg_inp
    call landtemp(tice_inp(1,1,k),work,nlon_inp,nlat_inp,4,0,0.9)
   enddo

   call seatemp(fice_inp_ini,fmask_inp,fice_inp,nlon_inp,nlat_inp,4,1,0.9)
   work(:,:) = iceth_inp(:,:)
   call seatemp(work,fmask_inp,iceth_inp,nlon_inp,nlat_inp,4,1,0.9)

 endif

!--------------------------------------------------------------------------
!          Horizontal interpolation
!--------------------------------------------------------------------------

 if (input_model == "IFS".or.input_model == "GFS") then
   al=0.7
 else ! GLOBO, BOLAM, MOLOCH
!   al=0.5
   al=1.0
 endif
 if (frame) al = 1. ! in case of data on frames only, bilinear interpolation is used

 call interp_spline_2d(sst_inp,  nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t,y_t,ntot,sst,  al)
 call interp_spline_2d(sstcl_inp,nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t,y_t,ntot,sstcl,al)
 call interp_spline_2d(snow_inp, nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t,y_t,ntot,snow, al)
 if (minval(tsurf_inp) > 100.) call interp_spline_2d(tsurf_inp,nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t,y_t,ntot,tsurf,al)
 if (input_model == "BOLAM".or.input_model == "MOLOCH") &
 call interp_spline_2d(qvsurf_inp,nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t,y_t,ntot,qvsurf,al)
 call interp_spline_2d(fice_inp, nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t,y_t,ntot,fice, al)
 call interp_spline_2d(iceth_inp,nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t,y_t,ntot,iceth,al)

 do k=1,nlevg_inp
  call interp_spline_2d(tg_inp(:,:,k),nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t,y_t, &
                        ntot,tg_inp_mod(:,:,k),al)
  call interp_spline_2d(qg_inp(:,:,k),nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t,y_t, &
                        ntot,qg_inp_mod(:,:,k),al)
  call interp_spline_2d(tice_inp(:,:,k),nlon_inp,nlat_inp,x_t_inp,y_t_inp,x_t,y_t, &
                        ntot,tice_inp_mod(:,:,k),al)
 enddo

! Modification of SST by assimilation of SST from ISAC-MYOCEAN product
! (Mediterranean and near Atlantic) - only in case of IFS or GFS input model!
! (do not use it for the BOLAM input model, because in this version the SST at
! deep output model levels is not modified, since sstcl_inp -> sstcl is used to define
! SST on such levels and not tsurf, that contains MYOCEAN sst).

  if ((input_model == "IFS".or.input_model == "GFS").and.in == 1) then 
    call sst_isac(sst,alon_t,alat_t,nlon,nlat,ntot,dlon,dlat,alon0,alat0,x0,y0,idate0)
  endif

! Reset of snow fice, iceth unfeasible values and blend of sst inland (used for lakes)

  snow(:,:)  = max(snow(:,:),0.)
  fice(:,:)  = min( max(fice(:,:), 0.), 1.)
  iceth(:,:) = max(iceth(:,:), 0.)
  do j = 1, nlat
  do i = 1, nlon
    if (fmask(i,j) < 0.1) then
      fice(i,j)=0.
      iceth(i,j)=0.
      sst(i,j) = 0.85*sst(i,j) + 0.15*0.5*(tg_inp_mod(i,j,nlevg_inp/2)+tg_inp_mod(i,j,nlevg_inp/2+1))
    endif
  enddo
  enddo

!--------------------------------------------------------------------------
!   Definition of soil variables
!--------------------------------------------------------------------------

! Vertical interpolation of soil variables from input to output model levels

 z1=sum(soil_lev_inp(1:nlevg_inp))
 z2=sum(soil_lev(1:nlevg))

 if (abs(z1-z2)>1.e-1.or.nlevg_inp<nlevg) then  ! case vertical interpolation is needed

   zlout(1:nlevg) = sqrt(soil_lev(1:nlevg))
   zlinp(1:nlevg_inp) = sqrt(soil_lev_inp(1:nlevg_inp))

   do j=1,nlat
   do i=1,nlon

! Temperature of soil and sea water

     zfinp(1:nlevg_inp) = tg_inp_mod(i,j,1:nlevg_inp)

     if (fmask(i,j) < 0.5.or.fice(i,j) >= 0.8) then

! Soil or thick sea ice

       tg(i,j,1:nlevg) = tg_first_guess(i,j,1:nlevg)

       nk = ind_lev_soil_h_bottom(i,j)

       if (soil_lev(nk) >= soil_lev_inp(nlevg_inp)+0.5) then

! The bottom temperature soil level is below the bottom soil level in input data:
! temperature at upper soil levels is defined by vertical interpolation of
! input data and temperature at lower soil level is defined by first guess temperature

         do k = 1,nk
           if (soil_lev(k) >= soil_lev_inp(nlevg_inp)+0.5) exit
         enddo
         nk = k
         zlinp(nlevg_inp+1) = sqrt(soil_lev(nk))
         zfinp(nlevg_inp+1) = tg_first_guess(i,j,nk)

         call near (zlout(1:nk), nk, zlinp(1:nlevg_inp+1), nlevg_inp+1, iv(1:nk))
         call interp_spline_1d (zfout(1:nk), zlout(1:nk), nk, zfinp(1:nlevg_inp+1), zlinp(1:nlevg_inp+1), &
 nlevg_inp+1, iv(1:nk), 0., 0., 0.)

          tg(i,j,1:nk) = zfout(1:nk)

       else

! The bottom temperature soil level is below the bottom soil level in input data:
! temperature at upper soil levels is defined by vertical interpolation of 
! input data and temperature at lower soil level is defined by first guess temperature

         call near (zlout(1:nk), nk, zlinp(1:nlevg_inp), nlevg_inp, iv(1:nk))
         call interp_spline_1d (zfout(1:nk), zlout(1:nk), nk, zfinp(1:nlevg_inp), zlinp(1:nlevg_inp), &
 nlevg_inp, iv(1:nk), 0., 0., 0.)

         tg(i,j,1:nk) = zfout(1:nk)

       endif

     else

! Sea

       call near (zlout(1:nlevg), nlevg, zlinp(1:nlevg_inp), nlevg_inp, iv(1:nlevg))
       call interp_spline_1d (zfout(1:nlevg), zlout(1:nlevg), nlevg, zfinp(1:nlevg_inp), zlinp(1:nlevg_inp), &
 nlevg_inp, iv(1:nk), 0., 0., 0.)

       tg(i,j,1:nlevg) = zfout(1:nlevg)

     endif

! Temperature of sea ice

     zfinp(1:nlevg_inp) = tice_inp_mod(i,j,1:nlevg_inp)

     call near (zlout(1:nlevg), nlevg, zlinp(1:nlevg_inp), nlevg_inp, iv(1:nlevg))
     call interp_spline_1d (zfout(1:nlevg), zlout(1:nlevg), nlevg, zfinp(1:nlevg_inp), zlinp(1:nlevg_inp), &
 nlevg_inp, iv(1:nk), 0., 0., 0.)

     tice(i,j,1:nlevg) = zfout(1:nlevg)

! Relative soil water content

     zfinp(1:nlevg_inp) = qg_inp_mod(i,j,1:nlevg_inp)

     nk = ind_lev_soil_w_bottom(i,j)

     if (nk > 0) then ! No water body, no glacier

       qg(i,j,1:nlevg) = qg_rel_first_guess(i,j,1:nlevg)

       if (soil_lev(nk) >= soil_lev_inp(nlevg_inp)+0.5) then
  
! The bottom soil water content level is below the bottom soil level in input data:
! water content at upper soil levels is defined by vertical interpolation of 
! input data and water content at lower soil level is defined by first guess temperature
  
         do k = 1,nk
           if (soil_lev(k) >= soil_lev_inp(nlevg_inp)+0.5) exit
         enddo
         nk = k
         zlinp(nlevg_inp+1) = sqrt(soil_lev(nk))
         zfinp(nlevg_inp+1) = qg_rel_first_guess(i,j,nk)
  
         call near (zlout(1:nk), nk, zlinp(1:nlevg_inp+1), nlevg_inp+1, iv(1:nk))
         call interp_spline_1d (zfout(1:nk), zlout(1:nk), nk, zfinp(1:nlevg_inp+1), zlinp(1:nlevg_inp+1), &
 nlevg_inp+1, iv(1:nk), 0., 0., 0.)
  
         qg(i,j,1:nk) = zfout(1:nk)
  
       else
  
! The bottom soil water content level is upper then bottom soil level in input data:
! water content at all soil levels is defined by vertical interpolation of input data
  
         call near (zlout(1:nk), nk, zlinp(1:nlevg_inp), nlevg_inp, iv(1:nk))
         call interp_spline_1d (zfout(1:nk), zlout(1:nk), nk, zfinp(1:nlevg_inp), zlinp(1:nlevg_inp), &
 nlevg_inp, iv(1:nk), 0., 0., 0.)
  
         qg(i,j,1:nk) = zfout(1:nk)
  
       endif

     else

       qg(i,j,1:nlevg) = 0.

     endif ! No water body, no glacier

   enddo
   enddo

 else   ! case in which the moloch soil levels are the same as input model

   tg(:,:,1:nlevg) = tg_inp_mod(:,:,1:nlevg)
   qg(:,:,1:nlevg) = qg_inp_mod(:,:,1:nlevg)
   tice(:,:,1:nlevg) = tice_inp_mod(:,:,1:nlevg)

 endif

!--------------------------------------------------------------------------

! Reset of possible unfeasible values

 tice(:,:,:)  = min(tice(:,:,:), 271.4)
 qg(:,:,:) = max(min(qg(:,:,:),1.),0.) ! relative value

! Redistribution of snow depending on orography

  if (maxval(snow) > 1.e-2) then
    call redistr_snow(snow, phig/g0, nlon, nlat, 8)
    if (in == 1) print*, "Snow redistributed depending on orography"
  endif

! Definition of surface temperature applying a linear extrapolation from
! the two lowest atmospheric levels

 do j=1,nlat
 do i=1,nlon
   if (t(i,j,1) > t(i,j,2)) then
     ts(i,j)=t(i,j,1)+(t(i,j,1)-t(i,j,2))*(zeta(i,j,1)-phig(i,j)/g0)/(zeta(i,j,2)-zeta(i,j,1))
   else
     ts(i,j)=t(i,j,1)
   endif
 enddo
 enddo

!--------------------------------------------------------------------------
!    Loop on all grid points
!--------------------------------------------------------------------------

 zzh1 = 20. + 70.*(dlat/0.12)**.5
 zzh2 = 2.*zzh1

 do j = 1, nlat
 do i = 1, nlon

   zhtop = phig(i,j)/g0

! Calculation of a weighting factor depending on the difference between
! input data topography interpolated on the model grid (PHIG_INP_MOD) and
! topography defined in model grid (PHIG). DIFTOP > 0 if PHIG_INP_MODI > PHIG.
! In case of "valley" with respect to the input data orography,
! and in winter only, the lapse rate is further reduced

   diftop = htop_inp_mod(i,j)-zhtop
   if (diftop > 0..and.coeday < 0.5) then
      zlapse=gamma*(0.5+coeday)
   else
      zlapse=gamma
   endif

! Re-definition of sst: temperature of surface water (sea, lakes, rivers, including sea ice and lake ice).
! The value is selected between sst (that is correct for open sea, but not for lakes)
! and a combination of temp. at a deep soil level (reasonable for lakes)
! as a function of fmask and topography (by a linear interpolation).
! Sst is not corrected using diftop at an altitude < zzh1.

   ztlake = 0.5*(tg(i,j,nlevg_inp-ng-1)+tg(i,j,nlevg_inp-ng-1)) + 0.65*gammac*diftop

   if (zhtop > zzh2) then
   sst(i,j) = ztlake
   elseif (zhtop > zzh1) then
   sst(i,j) = sst(i,j) + (zhtop-zzh1)*(ztlake-sst(i,j))/(zzh2-zzh1)
   endif

! Re-definition of fice (fraction of sea/lake ice with respect to the sole part of sea/lake water in the grid box)

   if (sst(i,j) < 271.4 .and. fmask(i,j) >= 0.5) fice(i,j) = max(fice(i,j), (271.4-sst(i,j))/10.) ! over sea (and lakes)
   if (sst(i,j) < 273.0 .and. fmask(i,j) >= 0.5 .and. zhtop>zzh1) &
 fice(i,j) = max(fice(i,j), (273.0-sst(i,j))/6. ) ! over higher lakes
   fice(i,j) = max( min(fice(i,j), 1.), 0.)
   if (fmask(i,j) < 0.5) fice(i,j) = 0.

   if(fice(i,j) > 0.01) then
     do k = 1,nlevg
      tice(i,j,k) = min(tice(i,j,k), sst(i,j))
     enddo
   endif

! Definition of iceth in case of IFS data, as a function of fice

   if (input_model == "IFS") then
    iceth(i,j) = -3.5 + 5.*fice(i,j)     ! sets 0.5<iceth<1.5 for 0.8<fice<1.
   endif

! Consistency reset between fice and iceth

   if(fice(i,j) < 0.8) then
     iceth(i,j) = 0.
   else
     iceth(i,j) = max(iceth(i,j), 0.5)
   endif
   iceth(i,j) = min(iceth(i,j), 3.0)

! Snow definition (in meters of equivalent water)

   fhard = 1. - fmask(i,j) + fice(i,j)*fmask(i,j)
   snow(i,j) = max(snow(i,j)*fhard, 0.)
   if (fmask(i,j) > 0.5.and.fice(i,j) < 0.5) snow(i,j) = 0.
   if (snow(i,j) < 0.0005) snow(i,j)=0.
   snow(i,j) = min(snow(i,j), 0.08 + zhtop*(0.2-0.08)/3.4e3) ! 80 cm at sea level, 2 m at 3400 m
   fsnow = min((snow(i,j)/.02)**.67, max(0.9, fice(i,j))) ! over compact sea ice, fsnow can reach 1.

! Definition of surface temperature tsurf
! Over land, the value is intermediate between TSURF from input data and the
! temperature extrapolated from the lower atmosphere TS, using a weighting factor WF,
! depending on difference between model topography and interpolated input topography

   wf = 600./(abs(diftop)+600.)

   if (tsurf(1,1) > 190..and.tsurf(1,1) < 340.) then ! there are tsurf data in input
     tland = wf*(tsurf(i,j)+zlapse*diftop) + (1.-wf)*ts(i,j)
   else ! there are not tsurf data in input
     tland = t(i,j,1)
   endif

   if (fmask(i,j) > 0.5) then
     tsurf(i,j) = sst(i,j)
   else
     tsurf(i,j) = tland
   endif

! Case of presence of snow over land or sea/lake ice

   if(fsnow > 0.05) then
   tsurf(i,j) = min(tsurf(i,j), (1.-fsnow)*tsurf(i,j) + fsnow*tzer)
   endif

! Re-definition of TG - the case of thick ice is treated as solid ground.
! For definition of orographic corrections of soil temperature at various
! levels, different lapse rates are applied, with seasonal variations decreasing
! from near the surface to deeper levels.

   if (fmask(i,j) > .5) then
    tg(i,j,:) = tsurf(i,j)
     if (input_model /= "IFS".and.input_model /= "GFS") then ! GLOBO, BOLAM, MOLOCH
      if (htop_inp_mod(i,j) < zzh1) then
        tg(i,j,2:nlevg) = sstcl(i,j) ! reference sea temp. used in the moloch soil scheme
      else
        tg(i,j,2:nlevg) = tsurf(i,j) ! on lakes above zzh1 (sstcl is not height-corrected)
      endif
     endif
   else
    tg(i,j,1) = tg(i,j,1) + 0.5*(zlapse+gammac)*diftop
    tg(i,j,2) = tg(i,j,2) + 1./3.*(zlapse+gammac+6.e-3)*diftop
    tg(i,j,3) = tg(i,j,3) + .5*(gammac+6.e-3)*diftop
    tg(i,j,4:nlevg) = tg(i,j,4:nlevg) + 6.e-3*diftop
   endif

! Redefinition of TG in case of sea/lake ice
! (important: used in the model as reference temp.)

   tg(i,j,:) = tg(i,j,:)*(1.-fice(i,j)) + tice(i,j,:)*fice(i,j)

!  Redefinition of TG in case of sea/lake thick ice

   if (fice(i,j) >= 0.8) then
     tg(i,j,1) = tice(i,j,1) + 0.5*(zlapse+gammac)*diftop
     tg(i,j,2) = tice(i,j,2) + gammac*diftop
     tg(i,j,3) = tice(i,j,3) + .5*(gammac+6.e-3)*diftop
     tg(i,j,4:nlevg) = tice(i,j,4:nlevg) + 6.e-3*diftop
   endif

! Redefinition of TG (deep levels) in case of sea/lake ice
! Case of thin ice: deep soil TG used as relaxation temp.

   if (fice(i,j) > 0.1 .and. fice(i,j) < 0.8 .and. fmask(i,j) > 0.5 .and. zhtop < zzh1) then
     tg(i,j,2:nlevg) = min(tg(i,j,2:nlevg), (1.-fice(i,j))*271.4 + fice(i,j)*tg(i,j,2:nlevg))
     tg(i,j,2:nlevg) = max(tg(i,j,2:nlevg), (1.-fice(i,j))*271.4 + fice(i,j)*247.)
   elseif(fice(i,j) > 0.1 .and. fice(i,j) < 0.8 .and. fmask(i,j) > 0.5 .and. zhtop >= zzh1) then
     tg(i,j,2:nlevg) = min(tg(i,j,2:nlevg), (1.-fice(i,j))*273.1 + fice(i,j)*tg(i,j,2:nlevg))
     tg(i,j,2:nlevg) = max(tg(i,j,2:nlevg), (1.-fice(i,j))*273.1 + fice(i,j)*247.)
   endif

! Case of thick ice: all soil TG defined as in soil/glacier scheme

   if (fice(i,j) >= 0.8 .and. fmask(i,j) > 0.5 .and. zhtop < zzh1) then
     do k = 2, nlevg
       tg(i,j,k) = tg(i,j,1) + (soil_lev(k)-soil_lev(1))*(271.4-tg(i,j,1))/(soil_lev(nlevg)-soil_lev(1))
     enddo
    elseif (fice(i,j) >= 0.8 .and. fmask(i,j) > 0.5 .and. zhtop >= zzh1) then
      do k = 2, nlevg
        tg(i,j,k) = tg(i,j,1) + (soil_lev(k)-soil_lev(1))*(273.1-tg(i,j,1))/(soil_lev(nlevg)-soil_lev(1))
      enddo
    endif

! Glaciers: T must remain below 0 degC.
! (NST-1=14, but NST-1 used here in case new soil types are introduced)

   if (fmask(i,j) <= 0.5.and.soil_map(i,j,1) == nst-1) then
    tsurf(i,j) = min(tsurf(i,j),273.15)
    tg(i,j,1) = min(tg(i,j,1),273.1)
    tg(i,j,2) = min(tg(i,j,2),273.)
    tg(i,j,3) = min(tg(i,j,3),273.)
    tg(i,j,2:nlevg) = min(tg(i,j,2:nlevg),273.)
   endif

! Snow reduction over land as a function of TG(1) and TS
! and redefinition of TSURF

   zzz = 0.8*tg(i,j,1)+0.2*ts(i,j)
   if (zzz > 278..and.fmask(i,j) <0.5) then
   snow(i,j)=0.
   tsurf(i,j) = tland
   endif

! Defintion of soil temperature at the soil top

   if (snow(i,j) < 0.01) then
     tgsurf(i,j)=tsurf(i,j)
   else
     tgsurf(i,j)=min(tg(i,j,1), 273.)
   endif

! Definition of ice fraction in soil water content

   fice_soil(i,j,:)=0.
   if (fmask(i,j) < 0.5.or.fice(i,j) >= 0.8) then
     if (fice(i,j) >= 0.8.or.int(soil_map(i,j,1)) == nst-1) then ! Glaciers and thick sea ice (sea glacier)
       fice_soil(i,j,:)=1.
       fice_soil_surf(i,j)=1.
     else ! Soil
       call frac_soil_ice_point(tgsurf(i,j), fice_soil_surf(i,j), soil_par_b(i,j,1))
       do k = 1, ind_lev_soil_h_bottom(i,j)
         call frac_soil_ice_point(tg(i,j,k), fice_soil(i,j,k), soil_par_b(i,j,k))
       enddo
     endif
   endif

! Definition of QG
! Transf. from relative QG to absolute QG

   if (fmask(i,j) <= 0.5) then
     qg(i,j,1:nlevg) = qg(i,j,1:nlevg)*(soil_qmax(i,j,1:nlevg)-soil_qmin(i,j,1:nlevg)) + soil_qmin(i,j,1:nlevg)
   else
    qg(i,j,:) = 1.
   endif

   qgsurf(i,j) = qg(i,j,1)

! Soil water content definition for water bodies: sea, lakes, rivers, glaciers

   if (fmask(i,j) > 0.5.or.int(soil_map(i,j,1)) >= nst-1) qg(i,j,1:nlevg) = 1.

! Definition of roughness length (over ice-free sea it is redefined in the model)

   if (fmask(i,j) > .5) then
   ordip = 0.
   else
   ordip = min (2.5e-5*htopvar(i,j)**2, 6.)
   endif

   zterm = max(m_rough(i,j), ordip*0.1, 0.02 )
   zterq = max(q_rough(i,j), ordip*0.1, 0.015)
   rgm(i,j) = (1. - fmask(i,j))*zterm + fmask(i,j)*(2.e-2*fice(i,j) + 2.e-4*(1.-fice(i,j)))
   rgq(i,j) = (1. - fmask(i,j))*zterq + fmask(i,j)*(2.e-2*fice(i,j) + 2.e-4*(1.-fice(i,j)))

! Denition of snow variables at snow levels
! 1-st level is snow top, bottom level is soil surface

   if (int(soil_map(i,j,1)) == nst-1) snow(i,j)=0.03 ! minimum 30 cm snow layer over a glacier

   snow(i,j)=snow(i,j)*1.e3
   call snow_lev_def(snow(i,j), nlsnow, snow_lev(i,j,:))
   snow(i,j)=snow(i,j)*1.e-3

! Definition of snow variables

   snow_t(i,j,:) = val_missing
   snow_fice(i,j,:) = val_missing
   snow_age(i,j,:) = val_missing
   snow_melt_age(i,j,:) = val_missing
   snow_dens(i,j,:) = val_missing

   if (nlsnow > 0) then
     snow_t(i,j,1) = min(tsurf(i,j), 273.)
     if (nlsnow < 2) then
       snow_t(i,j,1:2) = min(tg(i,j,1), 273.)
     else
       snow_t(i,j,nlsnow+1) = min(tg(i,j,1), 273.)
       z1=1./float(nlsnow+1)
       do k=2,nlsnow
         snow_t(i,j,k) = snow_t(i,j,1)*(1.-z1*float(k-1)) + snow_t(i,j,nlsnow+1)*z1*float(k-1)
       enddo
     endif
     snow_fice(i,j,1:nlsnow+1) = 1.
     snow_age(i,j,1:nlsnow+1) = 10. ! days
     snow_melt_age(i,j,1:nlsnow+1) = 0. ! days
     if (fmask(i,j) < 0.5.and.int(soil_map(i,j,1)) == nst-1) then ! glacier
       snow_age(i,j,1:nlsnow+1) = 180. ! days
       snow_melt_age(i,j,1:nlsnow+1) = 30. ! days
     endif
     if (fmask(i,j) >= 0.5.and.fice(i,j) >= 0.8) then ! thick sea ice
       snow_age(i,j,1:nlsnow+1) = 180. ! days
       snow_melt_age(i,j,1:nlsnow+1) = 0. ! days
     endif
     do k=1,nlsnow+1
! 150 kg/m^3 fresh snow density; 800 kg/m^3 old snow density; 850 kg/m^3 firn dencity
       zdens_age = max( min(((snow_age(i,j,k)/365.)**0.3), 1.)*800., 150.)
       zdens_firn = max( min((((snow_melt_age(i,j,k)+30.)/395.)**0.3), 1.)*850., zdens_age) 
       zdens_depth = min( 1.+0.5*(snow_lev(i,j,k)/100.)**0.5, 1.5)
       snow_dens(i,j,k) = min(zdens_firn*zdens_depth, 850.)
     enddo
   endif

 enddo
 enddo

! Using of forecast soil/snow data in place of analysis data 

  call read_forecast_mhf_soil(iflag_soil_snow_frc)
!  call read_forecast_mhf_ascii_soil(iflag_soil_snow_frc)

  write (*,*)
  if (iflag_soil_snow_frc == 1) then

    do j=1,nlat
    do i=1,nlon

      tsurf_copy(i,j)=tsurf(i,j)
      tg_copy(i,j,1:nlevg)=tg(i,j,1:nlevg)

      if (fmask(i,j) < 0.5 ) then ! land or temperary sea glacier

        tsurf(i,j) = tsurf_frc(i,j)
        tgsurf(i,j) = tgsurf_frc(i,j)
        tg(i,j,1:nlevg) = tg_frc(i,j,1:nlevg)
        qvsurf(i,j) = qvsurf_frc(i,j)
        qgsurf(i,j) = qgsurf_frc(i,j)
        qg(i,j,1:nlevg) = qg_frc(i,j,1:nlevg)
        fice_soil_surf(i,j) = fice_soil_surf_frc(i,j)
        fice_soil(i,j,1:nlevg) = fice_soil_frc(i,j,1:nlevg)
        snow_lev(i,j,1:nlevsnow) = val_missing
        snow_t(i,j,1:nlevsnow) = val_missing
        snow_fice(i,j,1:nlevsnow) = val_missing
        snow_age(i,j,1:nlevsnow) = val_missing
        snow_melt_age(i,j,1:nlevsnow) = val_missing
        snow_dens(i,j,1:nlevsnow) = val_missing
        do k=1,nlevsnow
          if (int(snow_t_frc(i,j,k)) == int(val_missing)) exit
        enddo
        nk=k-1
        if (nk >= 1) then
          snow_lev(i,j,1:nk) = snow_lev_frc(i,j,1:nk)
          snow_t(i,j,1:nk) = snow_t_frc(i,j,1:nk)
          snow_fice(i,j,1:nk) = snow_fice_frc(i,j,1:nk)
          snow_age(i,j,1:nk) = snow_age_frc(i,j,1:nk)
          snow_melt_age(i,j,1:nk) = snow_melt_age_frc(i,j,1:nk)
          snow_dens(i,j,1:nk) = snow_dens_frc(i,j,1:nk)
          snow(i,j) = snow_lev(i,j,nk)*1.e-3
        else
          snow(i,j) = 0.
        endif

      endif ! land

! Case of change grid point status:
! "sea glacier" turn to sea point status, or
! sea icea becames "sea glacier", transfers to land point status

      if (fmask(i,j) >= 0.5) then ! sea

        if (fice_frc(i,j) < 0.8.and.fice(i,j) >= 0.8) then ! sea point became temporary sea glacier

          soil_psi(i,j,:) = 2.2 ! thermal conductivity of ice
          soil_albedo_dry(i,j) = 0.4
          soil_albedo_wet(i,j) = 0.4

          do k = 1, nlevg
            if (soil_lev(k) > iceth(i,j)) exit
          enddo
          ind_lev_soil_h_bottom(i,j) = max(k-1, 3)
          ind_lev_soil_w_bottom(i,j) = 0

          tsurf(i,j) = min(tsurf(i,j), 273.0)
          do k = 1, ind_lev_soil_h_bottom(i,j)
            tg(i,j,k) = min(tg(i,j,k), 273.0)
          enddo

          fice_soil(i,j,:) = 1.
          fice_soil_surf(i,j) = 1.

          snow(i,j) = max (0.05, snow(i,j))
          snow(i,j)=snow(i,j)*1.e3
          call snow_lev_def(snow(i,j), nlsnow, snow_lev(i,j,:))
          snow(i,j)=snow(i,j)*1.e-3
          snow_t(i,j,:) = val_missing
          snow_fice(i,j,:) = val_missing
          snow_age(i,j,:) = val_missing
          snow_melt_age(i,j,:) = val_missing
          snow_dens(i,j,:) = val_missing
          if (nlsnow > 0) then
            snow_t(i,j,1) = min(tsurf(i,j), 273.)
            if (nlsnow < 2) then
              snow_t(i,j,1) = min(tg(i,j,1), 273.)
            else
              snow_t(i,j,nlsnow+1) = min(tg(i,j,1), 273.)
              z1=1./float(nlsnow+1)
              do k=2,nlsnow
                snow_t(i,j,k) = snow_t(i,j,1)*(1.-z1*float(k-1)) + snow_t(i,j,nlsnow+1)*z1*float(k-1)
              enddo
            endif
            snow_fice(i,j,1:nlsnow+1) = 1.
            snow_age(i,j,1:nlsnow+1) = 180. ! days
            snow_melt_age(i,j,1:nlsnow+1) = 0. ! days
          endif

        endif ! sea point became temporary sea glacier

        if (fice_frc(i,j) >= 0.8.and.fice(i,j) < 0.8) then ! temporary sea glacier turn to sea point status

          soil_psi(i,j,:) = 0. ! thermal conductivity of ice
          soil_albedo_dry(i,j) = 0.4
          soil_albedo_wet(i,j) = 0.4

          ind_lev_soil_h_bottom(i,j) = 0
          ind_lev_soil_w_bottom(i,j) = 0

          tsurf(i,j) = tsurf_copy(i,j)
          tg(i,j,1:nlevg) = tg(i,j,1:nlevg)

          fice_soil(i,j,:) = 0.
          fice_soil_surf(i,j) = 0.

          snow(i,j) = 0.
          snow_lev(i,j,:) = val_missing
          snow_t(i,j,:) = val_missing
          snow_fice(i,j,:) = val_missing
          snow_age(i,j,:) = val_missing
          snow_melt_age(i,j,:) = val_missing
          snow_dens(i,j,:) = val_missing

        endif ! temporary sea glacier turn to sea point status

      endif ! sea

    enddo
    enddo
    
    write (*,*) "Soil and snow prognostic parameters (temperature, water content, ect.) "
    write (*,*) "are initialisated with forecast data generated by a preceded model run"

  else ! iflag_soil_snow_frc

    write (*,*) "Soil and snow prognostic parameters (temperature, water content, ect.) are initialisated with analysis data"
    write (*,*) "    Cold soil and snow start" 

  endif ! iflag_soil_snow_frc
  write (*,*)

! Definition of radiative parameters at the surface

 call surfradpar(fmask, fice, qg(:,:,1), veg_map, soil_qmax(:,:,1), soil_qmin(:,:,1), &
 soil_albedo_dry, soil_albedo_wet, soil_emiss1_dry, soil_emiss1_wet, soil_emiss2_dry, soil_emiss2_wet, &
 veg_frac, veg_albedo, veg_emiss1, veg_emiss2, &
 nlon, nlat, nlevg, nvt, 1, albedo, emismap1, emismap2)

! Redefinition of QVSURF as intermediate between the interpolated value and lowest level humidity

 if (input_model == "IFS".or.input_model == "GFS") then
   qvsurf(:,:) = q(:,:,1)
 else ! GLOBO, BOLAM, MOLOCH
   qvsurf(:,:) = 0.5*q(:,:,1) + 0.5*qvsurf(:,:)
 endif

 cloudt(:,:)  = 0.
 totpre(:,:)  = 0.
 snfall(:,:)  = 0.
 runoff(:,:)  = 0.
 cswfl(:,:)   = 0.
 clwfl(:,:)   = 0.
 chflux(:,:)  = 0.
 cqflux(:,:)  = 0.
 t2min(:,:)   = 0.
 t2max(:,:)   = 0.
 ws10max(:,:) = 0.

return
end
!########################################################################################################
    subroutine filt (p, nlon, nlat, nlev)

    real p(nlon,nlat,nlev), p2(nlon,nlat)

!-----------------------
!  Horizontal diffusion
!-----------------------

    do 50 k = 1, nlev

    do jlat = 1, nlat
    do jlon = 2, nlon-1
    p2(jlon,jlat) = .25*(p(jlon-1,jlat,k)+p(jlon+1,jlat,k))+.5*p(jlon,jlat,k)
    enddo
    enddo

    do jlat = 2, nlat-1
    do jlon = 2, nlon-1
    p(jlon,jlat,k) = .25*(p2(jlon,jlat+1)+p2(jlon,jlat-1))+.5*p2(jlon,jlat)
    enddo
    enddo

    p(2:nlon-1,1   ,k) = p2(2:nlon-1,   1)
    p(2:nlon-1,nlat,k) = p2(2:nlon-1,nlat)

50  continue

    return
    end
!=======================================================================
   subroutine h_inter (a, nx, ny, xi, yi, xo, yo, nxo, nyo, f)

!  Horizontal bilinear interpolation between 2-D grids
!  Version to interpolate from a regular grid in input
!  with prescribed values defined in A(NX,NY) and with coordinates in XI and YI
!  (but note that only XI(1), XI(2), YI(1) and YI(2) are used to compute the
!  coordinates of the input grid) to points of coordinates XO,YO.
!  Output values defined in vector F(nxo,nyo).

   real a(nx,ny), xi(nx), yi(ny), xo(nxo,nyo), yo(nxo,nyo), f(nxo,nyo)

   dx  = xi(2)-xi(1)
   dy  = yi(2)-yi(1)
   dxr = 1./dx
   dyr = 1./dy

   do jo = 1, nyo
   do io = 1, nxo
   i = int((xo(io,jo)-xi(1))*dxr+1.0)
   j = int((yo(io,jo)-yi(1))*dyr+1.0)
   ip1 = min(i+1,nx)
   jp1 = min(j+1,ny)
   x = (xo(io,jo)-xi(i))*dxr
   y = (yo(io,jo)-yi(j))*dyr
   f1 = a(i,j  ) + x*(a(ip1,j  )-a(i,j  ))
   f2 = a(i,jp1) + x*(a(ip1,jp1)-a(i,jp1))
   f(io,jo) = f1 + y*(f2-f1)
   enddo
   enddo

   return
   end subroutine h_inter
!=======================================================================
 subroutine sst_isac(ssti,xxt,yyt,nlon,nlat,ntot,dlon,dlat,alon0,alat0,x0d,y0d,idate0)

! Defines SST on the a ISAC model (Bolam, Moloch) grid, using matrix of data SST ISAC-MYOCEAN on the Mediterranean, Black Sea
! and a portion of near Atlantic, combining it with the ECMWF or GFS SST analysis
! SST data are in deg. C /100, 2 byte integers. Missing values: <-999 (including the ext. framework)
! Lat.-lon. regular grid, step 1/16 deg (0.0625 deg).
! Grid dimensions: 1441x721 (not read in the sst file - must be written explicitely below)
! Grid extremes: lat 20.0, 65.0; lon -35.0, 55.0 (not read in the sst file: min. lat and lon written explicitely below)

parameter(im=1441,jm=721)    ! dimensions of the input grid
integer*2 sst_med(im,jm)
real sst_ext(im,jm), fmask_ext(im,jm), workf(im,jm), fmask_w(im,jm)
real xe_ext(im), ye_ext(jm)
real xxt(nlon,nlat), yyt(nlon,nlat), ssti(nlon,nlat), fmaski(nlon,nlat), work(nlon,nlat), work2(nlon,nlat)
integer, dimension(5) :: idate0
character*12 filesst
integer, dimension(12) :: imon=(/31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31/) ! odd years not considered!
integer today, yesterday, day_bef_yesterday
logical ex

! Reading of SST data file (name: yyyymmdd.dat)

filesst(9:12) = ".dat"

! SST files are taken into account to define the sst only if the data is today or yesterday or
! day before yesterday, otherwise the sst of the input model is not modified

! idate0(3): day of month; idate0(2): month; idate0(1): year (4 digits)

if(mod(idate0(1),4).eq.0) imon(2)=29 ! to take into account (most) odd years
today = idate0(3) + idate0(2)*100 + idate0(1)*10000
!print*, "today", today
write (filesst(1:8), '(i8.8)') today
inquire(file=filesst, exist=ex)
if(ex.eqv..true.) then           ! case of sst file of today
open (10, file=filesst, status='old', form='unformatted', err=105)
else
yesterday = idate0(3)-1 + idate0(2)*100 + idate0(1)*10000
if(idate0(2).eq.1.and.idate0(3).eq.1) yesterday = 31 + 12*100 + (idate0(1)-1)*10000 ! case 1st Jan
do iii = 2,12
if(idate0(2).eq.iii.and.idate0(3).eq.1) yesterday = imon(iii-1) + (iii-1)*100 + idate0(1)*10000 ! feb. to dec.
enddo
!print*, "yesterday", yesterday
write (filesst(1:8), '(i8.8)') yesterday
inquire(file=filesst, exist=ex)
if(ex.eqv..true.) then           ! case of sst file of yesterday
open (10, file=filesst, status='old', form='unformatted', err=105)
else
day_bef_yesterday = idate0(3)-2 + idate0(2)*100 + idate0(1)*10000
if(idate0(2).eq.1.and.idate0(3).eq.1) day_bef_yesterday = 30 + 12*100 + (idate0(1)-1)*10000 ! case 1st Jan
if(idate0(2).eq.1.and.idate0(3).eq.2) day_bef_yesterday = 31 + 12*100 + (idate0(1)-1)*10000 ! case 2nd Jan
do iii = 2,12
if(idate0(2).eq.iii.and.idate0(3).eq.1) day_bef_yesterday = imon(iii-1)-1 + (iii-1)*100 + idate0(1)*10000 ! feb. to dec.
if(idate0(2).eq.iii.and.idate0(3).eq.2) day_bef_yesterday = imon(iii-1) + (iii-1)*100 + idate0(1)*10000 ! feb. to dec.
enddo
!print*, "day_bef_yesterday", day_bef_yesterday
write (filesst(1:8), '(i8.8)') day_bef_yesterday
inquire(file=filesst, exist=ex)
if(ex.eqv..true.) then           ! case of sst file of day before yesterday
open (10, file=filesst, status='old', form='unformatted', err=105)
else
print*
print*, "File with SST ISAC-MYOCEAN not found or date not suitable"
print*

return
endif
endif
endif

read (10) sst_med
print*
print*, "File ", filesst, " with the ISAC-MYOCEAN SST read, to be used to define SST"
print*

do j = 1,jm
do i = 1,im
if(sst_med(i,j).lt.-50) then
sst_med(i,j) = -9999
fmask_ext(i,j) = 0.
else
fmask_ext(i,j) = 1.
endif
enddo
enddo

! Comput. of average sst in valid points, to be attributed to invalid points
! (land or boundaries or not covered area in north Atlantic)

t_aver = 0
icount = 0
do j = 1,jm
do i = 1,im
if(fmask_ext(i,j).gt.0.5) then
t_aver = t_aver + sst_med(i,j)
icount = icount + 1
endif
enddo
enddo
t_aver = t_aver/float(icount)
print*, "Average SST in file ", filesst, " in C:", t_aver/100.

do j = 1,jm
do i = 1,im
if(fmask_ext(i,j).lt.0.5) sst_med(i,j) = t_aver
enddo
enddo

! T in degrees Kelvin

sst_ext = float(sst_med)/100. + 273.15
tav = t_aver/100. + 273.15

!call plotout(sst_ext-273.15,ime,jme,99)

! Extension of SST values towards the land or to invalid areas

workf = sst_ext
call seatemp(workf,fmask_ext,sst_ext,im,jm,6,2,0.6)

workf = fmask_ext
call seatemp(workf,fmask_ext,fmask_w,im,jm,6,1,1.)  ! define fmask_w as an extended fmask towards land or invalid areas

!call plotout(sst_ext-273.15,ime,jme,99)

! Interpolation on the output grid

do i = 1,im
xe_ext(i) = -35.+(i-1)*0.0625
enddo

do j = 1,jm
ye_ext(j) = 20.+(j-1)*0.0625
enddo

! Check of geographical coordinates: the sst extended grid must cover the full model domain,
! otherwise it is not used (the check is based on the above chosen coordinates of the extended domain)

if(minval(xxt).lt.minval(xe_ext).or.maxval(xxt).gt.maxval(xe_ext).or.   &
   minval(yyt).lt.minval(ye_ext).or.maxval(yyt).gt.maxval(ye_ext)) then
print*, "Data of the ISAC-MYOCEAN SST file do not cover the MOLOCH grid"
print*, " and therefore are discarded and not used to define SST"
print*, "Min. MOLOCH long.", minval(xxt), "Max. MOLOCH long.", maxval(xxt)
print*, "Min. MOLOCH lat.", minval(yyt), "Max. MOLOCH lat.", maxval(yyt)
print*, "Min. SST data long.", minval(xe_ext), "Max. SST data long.", maxval(xe_ext)
print*, "Min. SST data lat.", minval(ye_ext), "Max. SST data lat.", maxval(ye_ext)
return
endif

call interp_spline_2d(sst_ext,im,jm,xe_ext,ye_ext,xxt,yyt,ntot,work,0.8)
call interp_spline_2d(fmask_w,im,jm,xe_ext,ye_ext,xxt,yyt,ntot,fmaski,0.8) ! fmaski computed from interpol. of the extended fmask_w
fmaski = min(1., fmaski)
fmaski = max(0., fmaski)

!call plotout(work-273.15,nlon,nlat,99)

call smooth_soil(work,work2,nlon,nlat,0.5,2)

!call plotout(work-273.15,nlon,nlat,99)
!call plotout(ssti-273.15,nlon,nlat,99)

! Combination of ssti computed with GFS analysis data and of sst computed with observation data
! wei is the weight to be attributed to the MY-OCEAN product.
! Note that matrix work does not contain values useful to define temp. of lakes inland.
! Note also that fmaski is different from fmask (so 0.7 is used in place of 0.5).

wei = 0.88
do jlat = 1,nlat
do jlon = 1,nlon
if(fmaski(jlon,jlat).gt.0.7) ssti(jlon,jlat) = (1.-wei)*ssti(jlon,jlat) + wei*work(jlon,jlat)
enddo
enddo
!call plotout(ssti-273.15,nlon,nlat,99)
close (10)
return

105 print*, "File with SST ISAC-MYOCEAN existing but unreadable"
return
end
! ======================================================================
